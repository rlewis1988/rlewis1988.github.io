<!DOCTYPE html><html lang="en"><head><title>category_theory.products.basic</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/category_theory/index.html">category_theory</a>/<br><a href="https://robertylewis.com/mathlib_docs/category_theory/products/index.html">products</a>/<br><a href="basic.html">basic</a></div><div class="mod_doc"><p></p>
</div><div class="def"><a id="category_theory.prod"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L21">category_theory.prod</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> (C × D)</div>
<div class="indent"><p><code>prod C D</code> gives the cartesian product of two categories.</p>
       Attributes: instance</div>
</div><div class="thm"><a id="category_theory.prod_id"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L27">category_theory.prod_id</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X : C)</span> <span class="decl_args">(Y : D)</span> <span class="decl_args">:</span>       <div class="decl_type">𝟙 (X, Y) = (𝟙 X, 𝟙 Y)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L28">category_theory.prod_comp</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{P Q R : C}</span> <span class="decl_args">{S T U : D}</span> <span class="decl_args">(f : (P, S) ⟶ (Q, T))</span> <span class="decl_args">(g : (Q, T) ⟶ (R, U))</span> <span class="decl_args">:</span>       <div class="decl_type">f ≫ g = (f.fst ≫ g.fst, f.snd ≫ g.snd)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod_id_fst"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L30">category_theory.prod_id_fst</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X : C × D)</span> <span class="decl_args">:</span>       <div class="decl_type">(𝟙 X).fst = 𝟙 (X.fst)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod_id_snd"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L31">category_theory.prod_id_snd</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X : C × D)</span> <span class="decl_args">:</span>       <div class="decl_type">(𝟙 X).snd = 𝟙 (X.snd)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod_comp_fst"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L32">category_theory.prod_comp_fst</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{X Y Z : C × D}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(g : Y ⟶ Z)</span> <span class="decl_args">:</span>       <div class="decl_type">(f ≫ g).fst = f.fst ≫ g.fst</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod_comp_snd"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L34">category_theory.prod_comp_snd</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{X Y Z : C × D}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(g : Y ⟶ Z)</span> <span class="decl_args">:</span>       <div class="decl_type">(f ≫ g).snd = f.snd ≫ g.snd</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.uniform_prod"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L44">category_theory.uniform_prod</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₁)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> (C × D)</div>
<div class="indent"><p><code>prod.category.uniform C D</code> is an additional instance specialised so both factors have the same universe levels. This helps typeclass resolution.</p>
       Attributes: instance</div>
</div><div class="thm"><a id="category_theory.prod.inl_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L56">category_theory.prod.inl_obj</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(Z : D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.inl">category_theory.prod.inl</a> C D Z).obj X = (X, Z)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.prod.inl"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L56">category_theory.prod.inl</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(Z : D)</span> <span class="decl_args">:</span>       <div class="decl_type">C ⥤ C × D</div>
<div class="indent"><p><code>inl C Z</code> is the functor <code>X ↦ (X, Z)</code>.</p>
       </div>
</div><div class="thm"><a id="category_theory.prod.inl_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L56">category_theory.prod.inl_map</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(Z : D)</span> <span class="decl_args">(X Y : C)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.inl">category_theory.prod.inl</a> C D Z).map f = (f, 𝟙 Z)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.prod.inr"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L61">category_theory.prod.inr</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(Z : C)</span> <span class="decl_args">:</span>       <div class="decl_type">D ⥤ C × D</div>
<div class="indent"><p><code>inr D Z</code> is the functor <code>X ↦ (Z, X)</code>.</p>
       </div>
</div><div class="thm"><a id="category_theory.prod.inr_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L61">category_theory.prod.inr_obj</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(Z : C)</span> <span class="decl_args">(X : D)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.inr">category_theory.prod.inr</a> C D Z).obj X = (Z, X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod.inr_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L61">category_theory.prod.inr_map</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(Z : C)</span> <span class="decl_args">(X Y : D)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.inr">category_theory.prod.inr</a> C D Z).map f = (𝟙 Z, f)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.prod.fst"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L66">category_theory.prod.fst</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type">C × D ⥤ C</div>
<div class="indent"><p><code>fst</code> is the functor <code>(X, Y) ↦ X</code>.</p>
       </div>
</div><div class="thm"><a id="category_theory.prod.fst_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L66">category_theory.prod.fst_obj</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X : C × D)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.fst">category_theory.prod.fst</a> C D).obj X = X.fst</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod.fst_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L66">category_theory.prod.fst_map</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X Y : C × D)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.fst">category_theory.prod.fst</a> C D).map f = f.fst</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod.snd_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L71">category_theory.prod.snd_map</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X Y : C × D)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.snd">category_theory.prod.snd</a> C D).map f = f.snd</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod.snd_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L71">category_theory.prod.snd_obj</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X : C × D)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.snd">category_theory.prod.snd</a> C D).obj X = X.snd</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.prod.snd"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L71">category_theory.prod.snd</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type">C × D ⥤ D</div>
<div class="indent"><p><code>snd</code> is the functor <code>(X, Y) ↦ Y</code>.</p>
       </div>
</div><div class="thm"><a id="category_theory.prod.swap_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L75">category_theory.prod.swap_obj</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X : C × D)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.swap">category_theory.prod.swap</a> C D).obj X = (X.snd, X.fst)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.prod.swap"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L75">category_theory.prod.swap</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type">C × D ⥤ D × C</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.prod.swap_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L75">category_theory.prod.swap_map</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(_x _x_1 : C × D)</span> <span class="decl_args">(f : _x ⟶ _x_1)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.swap">category_theory.prod.swap</a> C D).map f = (f.snd, f.fst)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod.symmetry_hom_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L79">category_theory.prod.symmetry_hom_app</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X : C × D)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.symmetry">category_theory.prod.symmetry</a> C D).hom).app X = 𝟙 X</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.prod.symmetry_inv_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L79">category_theory.prod.symmetry_inv_app</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X : C × D)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.symmetry">category_theory.prod.symmetry</a> C D).inv).app X = 𝟙 X</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.prod.symmetry"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L79">category_theory.prod.symmetry</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.swap">category_theory.prod.swap</a> C D ⋙ <a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.swap">category_theory.prod.swap</a> D C ≅ 𝟭 (C × D)</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.prod.braiding"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L83">category_theory.prod.braiding</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type">C × D ≌ D × C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.prod.swap_is_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L88">category_theory.prod.swap_is_equivalence</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.prod.swap">category_theory.prod.swap</a> C D)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="thm"><a id="category_theory.evaluation_map_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L97">category_theory.evaluation_map_app</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X Y : C)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.evaluation">category_theory.evaluation</a> C D).map f).app F = F.map f</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.evaluation"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L97">category_theory.evaluation</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type">C ⥤ (C ⥤ D) ⥤ D</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.evaluation_obj_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L97">category_theory.evaluation_obj_obj</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X : C)</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.evaluation">category_theory.evaluation</a> C D).obj X).obj F = F.obj X</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.evaluation_obj_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L97">category_theory.evaluation_obj_map</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(X : C)</span> <span class="decl_args">(F G : C ⥤ D)</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.evaluation">category_theory.evaluation</a> C D).obj X).map α = α.app X</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.evaluation_uncurried_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L105">category_theory.evaluation_uncurried_obj</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(p : C × (C ⥤ D))</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.evaluation_uncurried">category_theory.evaluation_uncurried</a> C D).obj p = (p.snd).obj (p.fst)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.evaluation_uncurried_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L105">category_theory.evaluation_uncurried_map</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(x y : C × (C ⥤ D))</span> <span class="decl_args">(f : x ⟶ y)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.evaluation_uncurried">category_theory.evaluation_uncurried</a> C D).map f = (x.snd).map (f.fst) ≫ (f.snd).app (y.fst)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.evaluation_uncurried"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L105">category_theory.evaluation_uncurried</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type">C × (C ⥤ D) ⥤ D</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.functor.prod_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L126">category_theory.functor.prod_map</a></span> <span class="decl_args">{A : Type u₁}</span> <span class="decl_args">[𝒜 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> A]</span> <span class="decl_args">{B : Type u₂}</span> <span class="decl_args">[ℬ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> B]</span> <span class="decl_args">{C : Type u₃}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₄}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : A ⥤ B)</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">(_x _x_1 : A × C)</span> <span class="decl_args">(f : _x ⟶ _x_1)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.functor.prod">category_theory.functor.prod</a> F G).map f = (F.map (f.fst), G.map (f.snd))</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.functor.prod_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L126">category_theory.functor.prod_obj</a></span> <span class="decl_args">{A : Type u₁}</span> <span class="decl_args">[𝒜 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> A]</span> <span class="decl_args">{B : Type u₂}</span> <span class="decl_args">[ℬ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> B]</span> <span class="decl_args">{C : Type u₃}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₄}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : A ⥤ B)</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">(X : A × C)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.functor.prod">category_theory.functor.prod</a> F G).obj X = (F.obj (X.fst), G.obj (X.snd))</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.functor.prod"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L126">category_theory.functor.prod</a></span> <span class="decl_args">{A : Type u₁}</span> <span class="decl_args">[𝒜 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> A]</span> <span class="decl_args">{B : Type u₂}</span> <span class="decl_args">[ℬ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> B]</span> <span class="decl_args">{C : Type u₃}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₄}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : A ⥤ B)</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">:</span>       <div class="decl_type">A × C ⥤ B × D</div>
<div class="indent"><p>The cartesian product of two functors.</p>
       </div>
</div><div class="def"><a id="category_theory.nat_trans.prod"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L138">category_theory.nat_trans.prod</a></span> <span class="decl_args">{A : Type u₁}</span> <span class="decl_args">[𝒜 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> A]</span> <span class="decl_args">{B : Type u₂}</span> <span class="decl_args">[ℬ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> B]</span> <span class="decl_args">{C : Type u₃}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₄}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F G : A ⥤ B}</span> <span class="decl_args">{H I : C ⥤ D}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(β : H ⟶ I)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.functor.prod">category_theory.functor.prod</a> F H ⟶ <a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.functor.prod">category_theory.functor.prod</a> G I</div>
<div class="indent"><p>The cartesian product of two natural transformations.</p>
       </div>
</div><div class="thm"><a id="category_theory.nat_trans.prod_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/products/basic.lean#L138">category_theory.nat_trans.prod_app</a></span> <span class="decl_args">{A : Type u₁}</span> <span class="decl_args">[𝒜 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> A]</span> <span class="decl_args">{B : Type u₂}</span> <span class="decl_args">[ℬ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> B]</span> <span class="decl_args">{C : Type u₃}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₄}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F G : A ⥤ B}</span> <span class="decl_args">{H I : C ⥤ D}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(β : H ⟶ I)</span> <span class="decl_args">(X : A × C)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/products/basic.html#category_theory.nat_trans.prod">category_theory.nat_trans.prod</a> α β).app X = (α.app (X.fst), β.app (X.snd))</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div></body></html>