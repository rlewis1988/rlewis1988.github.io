<!DOCTYPE html><html lang="en"><head><title>category_theory.equivalence</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/category_theory/index.html">category_theory</a>/<br><a href="equivalence.html">equivalence</a></div><div class="mod_doc"><p></p>
</div><div class="cnst"><a id="category_theory.equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L24">category_theory.equivalence</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u₁ u₂ v₁ v₂)</div>
<div class="indent"><p>We define an equivalence as a (half)-adjoint equivalence, a pair of functors with
 a unit and counit which are natural isomorphisms and the triangle law <code>Fη ≫ εF = 1</code>, or in other
 words the composite <code>F ⟶ FGF ⟶ F</code> is the identity.</p>

<p>The triangle equation is written as a family of equalities between morphisms, it is more
 complicated if we write it as an equality of natural transformations, because then we would have
 to insert natural transformations like <code>F ⟶ F1</code>.</p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.unit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L42">category_theory.equivalence.unit</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type">𝟭 C ⟶ e.functor ⋙ e.inverse</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.equivalence.counit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L43">category_theory.equivalence.counit</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type">e.inverse ⋙ e.functor ⟶ 𝟭 D</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.equivalence.unit_inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L44">category_theory.equivalence.unit_inv</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type">e.functor ⋙ e.inverse ⟶ 𝟭 C</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.equivalence.counit_inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L45">category_theory.equivalence.counit_inv</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type">𝟭 D ⟶ e.inverse ⋙ e.functor</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.unit_def"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L47">category_theory.equivalence.unit_def</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.unit_iso).hom = <a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.counit_def"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L48">category_theory.equivalence.counit_def</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.counit_iso).hom = <a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.unit_inv_def"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L49">category_theory.equivalence.unit_inv_def</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.unit_iso).inv = <a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.counit_inv_def"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L50">category_theory.equivalence.counit_inv_def</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.counit_iso).inv = <a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.functor_unit_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L52">category_theory.equivalence.functor_unit_comp</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.functor).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app X) ≫
    (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app ((e.functor).obj X) =
  𝟙 ((e.functor).obj X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.counit_inv_functor_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L56">category_theory.equivalence.counit_inv_functor_comp</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app ((e.functor).obj X) ≫
    (e.functor).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app X) =
  𝟙 ((e.functor).obj X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.functor_unit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L64">category_theory.equivalence.functor_unit</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.functor).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app X) =
  (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app ((e.functor).obj X)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.counit_functor"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L68">category_theory.equivalence.counit_functor</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app ((e.functor).obj X) =
  (e.functor).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app X)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.unit_inverse_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L74">category_theory.equivalence.unit_inverse_comp</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(Y : D)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app ((e.inverse).obj Y) ≫
    (e.inverse).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app Y) =
  𝟙 ((e.inverse).obj Y)</div>
<div class="indent"><p>The other triangle equality. The proof follows the following proof in Globular:
 http://globular.science/1905.001</p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.inverse_counit_inv_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L95">category_theory.equivalence.inverse_counit_inv_comp</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(Y : D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.inverse).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app Y) ≫
    (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app ((e.inverse).obj Y) =
  𝟙 ((e.inverse).obj Y)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.unit_inverse"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L103">category_theory.equivalence.unit_inverse</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(Y : D)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app ((e.inverse).obj Y) =
  (e.inverse).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app Y)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.inverse_counit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L107">category_theory.equivalence.inverse_counit</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(Y : D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.inverse).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app Y) =
  (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app ((e.inverse).obj Y)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.fun_inv_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L111">category_theory.equivalence.fun_inv_map</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(X Y : D)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.functor).map ((e.inverse).map f) =
  (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app X ≫ f ≫ (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app Y</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.inv_fun_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L115">category_theory.equivalence.inv_fun_map</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(X Y : C)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.inverse).map ((e.functor).map f) =
  (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app X ≫ f ≫ (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app Y</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.equivalence.adjointify_η"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L123">category_theory.equivalence.adjointify_η</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F : C ⥤ D}</span> <span class="decl_args">{G : D ⥤ C}</span> <span class="decl_args">(η : 𝟭 C ≅ F ⋙ G)</span> <span class="decl_args">(ε : G ⋙ F ≅ 𝟭 D)</span> <span class="decl_args">:</span>       <div class="decl_type">𝟭 C ≅ F ⋙ G</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.adjointify_η_ε"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L133">category_theory.equivalence.adjointify_η_ε</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F : C ⥤ D}</span> <span class="decl_args">{G : D ⥤ C}</span> <span class="decl_args">(η : 𝟭 C ≅ F ⋙ G)</span> <span class="decl_args">(ε : G ⋙ F ≅ 𝟭 D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">F.map (((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.adjointify_η">category_theory.equivalence.adjointify_η</a> η ε).hom).app X) ≫ (ε.hom).app (F.obj X) = 𝟙 (F.obj X)</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.mk"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L146">category_theory.equivalence.mk</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">(G : D ⥤ C)</span> <span class="decl_args">(η : 𝟭 C ≅ F ⋙ G)</span> <span class="decl_args">(ε : G ⋙ F ≅ 𝟭 D)</span> <span class="decl_args">:</span>       <div class="decl_type">C ≌ D</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.refl"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L151">category_theory.equivalence.refl</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type">C ≌ C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.symm"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L154">category_theory.equivalence.symm</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type">D ≌ C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.trans"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L160">category_theory.equivalence.trans</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(f : D ≌ E)</span> <span class="decl_args">:</span>       <div class="decl_type">C ≌ E</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.fun_inv_id_assoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L169">category_theory.equivalence.fun_inv_id_assoc</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(F : C ⥤ E)</span> <span class="decl_args">:</span>       <div class="decl_type">e.functor ⋙ e.inverse ⋙ F ≅ F</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.fun_inv_id_assoc_hom_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L172">category_theory.equivalence.fun_inv_id_assoc_hom_app</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(F : C ⥤ E)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.fun_inv_id_assoc">category_theory.equivalence.fun_inv_id_assoc</a> e F).hom).app X = F.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.fun_inv_id_assoc_inv_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L176">category_theory.equivalence.fun_inv_id_assoc_inv_app</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(F : C ⥤ E)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.fun_inv_id_assoc">category_theory.equivalence.fun_inv_id_assoc</a> e F).inv).app X = F.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.equivalence.inv_fun_id_assoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L180">category_theory.equivalence.inv_fun_id_assoc</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(F : D ⥤ E)</span> <span class="decl_args">:</span>       <div class="decl_type">e.inverse ⋙ e.functor ⋙ F ≅ F</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.inv_fun_id_assoc_hom_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L183">category_theory.equivalence.inv_fun_id_assoc_hom_app</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(F : D ⥤ E)</span> <span class="decl_args">(X : D)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.inv_fun_id_assoc">category_theory.equivalence.inv_fun_id_assoc</a> e F).hom).app X = F.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.inv_fun_id_assoc_inv_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L187">category_theory.equivalence.inv_fun_id_assoc_inv_app</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C ≌ D)</span> <span class="decl_args">(F : D ⥤ E)</span> <span class="decl_args">(X : D)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.inv_fun_id_assoc">category_theory.equivalence.inv_fun_id_assoc</a> e F).inv).app X =
  F.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="cnst"><a id="category_theory.is_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L195">category_theory.is_equivalence</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u₁ u₂ v₁ v₂)</div>
<div class="indent"><p>A functor that is part of a (half) adjoint equivalence</p>
       </div>
</div><div class="def"><a id="category_theory.is_equivalence.of_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L207">category_theory.is_equivalence.of_equivalence</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (F.functor)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.is_equivalence.of_equivalence_inverse"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L210">category_theory.is_equivalence.of_equivalence_inverse</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ≌ D)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (F.inverse)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.is_equivalence.mk"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L214">category_theory.is_equivalence.mk</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F : C ⥤ D}</span> <span class="decl_args">(G : D ⥤ C)</span> <span class="decl_args">(η : 𝟭 C ≅ F ⋙ G)</span> <span class="decl_args">(ε : G ⋙ F ≅ 𝟭 D)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.as_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L223">category_theory.functor.as_equivalence</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type">C ≌ D</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.is_equivalence_refl"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L228">category_theory.functor.is_equivalence_refl</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (𝟭 C)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.functor.inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L232">category_theory.functor.inv</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type">D ⥤ C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.is_equivalence_inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L235">category_theory.functor.is_equivalence_inv</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv">category_theory.functor.inv</a> F)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.functor.fun_inv_id"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L238">category_theory.functor.fun_inv_id</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type">F ⋙ <a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv">category_theory.functor.inv</a> F ≅ 𝟭 C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.inv_fun_id"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L241">category_theory.functor.inv_fun_id</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv">category_theory.functor.inv</a> F ⋙ F ≅ 𝟭 D</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.is_equivalence_trans"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L247">category_theory.functor.is_equivalence_trans</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">(G : D ⥤ E)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> G]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (F ⋙ G)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="thm"><a id="category_theory.is_equivalence.fun_inv_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L255">category_theory.is_equivalence.fun_inv_map</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">(X Y : D)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">F.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv">category_theory.functor.inv</a> F).map f) =
  ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv_fun_id">category_theory.functor.inv_fun_id</a> F).hom).app X ≫ f ≫ ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv_fun_id">category_theory.functor.inv_fun_id</a> F).inv).app Y</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.is_equivalence.inv_fun_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L261">category_theory.is_equivalence.inv_fun_map</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">(X Y : C)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv">category_theory.functor.inv</a> F).map (F.map f) =
  ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.fun_inv_id">category_theory.functor.fun_inv_id</a> F).hom).app X ≫ f ≫ ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.fun_inv_id">category_theory.functor.fun_inv_id</a> F).inv).app Y</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.is_equivalence.functor_unit_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L270">category_theory.is_equivalence.functor_unit_comp</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(E : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> E]</span> <span class="decl_args">(Y : C)</span> <span class="decl_args">:</span>       <div class="decl_type">E.map (((category_theory.is_equivalence.unit_iso E).hom).app Y) ≫
    ((category_theory.is_equivalence.counit_iso E).hom).app (E.obj Y) =
  𝟙 (E.obj ((𝟭 C).obj Y))</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.is_equivalence.counit_inv_functor_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L274">category_theory.is_equivalence.counit_inv_functor_comp</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(E : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> E]</span> <span class="decl_args">(Y : C)</span> <span class="decl_args">:</span>       <div class="decl_type">((category_theory.is_equivalence.counit_iso E).inv).app (E.obj Y) ≫
    E.map (((category_theory.is_equivalence.unit_iso E).inv).app Y) =
  𝟙 ((𝟭 D).obj (E.obj Y))</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="cnst"><a id="category_theory.ess_surj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L280">category_theory.ess_surj</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u₁ u₂ v₂)</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.obj_preimage"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L287">category_theory.functor.obj_preimage</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.ess_surj">category_theory.ess_surj</a> F]</span> <span class="decl_args">(d : D)</span> <span class="decl_args">:</span>       <div class="decl_type">C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.fun_obj_preimage_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L288">category_theory.functor.fun_obj_preimage_iso</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.ess_surj">category_theory.ess_surj</a> F]</span> <span class="decl_args">(d : D)</span> <span class="decl_args">:</span>       <div class="decl_type">F.obj (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.obj_preimage">category_theory.functor.obj_preimage</a> F d) ≅ d</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.ess_surj_of_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L294">category_theory.equivalence.ess_surj_of_equivalence</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.ess_surj">category_theory.ess_surj</a> F</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.faithful_of_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L297">category_theory.equivalence.faithful_of_equivalence</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> F</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.equivalence.full_of_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L304">category_theory.equivalence.full_of_equivalence</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.full">category_theory.full</a> F</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.equivalence.equivalence_of_fully_faithfully_ess_surj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L330">category_theory.equivalence.equivalence_of_fully_faithfully_ess_surj</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.full">category_theory.full</a> F]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> F]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.ess_surj">category_theory.ess_surj</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F</div>
<div class="indent"><p></p>
       </div>
</div></body></html>