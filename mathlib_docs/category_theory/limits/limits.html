<!DOCTYPE html><html lang="en"><head><title>category_theory.limits.limits</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/category_theory/index.html">category_theory</a>/<br><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/index.html">limits</a>/<br><a href="limits.html">limits</a>      <br><br><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean">View file source</a></div><div class="mod_doc"><p></p>
</div><div class="structure"><a id="category_theory.limits.is_limit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L26">category_theory.limits.is_limit</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">(t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p>A cone <code>t</code> on <code>F</code> is a limit cone if each cone on <code>F</code> admits a unique
 cone morphism to <code>t</code>.</p>
       <div class="structure_fields">
Fields:
<div class="structure_field">category_theory.limits.is_limit.lift : Π (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F), s.X ⟶ t.X</div>
<div class="structure_field">category_theory.limits.is_limit.fac' : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#auto_param">auto_param</a> (∀ (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F) (j : J), c.lift s ≫ (t.π).app j = (s.π).app j)
  (name.mk_string "obviously" name.anonymous)</div>
<div class="structure_field">category_theory.limits.is_limit.uniq' : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#auto_param">auto_param</a>
  (∀ (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F) (m : s.X ⟶ t.X),
     (∀ (j : J), m ≫ (t.π).app j = (s.π).app j) → m = c.lift s)
  (name.mk_string "obviously" name.anonymous)</div>
</div>

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.subsingleton"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L38">category_theory.limits.is_limit.subsingleton</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#subsingleton">subsingleton</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t)</div>
<div class="indent"><p></p>
       

Attributes: instance</div>
</div><div class="def"><a id="category_theory.limits.is_limit.lift_cone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L43">category_theory.limits.is_limit.lift_cone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">s ⟶ t</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_limit.uniq_cone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L46">category_theory.limits.is_limit.uniq_cone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{s t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t)</span> <span class="decl_args">{f f' : s ⟶ t}</span> <span class="decl_args">:</span>       <div class="decl_type">f = f'</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.mk_cone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L51">category_theory.limits.is_limit.mk_cone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(<a href="https://robertylewis.com/mathlib_docs/core/init/coe.html#lift">lift</a> : Π (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F), s ⟶ t)</span> <span class="decl_args">(uniq' : ∀ (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F) (m : s ⟶ t), m = <a href="https://robertylewis.com/mathlib_docs/core/init/coe.html#lift">lift</a> s)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.unique_up_to_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L60">category_theory.limits.is_limit.unique_up_to_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{s t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(P : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> s)</span> <span class="decl_args">(Q : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t)</span> <span class="decl_args">:</span>       <div class="decl_type">s ≅ t</div>
<div class="indent"><p>Limit cones on <code>F</code> are unique up to isomorphism.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.of_iso_limit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L66">category_theory.limits.is_limit.of_iso_limit</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{r t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(P : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> r)</span> <span class="decl_args">(i : r ≅ t)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_limit.hom_lift"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L73">category_theory.limits.is_limit.hom_lift</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t)</span> <span class="decl_args">{W : C}</span> <span class="decl_args">(m : W ⟶ t.X)</span> <span class="decl_args">:</span>       <div class="decl_type">m = h.lift {X := W, π := {app := λ (b : J), m ≫ (t.π).app b, naturality' := _}}</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_limit.hom_ext"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L79">category_theory.limits.is_limit.hom_ext</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t)</span> <span class="decl_args">{W : C}</span> <span class="decl_args">{f f' : W ⟶ t.X}</span> <span class="decl_args">(w : ∀ (j : J), f ≫ (t.π).app j = f' ≫ (t.π).app j)</span> <span class="decl_args">:</span>       <div class="decl_type">f = f'</div>
<div class="indent"><p>Two morphisms into a limit are equal if their compositions with
 each cone morphism are equal.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.hom_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L85">category_theory.limits.is_limit.hom_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t)</span> <span class="decl_args">(W : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(W ⟶ t.X) ≅ (<a href="https://robertylewis.com/mathlib_docs/category_theory/const.html#category_theory.functor.const">category_theory.functor.const</a> J).obj W ⟶ F</div>
<div class="indent"><p>The universal property of a limit cone: a map <code>W ⟶ X</code> is the same as
 a cone on <code>F</code> with vertex <code>W</code>.</p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_limit.hom_iso_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L90">category_theory.limits.is_limit.hom_iso_hom</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t)</span> <span class="decl_args">{W : C}</span> <span class="decl_args">(f : W ⟶ t.X)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit.hom_iso">category_theory.limits.is_limit.hom_iso</a> h W).hom f = (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone.extend">category_theory.limits.cone.extend</a> t f).π</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.is_limit.nat_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L95">category_theory.limits.is_limit.nat_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t)</span> <span class="decl_args">:</span>       <div class="decl_type">category_theory.yoneda.obj (t.X) ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F</div>
<div class="indent"><p>The limit of <code>F</code> represents the functor taking <code>W</code> to
 the set of cones on <code>F</code> with vertex <code>W</code>.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.hom_iso'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L98">category_theory.limits.is_limit.hom_iso'</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t)</span> <span class="decl_args">(W : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(W ⟶ t.X) ≅ {p // ∀ {j j' : J} (f : j ⟶ j'), p j ≫ F.map f = p j'}</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.of_faithful"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L111">category_theory.limits.is_limit.of_faithful</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> G]</span> <span class="decl_args">(ht : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.map_cone">category_theory.functor.map_cone</a> G t))</span> <span class="decl_args">(<a href="https://robertylewis.com/mathlib_docs/core/init/coe.html#lift">lift</a> : Π (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F), s.X ⟶ t.X)</span> <span class="decl_args">(h : ∀ (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F), G.map (<a href="https://robertylewis.com/mathlib_docs/core/init/coe.html#lift">lift</a> s) = ht.lift (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.map_cone">category_theory.functor.map_cone</a> G s))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t</div>
<div class="indent"><p>If G : C → D is a faithful functor which sends t to a limit cone,
 then it suffices to check that the induced maps for the image of t
 can be lifted to maps of C.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.iso_unique_cone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L123">category_theory.limits.is_limit.iso_unique_cone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F}</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> t ≅ Π (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F), <a href="https://robertylewis.com/mathlib_docs/logic/unique.html#unique">unique</a> (s ⟶ t)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.of_nat_iso.cone_of_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L136">category_theory.limits.is_limit.of_nat_iso.cone_of_hom</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.yoneda.obj X ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F)</span> <span class="decl_args">{Y : C}</span> <span class="decl_args">(f : Y ⟶ X)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F</div>
<div class="indent"><p>If <code>F.cones</code> is represented by <code>X</code>, each morphism <code>f : Y ⟶ X</code> gives a cone with cone point <code>Y</code>.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.of_nat_iso.hom_of_cone"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L140">category_theory.limits.is_limit.of_nat_iso.hom_of_cone</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.yoneda.obj X ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">s.X ⟶ X</div>
<div class="indent"><p>If <code>F.cones</code> is represented by <code>X</code>, each cone <code>s</code> gives a morphism <code>s.X ⟶ X</code>.</p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_limit.of_nat_iso.cone_of_hom_of_cone"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L142">category_theory.limits.is_limit.of_nat_iso.cone_of_hom_of_cone</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.yoneda.obj X ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit.of_nat_iso.cone_of_hom">category_theory.limits.is_limit.of_nat_iso.cone_of_hom</a> h (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit.of_nat_iso.hom_of_cone">category_theory.limits.is_limit.of_nat_iso.hom_of_cone</a> h s) =
  s</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.is_limit.of_nat_iso.hom_of_cone_of_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L148">category_theory.limits.is_limit.of_nat_iso.hom_of_cone_of_hom</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.yoneda.obj X ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F)</span> <span class="decl_args">{Y : C}</span> <span class="decl_args">(f : Y ⟶ X)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit.of_nat_iso.hom_of_cone">category_theory.limits.is_limit.of_nat_iso.hom_of_cone</a> h (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit.of_nat_iso.cone_of_hom">category_theory.limits.is_limit.of_nat_iso.cone_of_hom</a> h f) =
  f</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.is_limit.of_nat_iso.limit_cone"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L153">category_theory.limits.is_limit.of_nat_iso.limit_cone</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.yoneda.obj X ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F</div>
<div class="indent"><p>If <code>F.cones</code> is represented by <code>X</code>, the cone corresponding to the identity morphism on <code>X</code>
will be a limit cone.</p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_limit.of_nat_iso.cone_of_hom_fac"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L158">category_theory.limits.is_limit.of_nat_iso.cone_of_hom_fac</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.yoneda.obj X ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F)</span> <span class="decl_args">{Y : C}</span> <span class="decl_args">(f : Y ⟶ X)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit.of_nat_iso.cone_of_hom">category_theory.limits.is_limit.of_nat_iso.cone_of_hom</a> h f =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone.extend">category_theory.limits.cone.extend</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit.of_nat_iso.limit_cone">category_theory.limits.is_limit.of_nat_iso.limit_cone</a> h) f</div>
<div class="indent"><p>If <code>F.cones</code> is represented by <code>X</code>, the cone corresponding to a morphism <code>f : Y ⟶ X</code> is
the limit cone extended by <code>f</code>.</p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_limit.of_nat_iso.cone_fac"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L173">category_theory.limits.is_limit.of_nat_iso.cone_fac</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.yoneda.obj X ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone.extend">category_theory.limits.cone.extend</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit.of_nat_iso.limit_cone">category_theory.limits.is_limit.of_nat_iso.limit_cone</a> h)
    (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit.of_nat_iso.hom_of_cone">category_theory.limits.is_limit.of_nat_iso.hom_of_cone</a> h s) =
  s</div>
<div class="indent"><p>If <code>F.cones</code> is represented by <code>X</code>, any cone is the extension of the limit cone by the
corresponding morphism.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_limit.of_nat_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L189">category_theory.limits.is_limit.of_nat_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.yoneda.obj X ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit.of_nat_iso.limit_cone">category_theory.limits.is_limit.of_nat_iso.limit_cone</a> h)</div>
<div class="indent"><p>If <code>F.cones</code> is representable, then the cone corresponding to the identity morphism on
the representing object is a limit cone.</p>
       

</div>
</div><div class="structure"><a id="category_theory.limits.is_colimit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L214">category_theory.limits.is_colimit</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">(t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p>A cocone <code>t</code> on <code>F</code> is a colimit cocone if each cocone on <code>F</code> admits a unique
 cocone morphism from <code>t</code>.</p>
       <div class="structure_fields">
Fields:
<div class="structure_field">category_theory.limits.is_colimit.desc : Π (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F), t.X ⟶ s.X</div>
<div class="structure_field">category_theory.limits.is_colimit.fac' : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#auto_param">auto_param</a> (∀ (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F) (j : J), (t.ι).app j ≫ c.desc s = (s.ι).app j)
  (name.mk_string "obviously" name.anonymous)</div>
<div class="structure_field">category_theory.limits.is_colimit.uniq' : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#auto_param">auto_param</a>
  (∀ (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F) (m : t.X ⟶ s.X),
     (∀ (j : J), (t.ι).app j ≫ m = (s.ι).app j) → m = c.desc s)
  (name.mk_string "obviously" name.anonymous)</div>
</div>

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.subsingleton"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L226">category_theory.limits.is_colimit.subsingleton</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#subsingleton">subsingleton</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t)</div>
<div class="indent"><p></p>
       

Attributes: instance</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.desc_cocone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L231">category_theory.limits.is_colimit.desc_cocone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">t ⟶ s</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_colimit.uniq_cocone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L234">category_theory.limits.is_colimit.uniq_cocone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{s t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t)</span> <span class="decl_args">{f f' : t ⟶ s}</span> <span class="decl_args">:</span>       <div class="decl_type">f = f'</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.mk_cocone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L239">category_theory.limits.is_colimit.mk_cocone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(desc : Π (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F), t ⟶ s)</span> <span class="decl_args">(uniq' : ∀ (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F) (m : t ⟶ s), m = desc s)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.unique_up_to_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L248">category_theory.limits.is_colimit.unique_up_to_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{s t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(P : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> s)</span> <span class="decl_args">(Q : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t)</span> <span class="decl_args">:</span>       <div class="decl_type">s ≅ t</div>
<div class="indent"><p>Limit cones on <code>F</code> are unique up to isomorphism.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.of_iso_colimit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L254">category_theory.limits.is_colimit.of_iso_colimit</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{r t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(P : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> r)</span> <span class="decl_args">(i : r ≅ t)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_colimit.hom_desc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L261">category_theory.limits.is_colimit.hom_desc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t)</span> <span class="decl_args">{W : C}</span> <span class="decl_args">(m : t.X ⟶ W)</span> <span class="decl_args">:</span>       <div class="decl_type">m = h.desc {X := W, ι := {app := λ (b : J), (t.ι).app b ≫ m, naturality' := _}}</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_colimit.hom_ext"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L268">category_theory.limits.is_colimit.hom_ext</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t)</span> <span class="decl_args">{W : C}</span> <span class="decl_args">{f f' : t.X ⟶ W}</span> <span class="decl_args">(w : ∀ (j : J), (t.ι).app j ≫ f = (t.ι).app j ≫ f')</span> <span class="decl_args">:</span>       <div class="decl_type">f = f'</div>
<div class="indent"><p>Two morphisms out of a colimit are equal if their compositions with
 each cocone morphism are equal.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.hom_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L274">category_theory.limits.is_colimit.hom_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t)</span> <span class="decl_args">(W : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(t.X ⟶ W) ≅ F ⟶ (<a href="https://robertylewis.com/mathlib_docs/category_theory/const.html#category_theory.functor.const">category_theory.functor.const</a> J).obj W</div>
<div class="indent"><p>The universal property of a colimit cocone: a map <code>X ⟶ W</code> is the same as
 a cocone on <code>F</code> with vertex <code>W</code>.</p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_colimit.hom_iso_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L279">category_theory.limits.is_colimit.hom_iso_hom</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t)</span> <span class="decl_args">{W : C}</span> <span class="decl_args">(f : t.X ⟶ W)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit.hom_iso">category_theory.limits.is_colimit.hom_iso</a> h W).hom f = (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone.extend">category_theory.limits.cocone.extend</a> t f).ι</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.nat_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L284">category_theory.limits.is_colimit.nat_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t)</span> <span class="decl_args">:</span>       <div class="decl_type">category_theory.coyoneda.obj (<a href="https://robertylewis.com/mathlib_docs/data/opposite.html#opposite.op">opposite.op</a> (t.X)) ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F</div>
<div class="indent"><p>The colimit of <code>F</code> represents the functor taking <code>W</code> to
 the set of cocones on <code>F</code> with vertex <code>W</code>.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.hom_iso'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L287">category_theory.limits.is_colimit.hom_iso'</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t)</span> <span class="decl_args">(W : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(t.X ⟶ W) ≅ {p // ∀ {j j' : J} (f : j ⟶ j'), F.map f ≫ p j' = p j}</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.of_faithful"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L300">category_theory.limits.is_colimit.of_faithful</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> G]</span> <span class="decl_args">(ht : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.map_cocone">category_theory.functor.map_cocone</a> G t))</span> <span class="decl_args">(desc : Π (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F), t.X ⟶ s.X)</span> <span class="decl_args">(h : ∀ (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F), G.map (desc s) = ht.desc (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.map_cocone">category_theory.functor.map_cocone</a> G s))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t</div>
<div class="indent"><p>If G : C → D is a faithful functor which sends t to a colimit cocone,
 then it suffices to check that the induced maps for the image of t
 can be lifted to maps of C.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.iso_unique_cocone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L312">category_theory.limits.is_colimit.iso_unique_cocone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{t : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F}</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> t ≅ Π (s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F), <a href="https://robertylewis.com/mathlib_docs/logic/unique.html#unique">unique</a> (t ⟶ s)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L325">category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.coyoneda.obj (<a href="https://robertylewis.com/mathlib_docs/data/opposite.html#opposite.op">opposite.op</a> X) ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F)</span> <span class="decl_args">{Y : C}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F</div>
<div class="indent"><p>If <code>F.cocones</code> is corepresented by <code>X</code>, each morphism <code>f : X ⟶ Y</code> gives a cocone with cone point <code>Y</code>.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L329">category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.coyoneda.obj (<a href="https://robertylewis.com/mathlib_docs/data/opposite.html#opposite.op">opposite.op</a> X) ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">X ⟶ s.X</div>
<div class="indent"><p>If <code>F.cocones</code> is corepresented by <code>X</code>, each cocone <code>s</code> gives a morphism <code>X ⟶ s.X</code>.</p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom_of_cocone"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L331">category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom_of_cocone</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.coyoneda.obj (<a href="https://robertylewis.com/mathlib_docs/data/opposite.html#opposite.op">opposite.op</a> X) ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom">category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom</a> h
    (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone">category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone</a> h s) =
  s</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone_of_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L337">category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone_of_hom</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.coyoneda.obj (<a href="https://robertylewis.com/mathlib_docs/data/opposite.html#opposite.op">opposite.op</a> X) ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F)</span> <span class="decl_args">{Y : C}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone">category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone</a> h
    (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom">category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom</a> h f) =
  f</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.of_nat_iso.colimit_cocone"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L342">category_theory.limits.is_colimit.of_nat_iso.colimit_cocone</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.coyoneda.obj (<a href="https://robertylewis.com/mathlib_docs/data/opposite.html#opposite.op">opposite.op</a> X) ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F</div>
<div class="indent"><p>If <code>F.cocones</code> is corepresented by <code>X</code>, the cocone corresponding to the identity morphism on <code>X</code>
will be a colimit cocone.</p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom_fac"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L347">category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom_fac</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.coyoneda.obj (<a href="https://robertylewis.com/mathlib_docs/data/opposite.html#opposite.op">opposite.op</a> X) ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F)</span> <span class="decl_args">{Y : C}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom">category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom</a> h f =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone.extend">category_theory.limits.cocone.extend</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit.of_nat_iso.colimit_cocone">category_theory.limits.is_colimit.of_nat_iso.colimit_cocone</a> h) f</div>
<div class="indent"><p>If <code>F.cocones</code> is corepresented by <code>X</code>, the cocone corresponding to a morphism <code>f : Y ⟶ X</code> is
the colimit cocone extended by <code>f</code>.</p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.is_colimit.of_nat_iso.cocone_fac"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L362">category_theory.limits.is_colimit.of_nat_iso.cocone_fac</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.coyoneda.obj (<a href="https://robertylewis.com/mathlib_docs/data/opposite.html#opposite.op">opposite.op</a> X) ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone.extend">category_theory.limits.cocone.extend</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit.of_nat_iso.colimit_cocone">category_theory.limits.is_colimit.of_nat_iso.colimit_cocone</a> h)
    (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone">category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone</a> h s) =
  s</div>
<div class="indent"><p>If <code>F.cocones</code> is corepresented by <code>X</code>, any cocone is the extension of the colimit cocone by the
corresponding morphism.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.is_colimit.of_nat_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L378">category_theory.limits.is_colimit.of_nat_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(h : category_theory.coyoneda.obj (<a href="https://robertylewis.com/mathlib_docs/data/opposite.html#opposite.op">opposite.op</a> X) ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit.of_nat_iso.colimit_cocone">category_theory.limits.is_colimit.of_nat_iso.colimit_cocone</a> h)</div>
<div class="indent"><p>If <code>F.cocones</code> is corepresentable, then the cocone corresponding to the identity morphism on
the representing object is a colimit cocone.</p>
       

</div>
</div><div class="structure"><a id="category_theory.limits.has_limit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L404">category_theory.limits.has_limit</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p><code>has_limit F</code> represents a particular chosen limit of the diagram <code>F</code>.</p>
       <div class="structure_fields">
Fields:
<div class="structure_field">category_theory.limits.has_limit.cone : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F</div>
<div class="structure_field">category_theory.limits.has_limit.is_limit : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#auto_param">auto_param</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> (category_theory.limits.has_limit.cone F))
  (name.mk_string "apply_instance" (name.mk_string "tactic" name.anonymous))</div>
</div>

</div>
</div><div class="structure"><a id="category_theory.limits.has_limits_of_shape"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L412">category_theory.limits.has_limits_of_shape</a></span> <span class="decl_args">(J : Type v)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">(C : Type u)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p><code>C</code> has limits of shape <code>J</code> if we have chosen a particular limit of
 every functor <code>F : J ⥤ C</code>.</p>
       <div class="structure_fields">
Fields:
<div class="structure_field">category_theory.limits.has_limits_of_shape.has_limit : Π (F : J ⥤ C), <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F</div>
</div>

</div>
</div><div class="structure"><a id="category_theory.limits.has_limits"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L416">category_theory.limits.has_limits</a></span> <span class="decl_args">(C : Type u)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u (v+1))</div>
<div class="indent"><p><code>C</code> has all (small) limits if it has limits of every shape.</p>
       <div class="structure_fields">
Fields:
<div class="structure_field">category_theory.limits.has_limits.has_limits_of_shape : Π (J : Type ?) [𝒥 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J], <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C</div>
</div>

</div>
</div><div class="def"><a id="category_theory.limits.has_limit_of_has_limits_of_shape"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L421">category_theory.limits.has_limit_of_has_limits_of_shape</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[H : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F</div>
<div class="indent"><p></p>
       

Attributes: instance</div>
</div><div class="def"><a id="category_theory.limits.has_limits_of_shape_of_has_limits"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L425">category_theory.limits.has_limits_of_shape_of_has_limits</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[H : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits">category_theory.limits.has_limits</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C</div>
<div class="indent"><p></p>
       

Attributes: instance</div>
</div><div class="def"><a id="category_theory.limits.limit.cone"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L431">category_theory.limits.limit.cone</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.limit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L433">category_theory.limits.limit</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type">C</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.limit.π"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L435">category_theory.limits.limit.π</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit">category_theory.limits.limit</a> F ⟶ F.obj j</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.limit.cone_π"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L438">category_theory.limits.limit.cone_π</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.cone">category_theory.limits.limit.cone</a> F).π).app j = <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.w"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L441">category_theory.limits.limit.w</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">{j j' : J}</span> <span class="decl_args">(f : j ⟶ j')</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j ≫ F.map f = <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j'</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.limit.is_limit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L444">category_theory.limits.limit.is_limit</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_limit">category_theory.limits.is_limit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.cone">category_theory.limits.limit.cone</a> F)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.limit.lift"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L447">category_theory.limits.limit.lift</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">c.X ⟶ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit">category_theory.limits.limit</a> F</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.limit.is_limit_lift"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L450">category_theory.limits.limit.is_limit_lift</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.is_limit">category_theory.limits.limit.is_limit</a> F).lift c = <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> F c</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.lift_π_assoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L453">category_theory.limits.limit.lift_π_assoc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">(j : J)</span> <span class="decl_args">{X' : C}</span> <span class="decl_args">(f' : F.obj j ⟶ X')</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> F c ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j ≫ f' = (c.π).app j ≫ f'</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.lift_π"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L453">category_theory.limits.limit.lift_π</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> F c ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j = (c.π).app j</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.limit.cone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L457">category_theory.limits.limit.cone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone_morphism">category_theory.limits.cone_morphism</a> c (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.cone">category_theory.limits.limit.cone</a> F)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.limit.cone_morphism_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L461">category_theory.limits.limit.cone_morphism_hom</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.cone_morphism">category_theory.limits.limit.cone_morphism</a> c).hom = <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> F c</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.cone_morphism_π"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L463">category_theory.limits.limit.cone_morphism_π</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.cone_morphism">category_theory.limits.limit.cone_morphism</a> c).hom ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j = (c.π).app j</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.hom_ext"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L467">category_theory.limits.limit.hom_ext</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">{X : C}</span> <span class="decl_args">{f f' : X ⟶ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit">category_theory.limits.limit</a> F}</span> <span class="decl_args">(w : ∀ (j : J), f ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j = f' ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j)</span> <span class="decl_args">:</span>       <div class="decl_type">f = f'</div>
<div class="indent"><p></p>
       

Attributes: ext</div>
</div><div class="def"><a id="category_theory.limits.limit.hom_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L471">category_theory.limits.limit.hom_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(W : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(W ⟶ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit">category_theory.limits.limit</a> F) ≅ (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F).obj (<a href="https://robertylewis.com/mathlib_docs/data/opposite.html#opposite.op">opposite.op</a> W)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.limit.hom_iso_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L474">category_theory.limits.limit.hom_iso_hom</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">{W : C}</span> <span class="decl_args">(f : W ⟶ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit">category_theory.limits.limit</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.hom_iso">category_theory.limits.limit.hom_iso</a> F W).hom f =
  (<a href="https://robertylewis.com/mathlib_docs/category_theory/const.html#category_theory.functor.const">category_theory.functor.const</a> J).map f ≫ (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.cone">category_theory.limits.limit.cone</a> F).π</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.limit.hom_iso'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L478">category_theory.limits.limit.hom_iso'</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(W : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(W ⟶ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit">category_theory.limits.limit</a> F) ≅ {p // ∀ {j j' : J} (f : j ⟶ j'), p j ≫ F.map f = p j'}</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.limit.lift_extend"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L482">category_theory.limits.limit.lift_extend</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(f : X ⟶ c.X)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> F (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone.extend">category_theory.limits.cone.extend</a> c f) =
  f ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> F c</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.has_limit_of_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L486">category_theory.limits.has_limit_of_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F G : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(α : F ≅ G)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> G</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.has_limit.of_cones_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L506">category_theory.limits.has_limit.of_cones_iso</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">(G : K ⥤ C)</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> G)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> G</div>
<div class="indent"><p>If a functor <code>G</code> has the same collection of cones as a functor <code>F</code>
which has a limit, then <code>G</code> also has a limit.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.limit.pre"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L513">category_theory.limits.limit.pre</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (E ⋙ F)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit">category_theory.limits.limit</a> F ⟶ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit">category_theory.limits.limit</a> (E ⋙ F)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.limit.pre_π"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L518">category_theory.limits.limit.pre_π</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (E ⋙ F)]</span> <span class="decl_args">(k : K)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> F E ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> (E ⋙ F) k =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F (E.obj k)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.lift_pre"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L521">category_theory.limits.limit.lift_pre</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (E ⋙ F)]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> F c ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> F E =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> (E ⋙ F) (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone.whisker">category_theory.limits.cone.whisker</a> E c)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.pre_pre"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L528">category_theory.limits.limit.pre_pre</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (E ⋙ F)]</span> <span class="decl_args">{L : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> L]</span> <span class="decl_args">(D : L ⥤ K)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (D ⋙ E ⋙ F)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> F E ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> (E ⋙ F) D =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> F (D ⋙ E)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.limit.post"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L539">category_theory.limits.limit.post</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (F ⋙ G)]</span> <span class="decl_args">:</span>       <div class="decl_type">G.obj (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit">category_theory.limits.limit</a> F) ⟶ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit">category_theory.limits.limit</a> (F ⋙ G)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.limit.post_π"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L547">category_theory.limits.limit.post_π</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (F ⋙ G)]</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.post">category_theory.limits.limit.post</a> F G ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> (F ⋙ G) j =
  G.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.lift_post"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L550">category_theory.limits.limit.lift_post</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (F ⋙ G)]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">G.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> F c) ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.post">category_theory.limits.limit.post</a> F G =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> (F ⋙ G) (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.map_cone">category_theory.functor.map_cone</a> G c)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.post_post"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L554">category_theory.limits.limit.post_post</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (F ⋙ G)]</span> <span class="decl_args">{E : Type u''}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(H : D ⥤ E)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> ((F ⋙ G) ⋙ H)]</span> <span class="decl_args">:</span>       <div class="decl_type">H.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.post">category_theory.limits.limit.post</a> F G) ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.post">category_theory.limits.limit.post</a> (F ⋙ G) H =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.post">category_theory.limits.limit.post</a> F (G ⋙ H)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.pre_post"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L563">category_theory.limits.limit.pre_post</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (E ⋙ F)]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (F ⋙ G)]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> ((E ⋙ F) ⋙ G)]</span> <span class="decl_args">:</span>       <div class="decl_type">G.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> F E) ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.post">category_theory.limits.limit.post</a> (E ⋙ F) G =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.post">category_theory.limits.limit.post</a> F G ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> (F ⋙ G) E</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.has_limit_equivalence_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L572">category_theory.limits.has_limit_equivalence_comp</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">(e : K ≌ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (e.functor ⋙ F)</div>
<div class="indent"><p></p>
       

Attributes: instance</div>
</div><div class="def"><a id="category_theory.limits.has_limit_of_equivalence_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L590">category_theory.limits.has_limit_of_equivalence_comp</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">(e : K ≌ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (e.functor ⋙ F)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> F</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.lim"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L604">category_theory.limits.lim</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">:</span>       <div class="decl_type">(J ⥤ C) ⥤ C</div>
<div class="indent"><p><code>limit F</code> is functorial in <code>F</code>, when <code>C</code> has all limits of shape <code>J</code>.</p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.lim.map_π"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L617">category_theory.limits.lim.map_π</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">{G : J ⥤ C}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type">category_theory.limits.lim.map α ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> G j =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j ≫ α.app j</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.lim.map_π_assoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L617">category_theory.limits.lim.map_π_assoc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">{G : J ⥤ C}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(j : J)</span> <span class="decl_args">{X' : C}</span> <span class="decl_args">(f' : G.obj j ⟶ X')</span> <span class="decl_args">:</span>       <div class="decl_type">category_theory.limits.lim.map α ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> G j ≫ f' =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.π">category_theory.limits.limit.π</a> F j ≫ α.app j ≫ f'</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.lift_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L620">category_theory.limits.limit.lift_map</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">{G : J ⥤ C}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cone">category_theory.limits.cone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> F c ≫ category_theory.limits.lim.map α =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.lift">category_theory.limits.limit.lift</a> G ((<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cones.postcompose">category_theory.limits.cones.postcompose</a> α).obj c)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.limit.map_pre"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L624">category_theory.limits.limit.map_pre</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">{G : J ⥤ C}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> K C]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">:</span>       <div class="decl_type">category_theory.limits.lim.map α ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> G E =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> F E ≫ category_theory.limits.lim.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/whiskering.html#category_theory.whisker_left">category_theory.whisker_left</a> E α)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.limit.map_pre'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L628">category_theory.limits.limit.map_pre'</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> K C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{E₁ E₂ : K ⥤ J}</span> <span class="decl_args">(α : E₁ ⟶ E₂)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> F E₂ =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> F E₁ ≫ category_theory.limits.lim.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/whiskering.html#category_theory.whisker_right">category_theory.whisker_right</a> α F)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.limit.id_pre"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L633">category_theory.limits.limit.id_pre</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.pre">category_theory.limits.limit.pre</a> F (𝟭 J) =
  category_theory.limits.lim.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/whiskering.html#category_theory.functor.left_unitor">category_theory.functor.left_unitor</a> F).inv)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.limit.map_post"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L636">category_theory.limits.limit.map_post</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">{G : J ⥤ C}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J D]</span> <span class="decl_args">(H : C ⥤ D)</span> <span class="decl_args">:</span>       <div class="decl_type">H.map (category_theory.limits.lim.map α) ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.post">category_theory.limits.limit.post</a> G H =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.limit.post">category_theory.limits.limit.post</a> F H ≫ category_theory.limits.lim.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/whiskering.html#category_theory.whisker_right">category_theory.whisker_right</a> α H)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.lim_yoneda"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L647">category_theory.limits.lim_yoneda</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.lim">category_theory.limits.lim</a> ⋙ <a href="https://robertylewis.com/mathlib_docs/category_theory/yoneda.html#category_theory.yoneda">category_theory.yoneda</a> ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.cones">category_theory.cones</a> J C</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.has_limits_of_shape_of_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L653">category_theory.limits.has_limits_of_shape_of_equivalence</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J' : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J']</span> <span class="decl_args">(e : J ≌ J')</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> J' C</div>
<div class="indent"><p></p>
       

</div>
</div><div class="structure"><a id="category_theory.limits.has_colimit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L663">category_theory.limits.has_colimit</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p><code>has_colimit F</code> represents a particular chosen colimit of the diagram <code>F</code>.</p>
       <div class="structure_fields">
Fields:
<div class="structure_field">category_theory.limits.has_colimit.cocone : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F</div>
<div class="structure_field">category_theory.limits.has_colimit.is_colimit : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#auto_param">auto_param</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> (category_theory.limits.has_colimit.cocone F))
  (name.mk_string "apply_instance" (name.mk_string "tactic" name.anonymous))</div>
</div>

</div>
</div><div class="structure"><a id="category_theory.limits.has_colimits_of_shape"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L671">category_theory.limits.has_colimits_of_shape</a></span> <span class="decl_args">(J : Type v)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">(C : Type u)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p><code>C</code> has colimits of shape <code>J</code> if we have chosen a particular colimit of
 every functor <code>F : J ⥤ C</code>.</p>
       <div class="structure_fields">
Fields:
<div class="structure_field">category_theory.limits.has_colimits_of_shape.has_colimit : Π (F : J ⥤ C), <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F</div>
</div>

</div>
</div><div class="structure"><a id="category_theory.limits.has_colimits"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L675">category_theory.limits.has_colimits</a></span> <span class="decl_args">(C : Type u)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u (v+1))</div>
<div class="indent"><p><code>C</code> has all (small) colimits if it has colimits of every shape.</p>
       <div class="structure_fields">
Fields:
<div class="structure_field">category_theory.limits.has_colimits.has_colimits_of_shape : Π (J : Type ?) [𝒥 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J], <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C</div>
</div>

</div>
</div><div class="def"><a id="category_theory.limits.has_colimit_of_has_colimits_of_shape"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L680">category_theory.limits.has_colimit_of_has_colimits_of_shape</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[H : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F</div>
<div class="indent"><p></p>
       

Attributes: instance</div>
</div><div class="def"><a id="category_theory.limits.has_colimits_of_shape_of_has_colimits"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L684">category_theory.limits.has_colimits_of_shape_of_has_colimits</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[H : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits">category_theory.limits.has_colimits</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C</div>
<div class="indent"><p></p>
       

Attributes: instance</div>
</div><div class="def"><a id="category_theory.limits.colimit.cocone"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L690">category_theory.limits.colimit.cocone</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.colimit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L692">category_theory.limits.colimit</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type">C</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.colimit.ι"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L694">category_theory.limits.colimit.ι</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type">F.obj j ⟶ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> F</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colimit.cocone_ι"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L697">category_theory.limits.colimit.cocone_ι</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.cocone">category_theory.limits.colimit.cocone</a> F).ι).app j = <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.w"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L700">category_theory.limits.colimit.w</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">{j j' : J}</span> <span class="decl_args">(f : j ⟶ j')</span> <span class="decl_args">:</span>       <div class="decl_type">F.map f ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j' = <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.colimit.is_colimit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L703">category_theory.limits.colimit.is_colimit</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.is_colimit">category_theory.limits.is_colimit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.cocone">category_theory.limits.colimit.cocone</a> F)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.colimit.desc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L706">category_theory.limits.colimit.desc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> F ⟶ c.X</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colimit.is_colimit_desc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L709">category_theory.limits.colimit.is_colimit_desc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.is_colimit">category_theory.limits.colimit.is_colimit</a> F).desc c = <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> F c</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.ι_desc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L722">category_theory.limits.colimit.ι_desc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> F c = (c.ι).app j</div>
<div class="indent"><p>We have lots of lemmas describing how to simplify <code>colimit.ι F j ≫ _</code>,
and combined with <code>colimit.ext</code> we rely on these lemmas for many calculations.</p>

<p>However, since <code>category.assoc</code> is a <code>@[simp]</code> lemma, often expressions are
right associated, and it's hard to apply these lemmas about <code>colimit.ι</code>.</p>

<p>We thus use <code>reassoc</code> to define additional <code>@[simp]</code> lemmas, with an arbitrary extra morphism.
(see <code>tactic/reassoc_axiom.lean</code>)</p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.ι_desc_assoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L722">category_theory.limits.colimit.ι_desc_assoc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">(j : J)</span> <span class="decl_args">{X' : C}</span> <span class="decl_args">(f' : c.X ⟶ X')</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> F c ≫ f' = (c.ι).app j ≫ f'</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.colimit.cocone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L726">category_theory.limits.colimit.cocone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone_morphism">category_theory.limits.cocone_morphism</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.cocone">category_theory.limits.colimit.cocone</a> F) c</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colimit.cocone_morphism_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L730">category_theory.limits.colimit.cocone_morphism_hom</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.cocone_morphism">category_theory.limits.colimit.cocone_morphism</a> c).hom = <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> F c</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.ι_cocone_morphism"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L732">category_theory.limits.colimit.ι_cocone_morphism</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j ≫ (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.cocone_morphism">category_theory.limits.colimit.cocone_morphism</a> c).hom = (c.ι).app j</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.hom_ext"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L736">category_theory.limits.colimit.hom_ext</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">{X : C}</span> <span class="decl_args">{f f' : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> F ⟶ X}</span> <span class="decl_args">(w : ∀ (j : J), <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j ≫ f = <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j ≫ f')</span> <span class="decl_args">:</span>       <div class="decl_type">f = f'</div>
<div class="indent"><p></p>
       

Attributes: ext</div>
</div><div class="def"><a id="category_theory.limits.colimit.hom_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L740">category_theory.limits.colimit.hom_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(W : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> F ⟶ W) ≅ (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F).obj W</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colimit.hom_iso_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L743">category_theory.limits.colimit.hom_iso_hom</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">{W : C}</span> <span class="decl_args">(f : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> F ⟶ W)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.hom_iso">category_theory.limits.colimit.hom_iso</a> F W).hom f =
  (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.cocone">category_theory.limits.colimit.cocone</a> F).ι ≫ (<a href="https://robertylewis.com/mathlib_docs/category_theory/const.html#category_theory.functor.const">category_theory.functor.const</a> J).map f</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.colimit.hom_iso'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L747">category_theory.limits.colimit.hom_iso'</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(W : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> F ⟶ W) ≅ {p // ∀ {j j' : J} (f : j ⟶ j'), F.map f ≫ p j' = p j}</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colimit.desc_extend"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L751">category_theory.limits.colimit.desc_extend</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(f : c.X ⟶ X)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> F (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone.extend">category_theory.limits.cocone.extend</a> c f) =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> F c ≫ f</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.has_colimit_of_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L757">category_theory.limits.has_colimit_of_iso</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F G : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(α : G ≅ F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> G</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.has_colimit.of_cocones_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L776">category_theory.limits.has_colimit.of_cocones_iso</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">(G : K ⥤ C)</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> F ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.cocones">category_theory.functor.cocones</a> G)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> G</div>
<div class="indent"><p>If a functor <code>G</code> has the same collection of cocones as a functor <code>F</code>
which has a colimit, then <code>G</code> also has a colimit.</p>
       

</div>
</div><div class="def"><a id="category_theory.limits.colimit.pre"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L783">category_theory.limits.colimit.pre</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (E ⋙ F)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> (E ⋙ F) ⟶ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> F</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colimit.ι_pre_assoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L788">category_theory.limits.colimit.ι_pre_assoc</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (E ⋙ F)]</span> <span class="decl_args">(k : K)</span> <span class="decl_args">{X' : C}</span> <span class="decl_args">(f' : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> F ⟶ X')</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> (E ⋙ F) k ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> F E ≫ f' =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F (E.obj k) ≫ f'</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.ι_pre"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L788">category_theory.limits.colimit.ι_pre</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (E ⋙ F)]</span> <span class="decl_args">(k : K)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> (E ⋙ F) k ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> F E =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F (E.obj k)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.pre_desc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L791">category_theory.limits.colimit.pre_desc</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (E ⋙ F)]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> F E ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> F c =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> (E ⋙ F) (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone.whisker">category_theory.limits.cocone.whisker</a> E c)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.pre_pre"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L798">category_theory.limits.colimit.pre_pre</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (E ⋙ F)]</span> <span class="decl_args">{L : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> L]</span> <span class="decl_args">(D : L ⥤ K)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (D ⋙ E ⋙ F)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> (E ⋙ F) D ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> F E =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> F (D ⋙ E)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.colimit.post"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L814">category_theory.limits.colimit.post</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (F ⋙ G)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> (F ⋙ G) ⟶ G.obj (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> F)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colimit.ι_post_assoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L822">category_theory.limits.colimit.ι_post_assoc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (F ⋙ G)]</span> <span class="decl_args">(j : J)</span> <span class="decl_args">{X' : D}</span> <span class="decl_args">(f' : G.obj (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit">category_theory.limits.colimit</a> F) ⟶ X')</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> (F ⋙ G) j ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.post">category_theory.limits.colimit.post</a> F G ≫ f' =
  G.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j) ≫ f'</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.ι_post"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L822">category_theory.limits.colimit.ι_post</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (F ⋙ G)]</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> (F ⋙ G) j ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.post">category_theory.limits.colimit.post</a> F G =
  G.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.post_desc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L825">category_theory.limits.colimit.post_desc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (F ⋙ G)]</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> F)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.post">category_theory.limits.colimit.post</a> F G ≫ G.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> F c) =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> (F ⋙ G) (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.functor.map_cocone">category_theory.functor.map_cocone</a> G c)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.post_post"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L829">category_theory.limits.colimit.post_post</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (F ⋙ G)]</span> <span class="decl_args">{E : Type u''}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(H : D ⥤ E)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> ((F ⋙ G) ⋙ H)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.post">category_theory.limits.colimit.post</a> (F ⋙ G) H ≫ H.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.post">category_theory.limits.colimit.post</a> F G) =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.post">category_theory.limits.colimit.post</a> F (G ⋙ H)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.pre_post"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L842">category_theory.limits.colimit.pre_post</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">(G : C ⥤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (E ⋙ F)]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (F ⋙ G)]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> ((E ⋙ F) ⋙ G)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.post">category_theory.limits.colimit.post</a> (E ⋙ F) G ≫ G.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> F E) =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> (F ⋙ G) E ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.post">category_theory.limits.colimit.post</a> F G</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.has_colimit_equivalence_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L856">category_theory.limits.has_colimit_equivalence_comp</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">(e : K ≌ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (e.functor ⋙ F)</div>
<div class="indent"><p></p>
       

Attributes: instance</div>
</div><div class="def"><a id="category_theory.limits.has_colimit_of_equivalence_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L873">category_theory.limits.has_colimit_of_equivalence_comp</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">(e : K ≌ J)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (e.functor ⋙ F)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> F</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.colim"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L884">category_theory.limits.colim</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">:</span>       <div class="decl_type">(J ⥤ C) ⥤ C</div>
<div class="indent"><p><code>colimit F</code> is functorial in <code>F</code>, when <code>C</code> has all colimits of shape <code>J</code>.</p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colim.ι_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L897">category_theory.limits.colim.ι_map</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">{G : J ⥤ C}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(j : J)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j ≫ category_theory.limits.colim.map α =
  α.app j ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> G j</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colim.ι_map_assoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L897">category_theory.limits.colim.ι_map_assoc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">{G : J ⥤ C}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(j : J)</span> <span class="decl_args">{X' : C}</span> <span class="decl_args">(f' : category_theory.limits.colim.obj G ⟶ X')</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> F j ≫ category_theory.limits.colim.map α ≫ f' =
  α.app j ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.ι">category_theory.limits.colimit.ι</a> G j ≫ f'</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.map_desc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L900">category_theory.limits.colimit.map_desc</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">{G : J ⥤ C}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocone">category_theory.limits.cocone</a> G)</span> <span class="decl_args">:</span>       <div class="decl_type">category_theory.limits.colim.map α ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> G c =
  <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.desc">category_theory.limits.colimit.desc</a> F ((<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.limits.cocones.precompose">category_theory.limits.cocones.precompose</a> α).obj c)</div>
<div class="indent"><p></p>
       

Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.colimit.pre_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L904">category_theory.limits.colimit.pre_map</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">{G : J ⥤ C}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> K C]</span> <span class="decl_args">(E : K ⥤ J)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> F E ≫ category_theory.limits.colim.map α =
  category_theory.limits.colim.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/whiskering.html#category_theory.whisker_left">category_theory.whisker_left</a> E α) ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> G E</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colimit.pre_map'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L908">category_theory.limits.colimit.pre_map'</a></span> <span class="decl_args">{J K : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> K]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> K C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">{E₁ E₂ : K ⥤ J}</span> <span class="decl_args">(α : E₁ ⟶ E₂)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> F E₁ =
  category_theory.limits.colim.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/whiskering.html#category_theory.whisker_right">category_theory.whisker_right</a> α F) ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> F E₂</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colimit.pre_id"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L913">category_theory.limits.colimit.pre_id</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">(F : J ⥤ C)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.pre">category_theory.limits.colimit.pre</a> F (𝟭 J) =
  category_theory.limits.colim.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/whiskering.html#category_theory.functor.left_unitor">category_theory.functor.left_unitor</a> F).hom)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="thm"><a id="category_theory.limits.colimit.map_post"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L916">category_theory.limits.colimit.map_post</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{F : J ⥤ C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">{G : J ⥤ C}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J D]</span> <span class="decl_args">(H : C ⥤ D)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.post">category_theory.limits.colimit.post</a> F H ≫ H.map (category_theory.limits.colim.map α) =
  category_theory.limits.colim.map (<a href="https://robertylewis.com/mathlib_docs/category_theory/whiskering.html#category_theory.whisker_right">category_theory.whisker_right</a> α H) ≫ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colimit.post">category_theory.limits.colimit.post</a> G H</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.colim_coyoneda"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L927">category_theory.limits.colim_coyoneda</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/opposites.html#category_theory.functor.op">category_theory.functor.op</a> <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.colim">category_theory.limits.colim</a> ⋙ <a href="https://robertylewis.com/mathlib_docs/category_theory/yoneda.html#category_theory.coyoneda">category_theory.coyoneda</a> ≅ <a href="https://robertylewis.com/mathlib_docs/category_theory/limits/cones.html#category_theory.cocones">category_theory.cocones</a> J C</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="category_theory.limits.has_colimits_of_shape_of_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category_theory/limits/limits.lean#L933">category_theory.limits.has_colimits_of_shape_of_equivalence</a></span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J' : Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J']</span> <span class="decl_args">(e : J ≌ J')</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> J' C</div>
<div class="indent"><p></p>
       

</div>
</div></body></html>