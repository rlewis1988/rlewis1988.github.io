<!DOCTYPE html><html lang="en"><head><title>category_theory.limits.shapes.products</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><p></p>
</div><div class="def"><a id="category_theory.limits.fan"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L22">category_theory.limits.fan</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(f : β → C)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.limits.cofan"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L23">category_theory.limits.cofan</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(f : β → C)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.limits.fan.mk"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L25">category_theory.limits.fan.mk</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{f : β → C}</span> <span class="decl_args">{P : C}</span> <span class="decl_args">(p : Π (b : β), P ⟶ f b)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/shapes/products.html#category_theory.limits.fan">category_theory.limits.fan</a> f</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.limits.cofan.mk"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L29">category_theory.limits.cofan.mk</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{f : β → C}</span> <span class="decl_args">{P : C}</span> <span class="decl_args">(p : Π (b : β), f b ⟶ P)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/limits/shapes/products.html#category_theory.limits.cofan">category_theory.limits.cofan</a> f</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.limits.fan.mk_π_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L33">category_theory.limits.fan.mk_π_app</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{f : β → C}</span> <span class="decl_args">{P : C}</span> <span class="decl_args">(p : Π (b : β), P ⟶ f b)</span> <span class="decl_args">(b : β)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/shapes/products.html#category_theory.limits.fan.mk">category_theory.limits.fan.mk</a> p).π).app b = p b</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.limits.cofan.mk_π_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L34">category_theory.limits.cofan.mk_π_app</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{f : β → C}</span> <span class="decl_args">{P : C}</span> <span class="decl_args">(p : Π (b : β), f b ⟶ P)</span> <span class="decl_args">(b : β)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/shapes/products.html#category_theory.limits.cofan.mk">category_theory.limits.cofan.mk</a> p).ι).app b = p b</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.pi_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L39">category_theory.limits.pi_obj</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(f : β → C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> f)]</span> <span class="decl_args">:</span>       <div class="decl_type">C</div>
<div class="indent"><p><code>pi_obj f</code> computes the product of a family of elements <code>f</code>. (It is defined as an abbreviation
  for <code>limit (functor.of_function f)</code>, so for most facts about <code>pi_obj f</code>, you will just use general facts
  about limits.)</p>
       </div>
</div><div class="def"><a id="category_theory.limits.sigma_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L43">category_theory.limits.sigma_obj</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(f : β → C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> f)]</span> <span class="decl_args">:</span>       <div class="decl_type">C</div>
<div class="indent"><p><code>sigma_obj f</code> computes the coproduct of a family of elements <code>f</code>. (It is defined as an abbreviation
  for <code>colimit (functor.of_function f)</code>, so for most facts about <code>sigma_obj f</code>, you will just use general facts
  about colimits.)</p>
       </div>
</div><div class="def"><a id="category_theory.limits.pi.π"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L48">category_theory.limits.pi.π</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(f : β → C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> f)]</span> <span class="decl_args">(b : β)</span> <span class="decl_args">:</span>       <div class="decl_type">∏ f ⟶ f b</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.limits.sigma.ι"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L50">category_theory.limits.sigma.ι</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(f : β → C)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> f)]</span> <span class="decl_args">(b : β)</span> <span class="decl_args">:</span>       <div class="decl_type">f b ⟶ ∐ f</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.limits.pi.lift"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L53">category_theory.limits.pi.lift</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{f : β → C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> f)]</span> <span class="decl_args">{P : C}</span> <span class="decl_args">(p : Π (b : β), P ⟶ f b)</span> <span class="decl_args">:</span>       <div class="decl_type">P ⟶ ∏ f</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.limits.sigma.desc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L55">category_theory.limits.sigma.desc</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{f : β → C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimit">category_theory.limits.has_colimit</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> f)]</span> <span class="decl_args">{P : C}</span> <span class="decl_args">(p : Π (b : β), f b ⟶ P)</span> <span class="decl_args">:</span>       <div class="decl_type">∐ f ⟶ P</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.limits.pi.map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L58">category_theory.limits.pi.map</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{f g : β → C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_limits_of_shape">category_theory.limits.has_limits_of_shape</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/discrete_category.html#category_theory.discrete">category_theory.discrete</a> β) C]</span> <span class="decl_args">(p : Π (b : β), f b ⟶ g b)</span> <span class="decl_args">:</span>       <div class="decl_type">∏ f ⟶ ∏ g</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.limits.sigma.map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L61">category_theory.limits.sigma.map</a></span> <span class="decl_args">{β : Type v}</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{f g : β → C}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/limits/limits.html#category_theory.limits.has_colimits_of_shape">category_theory.limits.has_colimits_of_shape</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/discrete_category.html#category_theory.discrete">category_theory.discrete</a> β) C]</span> <span class="decl_args">(p : Π (b : β), f b ⟶ g b)</span> <span class="decl_args">:</span>       <div class="decl_type">∐ f ⟶ ∐ g</div>
<div class="indent"><p></p>
       </div>
</div><div class="cnst"><a id="category_theory.limits.has_products"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L67">category_theory.limits.has_products</a></span> <span class="decl_args">(C : Type u)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u (v+1))</div>
<div class="indent"><p></p>
       </div>
</div><div class="cnst"><a id="category_theory.limits.has_coproducts"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/limits/shapes/products.lean#L69">category_theory.limits.has_coproducts</a></span> <span class="decl_args">(C : Type u)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u (v+1))</div>
<div class="indent"><p></p>
       </div>
</div></body></html>