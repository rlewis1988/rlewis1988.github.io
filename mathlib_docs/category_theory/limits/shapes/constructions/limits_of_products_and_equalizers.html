<!DOCTYPE html><html lang="en"><head><title>category_theory.limits.shapes.constructions.limits_of_products_and_equalizers</title><meta charset="UTF-8"><link rel="stylesheet" href="/home/rob/lean/mathlib/scripts/html_out/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="/home/rob/lean/mathlib/scripts/html_out/index.html">root</a>/<br><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/index.html">category_theory</a>/<br><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/index.html">limits</a>/<br><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/index.html">shapes</a>/<br><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/constructions/index.html">constructions</a>/<br><a href="limits_of_products_and_equalizers.html">limits_of_products_and_equalizers</a></div><div class="mod_doc"><h1>Constructing limits from products and equalizers.</h1>

<p>If a category has all products, and all equalizers, then it has all limits.
Similarly, if it has all finite products, and all equalizers, then it has all finite limits.</p>

<p>TODO: provide the dual result.</p>
</div><div class="def"><a id="category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/limits/shapes/constructions/limits_of_products_and_equalizers.lean#L56">category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[ùíû : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">(F : J ‚•§ C)</span> <span class="decl_args">[H‚ÇÅ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> (F.obj))]</span> <span class="decl_args">[H‚ÇÇ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a>
  (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj ((f.fst).snd)))]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/equalizers.html#category_theory.limits.walking_parallel_pair">category_theory.limits.walking_parallel_pair</a> ‚•§ C</div>
<div class="indent"><p>Corresponding to any functor <code>F : J ‚•§ C</code>, we construct a new functor from the walking parallel
pair of morphisms to <code>C</code>, given by the diagram
<code>lean
         s
‚àè_j F j ===&gt; Œ†_{f : j ‚ü∂ j'} F j'
         t
</code>
where the two morphisms <code>s</code> and <code>t</code> are defined componentwise:
* The <code>s_f</code> component is the projection <code>‚àè_j F j ‚ü∂ F j</code> followed by <code>f</code>.
* The <code>t_f</code> component is the projection <code>‚àè_j F j ‚ü∂ F j'</code>.</p>

<p>In a moment we prove that cones over <code>F</code> are isomorphic to cones over this new diagram.</p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/limits/shapes/constructions/limits_of_products_and_equalizers.lean#L67">category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[ùíû : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">(F : J ‚•§ C)</span> <span class="decl_args">[H‚ÇÅ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> (F.obj))]</span> <span class="decl_args">[H‚ÇÇ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a>
  (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj ((f.fst).snd)))]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/constructions/limits_of_products_and_equalizers.html#category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram">category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram</a> F) ‚ü∂
  <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F</div>
<div class="indent"><p>The morphism from cones over the walking pair diagram <code>diagram F</code> to cones over
the original diagram <code>F</code>.</p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/limits/shapes/constructions/limits_of_products_and_equalizers.lean#L82">category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[ùíû : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">(F : J ‚•§ C)</span> <span class="decl_args">[H‚ÇÅ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> (F.obj))]</span> <span class="decl_args">[H‚ÇÇ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a>
  (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj ((f.fst).snd)))]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F ‚ü∂
  <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/constructions/limits_of_products_and_equalizers.html#category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram">category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram</a> F)</div>
<div class="indent"><p>The morphism from cones over the original diagram <code>F</code> to cones over the walking pair diagram
<code>diagram F</code>.</p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/limits/shapes/constructions/limits_of_products_and_equalizers.lean#L99">category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_iso</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[ùíû : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{J : Type v}</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> J]</span> <span class="decl_args">(F : J ‚•§ C)</span> <span class="decl_args">[H‚ÇÅ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> (F.obj))]</span> <span class="decl_args">[H‚ÇÇ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/limits.html#category_theory.limits.has_limit">category_theory.limits.has_limit</a>
  (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/discrete_category.html#category_theory.functor.of_function">category_theory.functor.of_function</a> (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj ((f.fst).snd)))]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/constructions/limits_of_products_and_equalizers.html#category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram">category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram</a> F) ‚âÖ
  <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/cones.html#category_theory.functor.cones">category_theory.functor.cones</a> F</div>
<div class="indent"><p>The natural isomorphism between cones over the
walking pair diagram <code>diagram F</code> and cones over the original diagram <code>F</code>.</p>
       </div>
</div><div class="def"><a id="category_theory.limits.limits_from_equalizers_and_products"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/limits/shapes/constructions/limits_of_products_and_equalizers.lean#L119">category_theory.limits.limits_from_equalizers_and_products</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[ùíû : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/products.html#category_theory.limits.has_products">category_theory.limits.has_products</a> C]</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/equalizers.html#category_theory.limits.has_equalizers">category_theory.limits.has_equalizers</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/limits.html#category_theory.limits.has_limits">category_theory.limits.has_limits</a> C</div>
<div class="indent"><p>Any category with products and equalizers has all limits.</p>
       </div>
</div><div class="def"><a id="category_theory.limits.finite_limits_from_equalizers_and_finite_products"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/limits/shapes/constructions/limits_of_products_and_equalizers.lean#L126">category_theory.limits.finite_limits_from_equalizers_and_finite_products</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[ùíû : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/finite_products.html#category_theory.limits.has_finite_products">category_theory.limits.has_finite_products</a> C]</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/equalizers.html#category_theory.limits.has_equalizers">category_theory.limits.has_equalizers</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/limits/shapes/finite_limits.html#category_theory.limits.has_finite_limits">category_theory.limits.has_finite_limits</a> C</div>
<div class="indent"><p>Any category with finite products and equalizers has all finite limits.</p>
       </div>
</div></body></html>