<!DOCTYPE html><html lang="en"><head><title>category_theory.types</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><p></p>
</div><div class="def"><a id="category_theory.types"></a>      <span class="decl_name">category_theory.types</span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.large_category">category_theory.large_category</a> (Type u)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="thm"><a id="category_theory.types_hom"></a>      <span class="decl_name">category_theory.types_hom</span> <span class="decl_args">{α β : Type u}</span> <span class="decl_args">:</span>       <div class="decl_type">(α ⟶ β) = (α → β)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.types_id"></a>      <span class="decl_name">category_theory.types_id</span> <span class="decl_args">(X : Type u)</span> <span class="decl_args">:</span>       <div class="decl_type">𝟙 X = <a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#id">id</a></div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.types_comp"></a>      <span class="decl_name">category_theory.types_comp</span> <span class="decl_args">{X Y Z : Type u}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(g : Y ⟶ Z)</span> <span class="decl_args">:</span>       <div class="decl_type">f ≫ g = g ∘ f</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.functor.sections"></a>      <span class="decl_name">category_theory.functor.sections</span> <span class="decl_args">{J : Type u}</span> <span class="decl_args">[𝒥 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> J]</span> <span class="decl_args">(F : J ⥤ Type w)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> (Π (j : J), F.obj j)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.functor_to_types.map_comp"></a>      <span class="decl_name">category_theory.functor_to_types.map_comp</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : C ⥤ Type w)</span> <span class="decl_args">{X Y Z : C}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(g : Y ⟶ Z)</span> <span class="decl_args">(a : F.obj X)</span> <span class="decl_args">:</span>       <div class="decl_type">F.map (f ≫ g) a = F.map g (F.map f a)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.functor_to_types.map_id"></a>      <span class="decl_name">category_theory.functor_to_types.map_id</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : C ⥤ Type w)</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(a : F.obj X)</span> <span class="decl_args">:</span>       <div class="decl_type">F.map (𝟙 X) a = a</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.functor_to_types.naturality"></a>      <span class="decl_name">category_theory.functor_to_types.naturality</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F G : C ⥤ Type w)</span> <span class="decl_args">{X Y : C}</span> <span class="decl_args">(σ : F ⟶ G)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(x : F.obj X)</span> <span class="decl_args">:</span>       <div class="decl_type">σ.app Y (F.map f x) = G.map f (σ.app X x)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.functor_to_types.comp"></a>      <span class="decl_name">category_theory.functor_to_types.comp</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F G H : C ⥤ Type w)</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(σ : F ⟶ G)</span> <span class="decl_args">(τ : G ⟶ H)</span> <span class="decl_args">(x : F.obj X)</span> <span class="decl_args">:</span>       <div class="decl_type">(σ ≫ τ).app X x = τ.app X (σ.app X x)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.functor_to_types.hcomp"></a>      <span class="decl_name">category_theory.functor_to_types.hcomp</span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F G : C ⥤ Type w)</span> <span class="decl_args">(σ : F ⟶ G)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(I J : D ⥤ C)</span> <span class="decl_args">(ρ : I ⟶ J)</span> <span class="decl_args">{W : D}</span> <span class="decl_args">(x : (I ⋙ F).obj W)</span> <span class="decl_args">:</span>       <div class="decl_type">(ρ ◫ σ).app W x = G.map (ρ.app W) (σ.app (I.obj W) x)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.ulift_trivial"></a>      <span class="decl_name">category_theory.ulift_trivial</span> <span class="decl_args">(V : Type u)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#ulift">ulift</a> V ≅ V</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.ulift_functor"></a>      <span class="decl_name">category_theory.ulift_functor</span>  <span class="decl_args">:</span>       <div class="decl_type">Type u ⥤ Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.ulift_functor_map"></a>      <span class="decl_name">category_theory.ulift_functor_map</span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(x : <a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#ulift">ulift</a> X)</span> <span class="decl_args">:</span>       <div class="decl_type">category_theory.ulift_functor.map f x = {down := f (x.down)}</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.ulift_functor_full"></a>      <span class="decl_name">category_theory.ulift_functor_full</span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.full">category_theory.full</a> <a href="https://robertylewis.com/mathlib_docs/category_theory/types.html#category_theory.ulift_functor">category_theory.ulift_functor</a></div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.ulift_functor_faithful"></a>      <span class="decl_name">category_theory.ulift_functor_faithful</span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> <a href="https://robertylewis.com/mathlib_docs/category_theory/types.html#category_theory.ulift_functor">category_theory.ulift_functor</a></div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.hom_of_element"></a>      <span class="decl_name">category_theory.hom_of_element</span> <span class="decl_args">{X : Type u}</span> <span class="decl_args">(x : X)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#punit">punit</a> ⟶ X</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.hom_of_element_eq_iff"></a>      <span class="decl_name">category_theory.hom_of_element_eq_iff</span> <span class="decl_args">{X : Type u}</span> <span class="decl_args">(x y : X)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/types.html#category_theory.hom_of_element">category_theory.hom_of_element</a> x = <a href="https://robertylewis.com/mathlib_docs/category_theory/types.html#category_theory.hom_of_element">category_theory.hom_of_element</a> y ↔ x = y</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.mono_iff_injective"></a>      <span class="decl_name">category_theory.mono_iff_injective</span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.mono">category_theory.mono</a> f ↔ <a href="https://robertylewis.com/mathlib_docs/core/init/function.html#function.injective">function.injective</a> f</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.epi_iff_surjective"></a>      <span class="decl_name">category_theory.epi_iff_surjective</span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.epi">category_theory.epi</a> f ↔ <a href="https://robertylewis.com/mathlib_docs/core/init/function.html#function.surjective">function.surjective</a> f</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.of_type_functor"></a>      <span class="decl_name">category_theory.of_type_functor</span> <span class="decl_args">(m : Type u → Type v)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/functor.html#functor">functor</a> m]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m]</span> <span class="decl_args">:</span>       <div class="decl_type">Type u ⥤ Type v</div>
<div class="indent"><p><code>of_type_functor m</code> converts from Lean's <code>Type</code>-based <code>category</code> to <code>category_theory</code>. This
allows us to use these functors in category theory.</p>
       </div>
</div><div class="thm"><a id="category_theory.of_type_functor_obj"></a>      <span class="decl_name">category_theory.of_type_functor_obj</span> <span class="decl_args">(m : Type u → Type v)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/functor.html#functor">functor</a> m]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m]</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/types.html#category_theory.of_type_functor">category_theory.of_type_functor</a> m).obj = m</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.of_type_functor_map"></a>      <span class="decl_name">category_theory.of_type_functor_map</span> <span class="decl_args">(m : Type u → Type v)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/functor.html#functor">functor</a> m]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m]</span> <span class="decl_args">{α β : Type u}</span> <span class="decl_args">(f : α → β)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/types.html#category_theory.of_type_functor">category_theory.of_type_functor</a> m).map f = functor.map f</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="equiv.to_iso"></a>      <span class="decl_name">equiv.to_iso</span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(e : X ≃ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">X ≅ Y</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="equiv.to_iso_hom"></a>      <span class="decl_name">equiv.to_iso_hom</span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">{e : X ≃ Y}</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/types.html#equiv.to_iso">equiv.to_iso</a> e).hom = ⇑e</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="equiv.to_iso_inv"></a>      <span class="decl_name">equiv.to_iso_inv</span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">{e : X ≃ Y}</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/types.html#equiv.to_iso">equiv.to_iso</a> e).inv = ⇑(<a href="https://robertylewis.com/mathlib_docs/data/equiv/basic.html#equiv.symm">equiv.symm</a> e)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.iso.to_equiv"></a>      <span class="decl_name">category_theory.iso.to_equiv</span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(i : X ≅ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">X ≃ Y</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.iso.to_equiv_fun"></a>      <span class="decl_name">category_theory.iso.to_equiv_fun</span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(i : X ≅ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">⇑(<a href="https://robertylewis.com/mathlib_docs/category_theory/types.html#category_theory.iso.to_equiv">category_theory.iso.to_equiv</a> i) = i.hom</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.iso.to_equiv_symm_fun"></a>      <span class="decl_name">category_theory.iso.to_equiv_symm_fun</span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(i : X ≅ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">⇑(<a href="https://robertylewis.com/mathlib_docs/data/equiv/basic.html#equiv.symm">equiv.symm</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/types.html#category_theory.iso.to_equiv">category_theory.iso.to_equiv</a> i)) = i.inv</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div></body></html>