<html><head><title>category_theory.types</title><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><p></p>
</div><div class="entry"><a id="category_theory.types">      <h4>category_theory.types</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.large_category">category_theory.large_category</a> (Type u)</code>
<div class="indent"><p><p></p>
</p>       Attributes: instance</div>
</div><div class="entry"><a id="category_theory.types_hom">      <h4>category_theory.types_hom</h4><code>∀ {α β : Type u}, (α ⟶ β) = (α → β)</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.types_id">      <h4>category_theory.types_id</h4><code>∀ (X : Type u), 𝟙 X = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#id">id</a></code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.types_comp">      <h4>category_theory.types_comp</h4><code>∀ {X Y Z : Type u} (f : X ⟶ Y) (g : Y ⟶ Z), f ≫ g = g ∘ f</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.functor.sections">      <h4>category_theory.functor.sections</h4><code>Π {J : Type u} [𝒥 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> J] (F : J ⥤ Type w), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (Π (j : J), F.obj j)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.functor_to_types.map_comp">      <h4>category_theory.functor_to_types.map_comp</h4><code>∀ {C : Type u} [𝒞 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C] (F : C ⥤ Type w) {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z)
(a : F.obj X), F.map (f ≫ g) a = F.map g (F.map f a)</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.functor_to_types.map_id">      <h4>category_theory.functor_to_types.map_id</h4><code>∀ {C : Type u} [𝒞 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C] (F : C ⥤ Type w) {X : C} (a : F.obj X), F.map (𝟙 X) a = a</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.functor_to_types.naturality">      <h4>category_theory.functor_to_types.naturality</h4><code>∀ {C : Type u} [𝒞 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C] (F G : C ⥤ Type w) {X Y : C} (σ : F ⟶ G) (f : X ⟶ Y)
(x : F.obj X), σ.app Y (F.map f x) = G.map f (σ.app X x)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.functor_to_types.comp">      <h4>category_theory.functor_to_types.comp</h4><code>∀ {C : Type u} [𝒞 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C] (F G H : C ⥤ Type w) {X : C} (σ : F ⟶ G) (τ : G ⟶ H)
(x : F.obj X), (σ ≫ τ).app X x = τ.app X (σ.app X x)</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.functor_to_types.hcomp">      <h4>category_theory.functor_to_types.hcomp</h4><code>∀ {C : Type u} [𝒞 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C] (F G : C ⥤ Type w) (σ : F ⟶ G) {D : Type u'}
[𝒟 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> D] (I J : D ⥤ C) (ρ : I ⟶ J) {W : D} (x : (I ⋙ F).obj W),
  (ρ ◫ σ).app W x = G.map (ρ.app W) (σ.app (I.obj W) x)</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.ulift_trivial">      <h4>category_theory.ulift_trivial</h4><code>Π (V : Type u), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#ulift">ulift</a> V ≅ V</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.ulift_functor">      <h4>category_theory.ulift_functor</h4><code>Type u ⥤ Type (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/algebra/functions.html#max">max</a> u v)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.ulift_functor_map">      <h4>category_theory.ulift_functor_map</h4><code>∀ {X Y : Type u} (f : X ⟶ Y) (x : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#ulift">ulift</a> X), category_theory.ulift_functor.map f x = {down := f (x.down)}</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.ulift_functor_full">      <h4>category_theory.ulift_functor_full</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/fully_faithful.html#category_theory.full">category_theory.full</a> <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.ulift_functor">category_theory.ulift_functor</a></code>
<div class="indent"><p><p></p>
</p>       Attributes: instance</div>
</div><div class="entry"><a id="category_theory.ulift_functor_faithful">      <h4>category_theory.ulift_functor_faithful</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.ulift_functor">category_theory.ulift_functor</a></code>
<div class="indent"><p><p></p>
</p>       Attributes: instance</div>
</div><div class="entry"><a id="category_theory.hom_of_element">      <h4>category_theory.hom_of_element</h4><code>Π {X : Type u}, X → (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#punit">punit</a> ⟶ X)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.hom_of_element_eq_iff">      <h4>category_theory.hom_of_element_eq_iff</h4><code>∀ {X : Type u} (x y : X), <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.hom_of_element">category_theory.hom_of_element</a> x = <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.hom_of_element">category_theory.hom_of_element</a> y ↔ x = y</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.mono_iff_injective">      <h4>category_theory.mono_iff_injective</h4><code>∀ {X Y : Type u} (f : X ⟶ Y), <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.mono">category_theory.mono</a> f ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> f</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.epi_iff_surjective">      <h4>category_theory.epi_iff_surjective</h4><code>∀ {X Y : Type u} (f : X ⟶ Y), <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.epi">category_theory.epi</a> f ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.surjective">function.surjective</a> f</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.of_type_functor">      <h4>category_theory.of_type_functor</h4><code>Π (m : Type u → Type v) [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/functor.html#functor">functor</a> m] [_inst_2 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m], Type u ⥤ Type v</code>
<div class="indent"><p><p><code>of_type_functor m</code> converts from Lean's <code>Type</code>-based <code>category</code> to <code>category_theory</code>. This
allows us to use these functors in category theory.</p>
</p>       </div>
</div><div class="entry"><a id="category_theory.of_type_functor_obj">      <h4>category_theory.of_type_functor_obj</h4><code>∀ (m : Type u → Type v) [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/functor.html#functor">functor</a> m] [_inst_2 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m],
  (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.of_type_functor">category_theory.of_type_functor</a> m).obj = m</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.of_type_functor_map">      <h4>category_theory.of_type_functor_map</h4><code>∀ (m : Type u → Type v) [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/functor.html#functor">functor</a> m] [_inst_2 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m] {α β : Type u} (f : α → β),
  (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.of_type_functor">category_theory.of_type_functor</a> m).map f = functor.map f</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="equiv.to_iso">      <h4>equiv.to_iso</h4><code>Π {X Y : Type u}, X ≃ Y → (X ≅ Y)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="equiv.to_iso_hom">      <h4>equiv.to_iso_hom</h4><code>∀ {X Y : Type u} {e : X ≃ Y}, (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#equiv.to_iso">equiv.to_iso</a> e).hom = ⇑e</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="equiv.to_iso_inv">      <h4>equiv.to_iso_inv</h4><code>∀ {X Y : Type u} {e : X ≃ Y}, (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#equiv.to_iso">equiv.to_iso</a> e).inv = ⇑(<a href="/home/rob/lean/mathlib/scripts/html_out/data/equiv/basic.html#equiv.symm">equiv.symm</a> e)</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.iso.to_equiv">      <h4>category_theory.iso.to_equiv</h4><code>Π {X Y : Type u}, (X ≅ Y) → X ≃ Y</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.iso.to_equiv_fun">      <h4>category_theory.iso.to_equiv_fun</h4><code>∀ {X Y : Type u} (i : X ≅ Y), ⇑(<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.iso.to_equiv">category_theory.iso.to_equiv</a> i) = i.hom</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.iso.to_equiv_symm_fun">      <h4>category_theory.iso.to_equiv_symm_fun</h4><code>∀ {X Y : Type u} (i : X ≅ Y), ⇑(<a href="/home/rob/lean/mathlib/scripts/html_out/data/equiv/basic.html#equiv.symm">equiv.symm</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.iso.to_equiv">category_theory.iso.to_equiv</a> i)) = i.inv</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div></body></html>