<!DOCTYPE html><html lang="en"><head><title>category_theory.types</title><meta charset="UTF-8"><link rel="stylesheet" href="/home/rob/lean/mathlib/scripts/html_out/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="/home/rob/lean/mathlib/scripts/html_out/index.html">root</a>/<br><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/index.html">category_theory</a>/<br><a href="types.html">types</a></div><div class="mod_doc"><p></p>
</div><div class="def"><a id="category_theory.types"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L14">category_theory.types</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.large_category">category_theory.large_category</a> (Type u)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="thm"><a id="category_theory.types_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L19">category_theory.types_hom</a></span> <span class="decl_args">{α β : Type u}</span> <span class="decl_args">:</span>       <div class="decl_type">(α ⟶ β) = (α → β)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.types_id"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L20">category_theory.types_id</a></span> <span class="decl_args">(X : Type u)</span> <span class="decl_args">:</span>       <div class="decl_type">𝟙 X = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#id">id</a></div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.types_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L21">category_theory.types_comp</a></span> <span class="decl_args">{X Y Z : Type u}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(g : Y ⟶ Z)</span> <span class="decl_args">:</span>       <div class="decl_type">f ≫ g = g ∘ f</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.functor.sections"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L27">category_theory.functor.sections</a></span> <span class="decl_args">{J : Type u}</span> <span class="decl_args">[𝒥 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> J]</span> <span class="decl_args">(F : J ⥤ Type w)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (Π (j : J), F.obj j)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.functor_to_types.map_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L36">category_theory.functor_to_types.map_comp</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : C ⥤ Type w)</span> <span class="decl_args">{X Y Z : C}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(g : Y ⟶ Z)</span> <span class="decl_args">(a : F.obj X)</span> <span class="decl_args">:</span>       <div class="decl_type">F.map (f ≫ g) a = F.map g (F.map f a)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.functor_to_types.map_id"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L39">category_theory.functor_to_types.map_id</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F : C ⥤ Type w)</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(a : F.obj X)</span> <span class="decl_args">:</span>       <div class="decl_type">F.map (𝟙 X) a = a</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.functor_to_types.naturality"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L42">category_theory.functor_to_types.naturality</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F G : C ⥤ Type w)</span> <span class="decl_args">{X Y : C}</span> <span class="decl_args">(σ : F ⟶ G)</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(x : F.obj X)</span> <span class="decl_args">:</span>       <div class="decl_type">σ.app Y (F.map f x) = G.map f (σ.app X x)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.functor_to_types.comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L45">category_theory.functor_to_types.comp</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F G H : C ⥤ Type w)</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(σ : F ⟶ G)</span> <span class="decl_args">(τ : G ⟶ H)</span> <span class="decl_args">(x : F.obj X)</span> <span class="decl_args">:</span>       <div class="decl_type">(σ ≫ τ).app X x = τ.app X (σ.app X x)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.functor_to_types.hcomp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L49">category_theory.functor_to_types.hcomp</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(F G : C ⥤ Type w)</span> <span class="decl_args">(σ : F ⟶ G)</span> <span class="decl_args">{D : Type u'}</span> <span class="decl_args">[𝒟 : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(I J : D ⥤ C)</span> <span class="decl_args">(ρ : I ⟶ J)</span> <span class="decl_args">{W : D}</span> <span class="decl_args">(x : (I ⋙ F).obj W)</span> <span class="decl_args">:</span>       <div class="decl_type">(ρ ◫ σ).app W x = G.map (ρ.app W) (σ.app (I.obj W) x)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.ulift_trivial"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L53">category_theory.ulift_trivial</a></span> <span class="decl_args">(V : Type u)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#ulift">ulift</a> V ≅ V</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.ulift_functor"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L55">category_theory.ulift_functor</a></span>  <span class="decl_args">:</span>       <div class="decl_type">Type u ⥤ Type (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.ulift_functor_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L59">category_theory.ulift_functor_map</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">(x : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#ulift">ulift</a> X)</span> <span class="decl_args">:</span>       <div class="decl_type">category_theory.ulift_functor.map f x = {down := f (x.down)}</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.ulift_functor_full"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L62">category_theory.ulift_functor_full</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/fully_faithful.html#category_theory.full">category_theory.full</a> <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.ulift_functor">category_theory.ulift_functor</a></div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.ulift_functor_faithful"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L64">category_theory.ulift_functor_faithful</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.ulift_functor">category_theory.ulift_functor</a></div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.hom_of_element"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L68">category_theory.hom_of_element</a></span> <span class="decl_args">{X : Type u}</span> <span class="decl_args">(x : X)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#punit">punit</a> ⟶ X</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.hom_of_element_eq_iff"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L70">category_theory.hom_of_element_eq_iff</a></span> <span class="decl_args">{X : Type u}</span> <span class="decl_args">(x y : X)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.hom_of_element">category_theory.hom_of_element</a> x = <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.hom_of_element">category_theory.hom_of_element</a> y ↔ x = y</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.mono_iff_injective"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L74">category_theory.mono_iff_injective</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.mono">category_theory.mono</a> f ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> f</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.epi_iff_surjective"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L87">category_theory.epi_iff_surjective</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.epi">category_theory.epi</a> f ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.surjective">function.surjective</a> f</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.of_type_functor"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L118">category_theory.of_type_functor</a></span> <span class="decl_args">(m : Type u → Type v)</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/functor.html#functor">functor</a> m]</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m]</span> <span class="decl_args">:</span>       <div class="decl_type">Type u ⥤ Type v</div>
<div class="indent"><p><code>of_type_functor m</code> converts from Lean's <code>Type</code>-based <code>category</code> to <code>category_theory</code>. This
allows us to use these functors in category theory.</p>
       </div>
</div><div class="thm"><a id="category_theory.of_type_functor_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L128">category_theory.of_type_functor_obj</a></span> <span class="decl_args">(m : Type u → Type v)</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/functor.html#functor">functor</a> m]</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m]</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.of_type_functor">category_theory.of_type_functor</a> m).obj = m</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.of_type_functor_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L131">category_theory.of_type_functor_map</a></span> <span class="decl_args">(m : Type u → Type v)</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/functor.html#functor">functor</a> m]</span> <span class="decl_args">[<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m]</span> <span class="decl_args">{α β : Type u}</span> <span class="decl_args">(f : α → β)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.of_type_functor">category_theory.of_type_functor</a> m).map f = functor.map f</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="equiv.to_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L146">equiv.to_iso</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(e : X ≃ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">X ≅ Y</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="equiv.to_iso_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L152">equiv.to_iso_hom</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">{e : X ≃ Y}</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#equiv.to_iso">equiv.to_iso</a> e).hom = ⇑e</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="equiv.to_iso_inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L153">equiv.to_iso_inv</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">{e : X ≃ Y}</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#equiv.to_iso">equiv.to_iso</a> e).inv = ⇑(<a href="/home/rob/lean/mathlib/scripts/html_out/data/equiv/basic.html#equiv.symm">equiv.symm</a> e)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.iso.to_equiv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L163">category_theory.iso.to_equiv</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(i : X ≅ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">X ≃ Y</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.iso.to_equiv_fun"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L169">category_theory.iso.to_equiv_fun</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(i : X ≅ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">⇑(<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.iso.to_equiv">category_theory.iso.to_equiv</a> i) = i.hom</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.iso.to_equiv_symm_fun"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L170">category_theory.iso.to_equiv_symm_fun</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(i : X ≅ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">⇑(<a href="/home/rob/lean/mathlib/scripts/html_out/data/equiv/basic.html#equiv.symm">equiv.symm</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.iso.to_equiv">category_theory.iso.to_equiv</a> i)) = i.inv</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="equiv_iso_iso_inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L181">equiv_iso_iso_inv</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(i : X ≅ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">equiv_iso_iso.inv i = <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.iso.to_equiv">category_theory.iso.to_equiv</a> i</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="equiv_iso_iso_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L181">equiv_iso_iso_hom</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(e : X ≃ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">equiv_iso_iso.hom e = <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#equiv.to_iso">equiv.to_iso</a> e</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="equiv_iso_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L181">equiv_iso_iso</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">:</span>       <div class="decl_type">X ≃ Y ≅ X ≅ Y</div>
<div class="indent"><p>equivalences (between types in the same universe) are the same as (isomorphic to) isomorphisms of types</p>
       </div>
</div><div class="def"><a id="equiv_equiv_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L187">equiv_equiv_iso</a></span> <span class="decl_args">(X Y : Type u)</span> <span class="decl_args">:</span>       <div class="decl_type">X ≃ Y ≃ (X ≅ Y)</div>
<div class="indent"><p>equivalences (between types in the same universe) are the same as (equivalent to) isomorphisms of types</p>
       </div>
</div><div class="thm"><a id="equiv_equiv_iso_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L190">equiv_equiv_iso_hom</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(e : X ≃ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">⇑(<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#equiv_equiv_iso">equiv_equiv_iso</a> X Y) e = <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#equiv.to_iso">equiv.to_iso</a> e</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="equiv_equiv_iso_inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/category_theory/types.lean#L191">equiv_equiv_iso_inv</a></span> <span class="decl_args">{X Y : Type u}</span> <span class="decl_args">(e : X ≅ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">⇑(<a href="/home/rob/lean/mathlib/scripts/html_out/data/equiv/basic.html#equiv.symm">equiv.symm</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#equiv_equiv_iso">equiv_equiv_iso</a> X Y)) e = <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.iso.to_equiv">category_theory.iso.to_equiv</a> e</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div></body></html>