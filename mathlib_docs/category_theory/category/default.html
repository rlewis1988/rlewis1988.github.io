<!DOCTYPE html><html lang="en"><head><title>category_theory.category.default</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/category_theory/index.html">category_theory</a>/<br><a href="https://robertylewis.com/mathlib_docs/category_theory/category/index.html">category</a>/<br><a href="default.html">default</a></div><div class="mod_doc"><p></p>
</div><div class="def"><a id="category_theory.obviously'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L32">category_theory.obviously'</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="cnst"><a id="category_theory.has_hom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L34">category_theory.has_hom</a></span> <span class="decl_args">(obj : Type u)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u (v+1))</div>
<div class="indent"><p></p>
       </div>
</div><div class="cnst"><a id="category_theory.category_struct"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L39">category_theory.category_struct</a></span> <span class="decl_args">(obj : Type u)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u (v+1))</div>
<div class="indent"><p></p>
       </div>
</div><div class="cnst"><a id="category_theory.category"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L52">category_theory.category</a></span> <span class="decl_args">(obj : Type u)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u (v+1))</div>
<div class="indent"><p>The typeclass <code>category C</code> describes morphisms associated to objects of type <code>C</code>.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as <code>category.{v} C</code>. (See also <code>large_category</code> and <code>small_category</code>.)</p>
       </div>
</div><div class="def"><a id="category_theory.large_category"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L73">category_theory.large_category</a></span> <span class="decl_args">(C : Type (u+1))</span> <span class="decl_args">:</span>       <div class="decl_type">Type (u+1)</div>
<div class="indent"><p>A <code>large_category</code> has objects in one universe level higher than the universe level of
the morphisms. It is useful for examples such as the category of types, or the category
of groups, etc.</p>
       </div>
</div><div class="def"><a id="category_theory.small_category"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L77">category_theory.small_category</a></span> <span class="decl_args">(C : Type u)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (u+1)</div>
<div class="indent"><p>A <code>small_category</code> has objects and morphisms in the same universe level.</p>
       </div>
</div><div class="thm"><a id="category_theory.eq_of_comp_left_eq"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L83">category_theory.eq_of_comp_left_eq</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{X Y : C}</span> <span class="decl_args">{f g : X ⟶ Y}</span> <span class="decl_args">(w : ∀ {Z : C} (h : Y ⟶ Z), f ≫ h = g ≫ h)</span> <span class="decl_args">:</span>       <div class="decl_type">f = g</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.eq_of_comp_right_eq"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L85">category_theory.eq_of_comp_right_eq</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{Y Z : C}</span> <span class="decl_args">{f g : Y ⟶ Z}</span> <span class="decl_args">(w : ∀ {X : C} (h : X ⟶ Y), h ≫ f = h ≫ g)</span> <span class="decl_args">:</span>       <div class="decl_type">f = g</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.eq_of_comp_left_eq'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L88">category_theory.eq_of_comp_left_eq'</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{X Y : C}</span> <span class="decl_args">(f g : X ⟶ Y)</span> <span class="decl_args">(w : (λ {Z : C} (h : Y ⟶ Z), f ≫ h) = λ {Z : C} (h : Y ⟶ Z), g ≫ h)</span> <span class="decl_args">:</span>       <div class="decl_type">f = g</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.eq_of_comp_right_eq'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L90">category_theory.eq_of_comp_right_eq'</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{Y Z : C}</span> <span class="decl_args">(f g : Y ⟶ Z)</span> <span class="decl_args">(w : (λ {X : C} (h : X ⟶ Y), h ≫ f) = λ {X : C} (h : X ⟶ Y), h ≫ g)</span> <span class="decl_args">:</span>       <div class="decl_type">f = g</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.id_of_comp_left_id"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L93">category_theory.id_of_comp_left_id</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(f : X ⟶ X)</span> <span class="decl_args">(w : ∀ {Y : C} (g : X ⟶ Y), f ≫ g = g)</span> <span class="decl_args">:</span>       <div class="decl_type">f = 𝟙 X</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.id_of_comp_right_id"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L95">category_theory.id_of_comp_right_id</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(f : X ⟶ X)</span> <span class="decl_args">(w : ∀ {Y : C} (g : Y ⟶ X), g ≫ f = g)</span> <span class="decl_args">:</span>       <div class="decl_type">f = 𝟙 X</div>
<div class="indent"><p></p>
       </div>
</div><div class="cnst"><a id="category_theory.epi"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L98">category_theory.epi</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{X Y : C}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">Prop</div>
<div class="indent"><p></p>
       </div>
</div><div class="cnst"><a id="category_theory.mono"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L100">category_theory.mono</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{X Y : C}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">Prop</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.cancel_epi"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L103">category_theory.cancel_epi</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{X Y Z : C}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.epi">category_theory.epi</a> f]</span> <span class="decl_args">{g h : Y ⟶ Z}</span> <span class="decl_args">:</span>       <div class="decl_type">f ≫ g = f ≫ h ↔ g = h</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.cancel_mono"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L105">category_theory.cancel_mono</a></span> <span class="decl_args">{C : Type u}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{X Y Z : C}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.mono">category_theory.mono</a> f]</span> <span class="decl_args">{g h : Z ⟶ X}</span> <span class="decl_args">:</span>       <div class="decl_type">g ≫ f = h ≫ f ↔ g = h</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.ulift_category"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L115">category_theory.ulift_category</a></span> <span class="decl_args">(C : Type u)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#ulift">ulift</a> C)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="preorder.small_category"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/category/default.lean#L132">preorder.small_category</a></span> <span class="decl_args">(α : Type u)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/order.html#preorder">preorder</a> α]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.small_category">category_theory.small_category</a> α</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div></body></html>