<!DOCTYPE html><html lang="en"><head><title>category_theory.functor_category</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/category_theory/index.html">category_theory</a>/<br><a href="functor_category.html">functor_category</a></div><div class="mod_doc"><p></p>
</div><div class="def"><a id="category_theory.functor.category"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L26">category_theory.functor.category</a></span> <span class="decl_args">(C : Type u₁)</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type u₂)</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> (C ⥤ D)</div>
<div class="indent"><p><code>functor.category C D</code> gives the category structure on functors and natural transformations
between categories <code>C</code> and <code>D</code>.</p>

<p>Notice that if <code>C</code> and <code>D</code> are both small categories at the same universe level,
this is another small category at that level.
However if <code>C</code> and <code>D</code> are both large categories at the same universe level,
this is a small category at the next higher level.</p>
       Attributes: instance</div>
</div><div class="thm"><a id="category_theory.nat_trans.vcomp_eq_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L36">category_theory.nat_trans.vcomp_eq_comp</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F G H : C ⥤ D}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(β : G ⟶ H)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/natural_transformation.html#category_theory.nat_trans.vcomp">category_theory.nat_trans.vcomp</a> α β = α ≫ β</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.nat_trans.congr_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L38">category_theory.nat_trans.congr_app</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F G : C ⥤ D}</span> <span class="decl_args">{α β : F ⟶ G}</span> <span class="decl_args">(h : α = β)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">α.app X = β.app X</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.nat_trans.id_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L39">category_theory.nat_trans.id_app</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C ⥤ D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(𝟙 F).app X = 𝟙 (F.obj X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.nat_trans.comp_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L40">category_theory.nat_trans.comp_app</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F G H : C ⥤ D}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(β : G ⟶ H)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(α ≫ β).app X = α.app X ≫ β.app X</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.nat_trans.app_naturality"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L45">category_theory.nat_trans.app_naturality</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">{F G : C ⥤ D ⥤ E}</span> <span class="decl_args">(T : F ⟶ G)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">{Y Z : D}</span> <span class="decl_args">(f : Y ⟶ Z)</span> <span class="decl_args">:</span>       <div class="decl_type">(F.obj X).map f ≫ (T.app X).app Z = (T.app X).app Y ≫ (G.obj X).map f</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.nat_trans.naturality_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L49">category_theory.nat_trans.naturality_app</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">{F G : C ⥤ D ⥤ E}</span> <span class="decl_args">(T : F ⟶ G)</span> <span class="decl_args">(Z : D)</span> <span class="decl_args">{X Y : C}</span> <span class="decl_args">(f : X ⟶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(F.map f).app Z ≫ (T.app Y).app Z = (T.app X).app Z ≫ (G.map f).app Z</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.nat_trans.hcomp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L54">category_theory.nat_trans.hcomp</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">{F G : C ⥤ D}</span> <span class="decl_args">{H I : D ⥤ E}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(β : H ⟶ I)</span> <span class="decl_args">:</span>       <div class="decl_type">F ⋙ H ⟶ G ⋙ I</div>
<div class="indent"><p><code>hcomp α β</code> is the horizontal composition of natural transformations.</p>
       </div>
</div><div class="thm"><a id="category_theory.nat_trans.hcomp_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L64">category_theory.nat_trans.hcomp_app</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">{F G : C ⥤ D}</span> <span class="decl_args">{H I : D ⥤ E}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(β : H ⟶ I)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(α ◫ β).app X = β.app (F.obj X) ≫ I.map (α.app X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.nat_trans.exchange"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L72">category_theory.nat_trans.exchange</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">{F G H : C ⥤ D}</span> <span class="decl_args">{I J K : D ⥤ E}</span> <span class="decl_args">(α : F ⟶ G)</span> <span class="decl_args">(β : G ⟶ H)</span> <span class="decl_args">(γ : I ⟶ J)</span> <span class="decl_args">(δ : J ⟶ K)</span> <span class="decl_args">:</span>       <div class="decl_type">(α ≫ β) ◫ (γ ≫ δ) = α ◫ γ ≫ β ◫ δ</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.flip"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L82">category_theory.functor.flip</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(F : C ⥤ D ⥤ E)</span> <span class="decl_args">:</span>       <div class="decl_type">D ⥤ C ⥤ E</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.functor.flip_obj_obj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L91">category_theory.functor.flip_obj_obj</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(F : C ⥤ D ⥤ E)</span> <span class="decl_args">(c : C)</span> <span class="decl_args">(d : D)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/functor_category.html#category_theory.functor.flip">category_theory.functor.flip</a> F).obj d).obj c = (F.obj c).obj d</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.functor.flip_obj_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L92">category_theory.functor.flip_obj_map</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(F : C ⥤ D ⥤ E)</span> <span class="decl_args">{c c' : C}</span> <span class="decl_args">(f : c ⟶ c')</span> <span class="decl_args">(d : D)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/functor_category.html#category_theory.functor.flip">category_theory.functor.flip</a> F).obj d).map f = (F.map f).app d</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.functor.flip_map_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/category_theory/functor_category.lean#L94">category_theory.functor.flip_map_app</a></span> <span class="decl_args">{C : Type u₁}</span> <span class="decl_args">[𝒞 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type u₂}</span> <span class="decl_args">[𝒟 : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type u₃}</span> <span class="decl_args">[ℰ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(F : C ⥤ D ⥤ E)</span> <span class="decl_args">{d d' : D}</span> <span class="decl_args">(f : d ⟶ d')</span> <span class="decl_args">(c : C)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/functor_category.html#category_theory.functor.flip">category_theory.functor.flip</a> F).map f).app c = (F.obj c).map f</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div></body></html>