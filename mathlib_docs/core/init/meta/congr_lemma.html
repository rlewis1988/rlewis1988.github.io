<!DOCTYPE html><html lang="en"><head><title>core.init.meta.congr_lemma</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><p></p>
</div><div class="cnst"><a id="congr_arg_kind"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/lean/blob/80c1b4d67eec24f1d1e5b4b3ed7082c27851271d/library/init/meta/congr_lemma.lean#L23">congr_arg_kind</a></span>  <span class="decl_args">:</span>       <div class="decl_type">Type</div>
<div class="indent"><p>This is a kind attached to an argument of a congruence lemma that tells the simplifier how to fill it in.
- <code>fixed</code>: It is a parameter for the congruence lemma, the parameter occurs in the left and right hand sides. 
  For example the α in the congruence generated from <code>f: Π {α : Type} α → α</code>.
- <code>fixed_no_param</code>: It is not a parameter for the congruence lemma, the lemma was specialized for this parameter.
  This only happens if the parameter is a subsingleton/proposition, and other parameters depend on it.
  [TODO] example.
- <code>eq</code>: The lemma contains three parameters for this kind of argument <code>a_i</code>, <code>b_i</code> and <code>(eq_i : a_i = b_i)</code>.
  <code>a_i</code> and <code>b_i</code> represent the left and right hand sides, and <code>eq_i</code> is a proof for their equality.
  For example the second argument in <code>f: Π {α : Type}, α → α</code>. 
- <code>cast</code>: corresponds to arguments that are subsingletons/propositions. 
  For example the <code>p</code> in the congruence generated from <code>f : Π (x y : ℕ) (p: x &lt; y), ℕ</code>.
- <code>heq</code> The lemma contains three parameters for this kind of argument <code>a_i</code>, <code>b_i</code> and <code>(eq_i : a_i == b_i)</code>.
   <code>a_i</code> and <code>b_i</code> represent the left and right hand sides, and eq_i is a proof for their heterogeneous equality.</p>
       </div>
</div><div class="def"><a id="congr_arg_kind.to_string"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/lean/blob/80c1b4d67eec24f1d1e5b4b3ed7082c27851271d/library/init/meta/congr_lemma.lean#L27">congr_arg_kind.to_string</a></span> <span class="decl_args">(a : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/congr_lemma.html#congr_arg_kind">congr_arg_kind</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/data/string/basic.html#string">string</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="congr_arg_kind.has_repr"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/lean/blob/80c1b4d67eec24f1d1e5b4b3ed7082c27851271d/library/init/meta/congr_lemma.lean#L29">congr_arg_kind.has_repr</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/data/repr.html#has_repr">has_repr</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/congr_lemma.html#congr_arg_kind">congr_arg_kind</a></div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="congr_arg_kind.has_to_format"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/lean/blob/80c1b4d67eec24f1d1e5b4b3ed7082c27851271d/library/init/meta/congr_lemma.lean#L30">congr_arg_kind.has_to_format</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/format.html#has_to_format">has_to_format</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/congr_lemma.html#congr_arg_kind">congr_arg_kind</a></div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="cnst"><a id="congr_lemma"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/lean/blob/80c1b4d67eec24f1d1e5b4b3ed7082c27851271d/library/init/meta/congr_lemma.lean#L38">congr_lemma</a></span>  <span class="decl_args">:</span>       <div class="decl_type">Type</div>
<div class="indent"><p>A congruence lemma is a proof that two terms are equal using a congruence proof generated by <code>mk_congr_lemma_simp</code> and friends.
See the docstring for <code>mk_congr_lemma_simp</code> and <code>congr_arg_kind</code> for more information.
The conclusion is prepended by a set of arguments. <code>arg_kinds</code> gives a suggestion of how that argument should be filled in using a simplifier.</p>
       </div>
</div><div class="cnst"><a id="tactic.mk_congr_lemma_simp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/lean/blob/80c1b4d67eec24f1d1e5b4b3ed7082c27851271d/library/init/meta/congr_lemma.lean#L70">tactic.mk_congr_lemma_simp</a></span> <span class="decl_args">(f : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">(nargs : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> ℕ) option.none)</span> <span class="decl_args">(md : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.transparency">tactic.transparency</a> tactic.transparency.semireducible)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/congr_lemma.html#congr_lemma">congr_lemma</a></div>
<div class="indent"><p><code>mk_congr_lemma_simp f nargs md</code>
creates a congruence lemma for the simplifier for the given function argument <code>f</code>.
If <code>nargs</code> is not none, then it tries to create a lemma for an application of arity <code>nargs</code>.
If <code>nargs</code> is none then the number of arguments will be guessed from the type signature of <code>f</code>.</p>

<p>That is, given <code>f : Π {α β γ δ : Type}, α → β → γ → δ</code> and <code>nargs = some 6</code>, we get a congruence lemma:
<code>lean
{ type := ∀ (α β γ δ : Type), ∀ (a₁ a₂ : α), a₁ = a₂ → ∀ (b₁ b₂ : β), b₁ = b₂ → f a₁ b₁ = f a₂ b₂
, proof := ...
, arg_kinds := [fixed, fixed, fixed, fixed, eq,eq]
}
</code>
See the docstrings for the cases of <code>congr_arg_kind</code> for more detail on how <code>arg_kinds</code> are chosen.
It can be difficult to see how the system chooses the <code>arg_kinds</code>, but it depends on what the other arguments depend on and whether the arguments have subsingleton types.</p>

<p>[NOTE] The number of arguments that <code>proof</code> takes can be inferred from <code>arg_kinds</code>: <code>arg_kinds.sum (fixed,cast ↦ 1 | eq,heq ↦ 3 | fixed_no_param ↦ 0)</code>.</p>

<p>From <code>congr_lemma.cpp</code>:</p>

<blockquote>
  <p>Create a congruence lemma that is useful for the simplifier.
  In this kind of lemma, if the i-th argument is a Cast argument, then the lemma
  contains an input a<em>i representing the i-th argument in the left-hand-side, and
  it appears with a cast (e.g., eq.drec ... a</em>i ...) in the right-hand-side.
  The idea is that the right-hand-side of this lemma "tells" the simplifier
  how the resulting term looks like.</p>
</blockquote>
       </div>
</div><div class="cnst"><a id="tactic.mk_specialized_congr_lemma_simp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/lean/blob/80c1b4d67eec24f1d1e5b4b3ed7082c27851271d/library/init/meta/congr_lemma.lean#L73">tactic.mk_specialized_congr_lemma_simp</a></span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">(md : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.transparency">tactic.transparency</a> tactic.transparency.semireducible)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/congr_lemma.html#congr_lemma">congr_lemma</a></div>
<div class="indent"><p>Create a specialized theorem using (a prefix of) the arguments of the given application. [TODO] What does this mean?</p>
       </div>
</div><div class="cnst"><a id="tactic.mk_congr_lemma"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/lean/blob/80c1b4d67eec24f1d1e5b4b3ed7082c27851271d/library/init/meta/congr_lemma.lean#L91">tactic.mk_congr_lemma</a></span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">(nargs : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> ℕ) option.none)</span> <span class="decl_args">(md : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.transparency">tactic.transparency</a> tactic.transparency.semireducible)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/congr_lemma.html#congr_lemma">congr_lemma</a></div>
<div class="indent"><p>Similar to <code>mk_congr_lemma_simp</code>, this will make a <code>congr_lemma</code> object.
   The difference is that for each <code>congr_arg_kind.cast</code> argument, two proof arguments are generated.</p>

<p>Consider some function <code>f : Π (x : ℕ) (p : x &lt; 4), ℕ</code>.
   - <code>mk_congr_simp</code> will produce a congruence lemma with type <code>∀ (x x_1 : ℕ) (e_1 : x = x_1) (p : x &lt; 4), cheese x p = cheese x_1 _</code>.
   - <code>mk_congr</code> will produce a congruence lemma with type <code>∀ (x x_1 : ℕ) (e_1 : x = x_1) (p : x &lt; 4) (p_1 : x_1 &lt; 4), cheese x p = cheese x_1 p_1</code>.</p>

<p>From <code>congr_lemma.cpp</code>:</p>

<blockquote>
  <p>Create a congruence lemma for the congruence closure module.
  In this kind of lemma, if the i-th argument is a Cast argument, then the lemma
  contains two inputs a<em>i and b</em>i representing the i-th argument in the left-hand-side and
  right-hand-side.
  This lemma is based on the congruence lemma for the simplifier.
  It uses subsinglenton elimination to show that the congr-simp lemma right-hand-side
  is equal to the right-hand-side of this lemma.</p>
</blockquote>
       </div>
</div><div class="cnst"><a id="tactic.mk_specialized_congr_lemma"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/lean/blob/80c1b4d67eec24f1d1e5b4b3ed7082c27851271d/library/init/meta/congr_lemma.lean#L93">tactic.mk_specialized_congr_lemma</a></span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">(md : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.transparency">tactic.transparency</a> tactic.transparency.semireducible)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/congr_lemma.html#congr_lemma">congr_lemma</a></div>
<div class="indent"><p>Create a specialized theorem using (a prefix of) the arguments of the given application. [TODO] what does this mean?</p>
       </div>
</div><div class="cnst"><a id="tactic.mk_hcongr_lemma"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/lean/blob/80c1b4d67eec24f1d1e5b4b3ed7082c27851271d/library/init/meta/congr_lemma.lean#L107">tactic.mk_hcongr_lemma</a></span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">(nargs : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> ℕ) option.none)</span> <span class="decl_args">(md : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.transparency">tactic.transparency</a> tactic.transparency.semireducible)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/congr_lemma.html#congr_lemma">congr_lemma</a></div>
<div class="indent"><p>Make a congruence lemma using hetrogeneous equality <code>heq</code> instead of <code>eq</code>.
For example <code>mk_hcongr_lemma (f : Π (α : ℕ → Type) (n:ℕ) (b:α n), ℕ</code> )` will make</p>

<p><code>lean
{ type := ∀ α α', α = α' → ∀ n n', n = n' → ∀ (b : α n) (b' : α' n'), b == b' → f α n b == f α' n' b'
, proof := ...
, arg_kinds := [eq,eq,heq]
}
</code></p>

<p>(Using merely <code>mk_congr_lemma</code> instead will produce <code>[fixed,fixed,eq]</code> instaed.)</p>
       </div>
</div></body></html>