<!DOCTYPE html><html lang="en"><head><title>meta.rb_map</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/meta/index.html">meta</a>/<br><a href="rb_map.html">rb_map</a></div><div class="mod_doc"><h1>rb_map</h1>

<p>This file defines additional operations on native rb_maps and rb_sets.
These structures are defined in core in <code>init.meta.rb_map</code>. They are meta objects,
and are generally the most efficient dictionary structures to use for pure metaprogramming right now.</p>
</div><div class="def"><a id="native.rb_set.filter"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L20">native.rb_set.filter</a></span> <span class="decl_args">{key : Type}</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_set">native.rb_set</a> key)</span> <span class="decl_args">(P : key → <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#bool">bool</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_set">native.rb_set</a> key</div>
<div class="indent"><p><code>filter s P</code> returns the subset of elements of <code>s</code> satisfying <code>P</code>.</p>
       </div>
</div><div class="def"><a id="native.rb_set.mfilter"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L25">native.rb_set.mfilter</a></span> <span class="decl_args">{m : Type → Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/monad.html#monad">monad</a> m]</span> <span class="decl_args">{key : Type}</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_set">native.rb_set</a> key)</span> <span class="decl_args">(P : key → m <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#bool">bool</a>)</span> <span class="decl_args">:</span>       <div class="decl_type">m (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_set">native.rb_set</a> key)</div>
<div class="indent"><p><code>mfilter s P</code> returns the subset of elements of <code>s</code> satisfying <code>P</code>,
where the check <code>P</code> is monadic.</p>
       </div>
</div><div class="def"><a id="native.rb_set.union"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L31">native.rb_set.union</a></span> <span class="decl_args">{key : Type}</span> <span class="decl_args">(s t : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_set">native.rb_set</a> key)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_set">native.rb_set</a> key</div>
<div class="indent"><p><code>union s t</code> returns an rb_set containing every element that appears in either <code>s</code> or <code>t</code>.</p>
       </div>
</div><div class="def"><a id="native.rb_map.find_def"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L40">native.rb_map.find_def</a></span> <span class="decl_args">{key value : Type}</span> <span class="decl_args">(<a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#default">default</a> : value)</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key value)</span> <span class="decl_args">(k : key)</span> <span class="decl_args">:</span>       <div class="decl_type">value</div>
<div class="indent"><p><code>find_def default m k</code> returns the value corresponding to <code>k</code> in <code>m</code>, if it exists.
Otherwise it returns <code>default</code>.</p>
       </div>
</div><div class="def"><a id="native.rb_map.ifind"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L45">native.rb_map.ifind</a></span> <span class="decl_args">{key value : Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#inhabited">inhabited</a> value]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key value)</span> <span class="decl_args">(k : key)</span> <span class="decl_args">:</span>       <div class="decl_type">value</div>
<div class="indent"><p><code>ifind m key</code> returns the value corresponding to <code>key</code> in <code>m</code>, if it exists.
Otherwise it returns the default value of <code>value</code>.</p>
       </div>
</div><div class="def"><a id="native.rb_map.zfind"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L50">native.rb_map.zfind</a></span> <span class="decl_args">{key value : Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#has_zero">has_zero</a> value]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key value)</span> <span class="decl_args">(k : key)</span> <span class="decl_args">:</span>       <div class="decl_type">value</div>
<div class="indent"><p><code>zfind m key</code> returns the value corresponding to <code>key</code> in <code>m</code>, if it exists.
Otherwise it returns 0.</p>
       </div>
</div><div class="def"><a id="native.rb_map.add"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L54">native.rb_map.add</a></span> <span class="decl_args">{key value : Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#has_add">has_add</a> value]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#has_zero">has_zero</a> value]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> value]</span> <span class="decl_args">(m1 m2 : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key value)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key value</div>
<div class="indent"><p>Returns the pointwise sum of <code>m1</code> and <code>m2</code>, treating nonexistent values as 0.</p>
       </div>
</div><div class="def"><a id="native.rb_map.mfilter"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L65">native.rb_map.mfilter</a></span> <span class="decl_args">{m : Type → Type u_1}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/monad.html#monad">monad</a> m]</span> <span class="decl_args">{key val : Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#has_lt">has_lt</a> key]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_rel">decidable_rel</a> has_lt.lt]</span> <span class="decl_args">(P : key → val → m <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#bool">bool</a>)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key val)</span> <span class="decl_args">:</span>       <div class="decl_type">m (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key val)</div>
<div class="indent"><p><code>mfilter P s</code> filters <code>s</code> by the monadic predicate <code>P</code> on keys and values.</p>
       </div>
</div><div class="def"><a id="native.rb_map.mmap"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L70">native.rb_map.mmap</a></span> <span class="decl_args">{m : Type → Type u_1}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/monad.html#monad">monad</a> m]</span> <span class="decl_args">{key val val' : Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#has_lt">has_lt</a> key]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_rel">decidable_rel</a> has_lt.lt]</span> <span class="decl_args">(f : val → m val')</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key val)</span> <span class="decl_args">:</span>       <div class="decl_type">m (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key val')</div>
<div class="indent"><p><code>mmap f s</code> maps the monadic function <code>f</code> over values in <code>s</code>.</p>
       </div>
</div><div class="def"><a id="native.rb_map.scale"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L75">native.rb_map.scale</a></span> <span class="decl_args">{key value : Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#has_lt">has_lt</a> key]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_rel">decidable_rel</a> has_lt.lt]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#has_mul">has_mul</a> value]</span> <span class="decl_args">(b : value)</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key value)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key value</div>
<div class="indent"><p><code>scale b m</code> multiplies every value in <code>m</code> by <code>b</code>.</p>
       </div>
</div><div class="def"><a id="native.rb_map.has_to_tactic_format"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L86">native.rb_map.has_to_tactic_format</a></span> <span class="decl_args">{key data : Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#has_to_tactic_format">has_to_tactic_format</a> key]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#has_to_tactic_format">has_to_tactic_format</a> data]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#has_to_tactic_format">has_to_tactic_format</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_map">native.rb_map</a> key data)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="native.rb_lmap.of_list"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L98">native.rb_lmap.of_list</a></span> <span class="decl_args">{key data : Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#has_lt">has_lt</a> key]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_rel">decidable_rel</a> has_lt.lt]</span> <span class="decl_args">(a : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (key × data))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#native.rb_lmap">native.rb_lmap</a> key data</div>
<div class="indent"><p>Construct a rb_lmap from a list of key-data pairs</p>
       </div>
</div><div class="def"><a id="name_set.filter"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L109">name_set.filter</a></span> <span class="decl_args">(P : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> → <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#bool">bool</a>)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_set">name_set</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_set">name_set</a></div>
<div class="indent"><p><code>filter P s</code> returns the subset of elements of <code>s</code> satisfying <code>P</code>.</p>
       </div>
</div><div class="def"><a id="name_set.mfilter"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L114">name_set.mfilter</a></span> <span class="decl_args">{m : Type → Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/monad.html#monad">monad</a> m]</span> <span class="decl_args">(P : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> → m <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#bool">bool</a>)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_set">name_set</a>)</span> <span class="decl_args">:</span>       <div class="decl_type">m <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_set">name_set</a></div>
<div class="indent"><p><code>mfilter P s</code> returns the subset of elements of <code>s</code> satisfying <code>P</code>,
where the check <code>P</code> is monadic.</p>
       </div>
</div><div class="def"><a id="name_set.mmap"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L120">name_set.mmap</a></span> <span class="decl_args">{m : Type → Type}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/monad.html#monad">monad</a> m]</span> <span class="decl_args">(f : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> → m <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_set">name_set</a>)</span> <span class="decl_args">:</span>       <div class="decl_type">m <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_set">name_set</a></div>
<div class="indent"><p><code>mmap f s</code> maps the monadic function <code>f</code> over values in <code>s</code>.</p>
       </div>
</div><div class="def"><a id="name_set.union"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L127">name_set.union</a></span> <span class="decl_args">(s t : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_set">name_set</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_set">name_set</a></div>
<div class="indent"><p><code>union s t</code> returns an rb_set containing every element that appears in either <code>s</code> or <code>t</code>.</p>
       </div>
</div><div class="def"><a id="name_set.insert_list"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/meta/rb_map.lean#L131">name_set.insert_list</a></span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_set">name_set</a>)</span> <span class="decl_args">(l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_set">name_set</a></div>
<div class="indent"><p><code>insert_list s l</code> inserts every element of <code>l</code> into <code>s</code>.</p>
       </div>
</div></body></html>