<!DOCTYPE html><html lang="en"><head><title>tactic.lift</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/tactic/index.html">tactic</a>/<br><a href="lift.html">lift</a>      <br><br><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/tactic/lift.lean">View file source</a></div><div class="mod_doc"><h1>lift tactic</h1>

<p>This file defines the lift tactic, allowing the user to lift elements from one type to another
under a specified condition.</p>

<h2>Tags</h2>

<p>lift, tactic</p>
</div><div class="structure"><a id="can_lift"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/tactic/lift.lean#L22">can_lift</a></span> <span class="decl_args">(α : Type u)</span> <span class="decl_args">(β : Type v)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p>A class specifying that you can lift elements from <code>α</code> to <code>β</code> assuming <code>cond</code> is true.
 Used by the tactic <code>lift</code>.</p>
       <div class="structure_fields">
Fields:
<div class="structure_field">can_lift.coe : β → α</div>
<div class="structure_field">can_lift.cond : α → Prop</div>
<div class="structure_field">can_lift.prf : ∀ (x : α), can_lift.cond β x → (∃ (y : β), can_lift.coe α y = x)</div>
</div>

</div>
</div><div class="def"><a id="can_lift_attr"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/tactic/lift.lean#L30">can_lift_attr</a></span>  <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/core/init/meta/attribute.html#user_attribute">user_attribute</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>))</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="nat.can_lift"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/tactic/lift.lean#L40">nat.can_lift</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/tactic/lift.html#can_lift">can_lift</a> ℤ ℕ</div>
<div class="indent"><p></p>
       

Attributes: instance</div>
</div><div class="def"><a id="tactic.get_lift_prf"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/tactic/lift.lean#L54">tactic.get_lift_prf</a></span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/pexpr.html#pexpr">pexpr</a>)</span> <span class="decl_args">(old_tp new_tp inst e : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/simp_tactic.html#simp_lemmas">simp_lemmas</a>)</span> <span class="decl_args">(to_unfold : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a></div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="tactic.lift"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/tactic/lift.lean#L71">tactic.lift</a></span> <span class="decl_args">(p t : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/pexpr.html#pexpr">pexpr</a>)</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/pexpr.html#pexpr">pexpr</a>)</span> <span class="decl_args">(n : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Lift the expression <code>p</code> to the type <code>t</code>, with proof obligation given by <code>h</code>.
 The list <code>n</code> is used for the two newly generated names, and to specify whether <code>h</code> should
 remain in the local context. See the doc string of <code>tactic.interactive.lift</code> for more information.</p>
       

</div>
</div><div class="def"><a id="tactic.using_texpr"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/tactic/lift.lean#L116">tactic.using_texpr</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser">lean.parser</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/pexpr.html#pexpr">pexpr</a>)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="tactic.to_texpr"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/tactic/lift.lean#L118">tactic.to_texpr</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser">lean.parser</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/pexpr.html#pexpr">pexpr</a></div>
<div class="indent"><p></p>
       

</div>
</div><div class="def"><a id="tactic.interactive.lift"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/tactic/lift.lean#L141">tactic.interactive.lift</a></span> <span class="decl_args">(p : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.types.texpr">interactive.types.texpr</a>)</span> <span class="decl_args">(t : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/tactic/lift.html#tactic.to_texpr">tactic.to_texpr</a>)</span> <span class="decl_args">(h : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/tactic/lift.html#tactic.using_texpr">tactic.using_texpr</a>)</span> <span class="decl_args">(n : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.types.with_ident_list">interactive.types.with_ident_list</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Lift an expression to another type.
 * Usage: <code>'lift' expr 'to' expr ('using' expr)? ('with' id (id id?)?)?</code>.
 * If <code>n : ℤ</code> and <code>hn : n ≥ 0</code> then the tactic <code>lift n to ℕ using hn</code> creates a new
   constant of type ℕ, also named <code>n</code> and replaces all occurrences of the old variable <code>(n : ℤ)</code>
   with <code>↑n</code> (where <code>n</code> in the new variable). It will remove <code>n</code> and <code>hn</code> from the context.
 * The argument <code>using hn</code> is optional, the tactic <code>lift n to ℕ</code> does the same, but also creates a
   new subgoal that <code>n ≥ 0</code> (where <code>n</code> is the old variable).
 * You can also use <code>lift n to ℕ using e</code> where <code>e</code> is any expression of type <code>n ≥ 0</code>.
 * Use <code>lift n to ℕ with k</code> to specify the name of the new variable.
 * Use <code>lift n to ℕ with k hk</code> to also specify the name of the equality <code>↑k = n</code>. In this case, <code>n</code>
   will remain in the context. You can use <code>rfl</code> for the name of <code>hk</code> to substitute it away.
 * You can also use <code>lift e to ℕ with k hk</code> where <code>e</code> is any expression of type <code>ℤ</code>.
   In this case, the <code>hk</code> will always stay in the context, but it will be used to rewrite <code>e</code> in
   all hypotheses and the target.
 * The tactic <code>lift n to ℕ using h</code> will remove <code>h</code> from the context. If you want to keep it,
   specify it again as the third argument to <code>with</code>, like this: <code>lift n to ℕ using h with n rfl h</code>.
 * More generally, this can lift an expression from <code>α</code> to <code>β</code> assuming that there is an instance
   of <code>can_lift α β</code>. In this case the proof obligation is specified by <code>can_lift.cond</code>.</p>
       

</div>
</div></body></html>