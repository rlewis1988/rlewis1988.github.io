<html><head><title>tactic.lift</title><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><h1>lift tactic</h1>

<p>This file defines the lift tactic, allowing the user to lift elements from one type to another
under a specified condition.</p>

<h2>Tags</h2>

<p>lift, tactic</p>
</div><div class="entry"><a id="can_lift">      <h4>can_lift</h4><code>Type u → Type v → Type (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/algebra/functions.html#max">max</a> u v)</code>
<div class="indent"><p><p>A class specifying that you can lift elements from <code>α</code> to <code>β</code> assuming <code>cond</code> is true.
 Used by the tactic <code>lift</code>.</p>
</p>       </div>
</div><div class="entry"><a id="can_lift_attr">      <h4>can_lift_attr</h4><code>(<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/attribute.html#user_attribute">user_attribute</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#list">list</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/name.html#name">name</a>))</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="nat.can_lift">      <h4>nat.can_lift</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/tactic/lift.html#can_lift">can_lift</a> ℤ ℕ</code>
<div class="indent"><p><p></p>
</p>       Attributes: instance</div>
</div><div class="entry"><a id="tactic.get_lift_prf">      <h4>tactic.get_lift_prf</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#option">option</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/pexpr.html#pexpr">pexpr</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/simp_tactic.html#simp_lemmas">simp_lemmas</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#list">list</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/name.html#name">name</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a></code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="tactic.lift">      <h4>tactic.lift</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/pexpr.html#pexpr">pexpr</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/pexpr.html#pexpr">pexpr</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#option">option</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/pexpr.html#pexpr">pexpr</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#list">list</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/name.html#name">name</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a></code>
<div class="indent"><p><p>Lift the expression <code>p</code> to the type <code>t</code>, with proof obligation given by <code>h</code>.
 The list <code>n</code> is used for the two newly generated names, and to specify whether <code>h</code> should
 remain in the local context. See the doc string of <code>tactic.interactive.lift</code> for more information.</p>
</p>       </div>
</div><div class="entry"><a id="tactic.using_texpr">      <h4>tactic.using_texpr</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/lean/parser.html#lean.parser">lean.parser</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#option">option</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/pexpr.html#pexpr">pexpr</a>)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="tactic.to_texpr">      <h4>tactic.to_texpr</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/lean/parser.html#lean.parser">lean.parser</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/pexpr.html#pexpr">pexpr</a></code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="tactic.interactive.lift">      <h4>tactic.interactive.lift</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.types.texpr">interactive.types.texpr</a> →
<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="/home/rob/lean/mathlib/scripts/html_out/tactic/lift.html#tactic.to_texpr">tactic.to_texpr</a> →
<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="/home/rob/lean/mathlib/scripts/html_out/tactic/lift.html#tactic.using_texpr">tactic.using_texpr</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.types.with_ident_list">interactive.types.with_ident_list</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a></code>
<div class="indent"><p><p>Lift an expression to another type.
 * Usage: <code>'lift' expr 'to' expr ('using' expr)? ('with' id (id id?)?)?</code>.
 * If <code>n : ℤ</code> and <code>hn : n ≥ 0</code> then the tactic <code>lift n to ℕ using hn</code> creates a new
   constant of type ℕ, also named <code>n</code> and replaces all occurrences of the old variable <code>(n : ℤ)</code>
   with <code>↑n</code> (where <code>n</code> in the new variable). It will remove <code>n</code> and <code>hn</code> from the context.
 * The argument <code>using hn</code> is optional, the tactic <code>lift n to ℕ</code> does the same, but also creates a
   new subgoal that <code>n ≥ 0</code> (where <code>n</code> is the old variable).
 * You can also use <code>lift n to ℕ using e</code> where <code>e</code> is any expression of type <code>n ≥ 0</code>.
 * Use <code>lift n to ℕ with k</code> to specify the name of the new variable.
 * Use <code>lift n to ℕ with k hk</code> to also specify the name of the equality <code>↑k = n</code>. In this case, <code>n</code>
   will remain in the context. You can use <code>rfl</code> for the name of <code>hk</code> to substitute it away.
 * You can also use <code>lift e to ℕ with k hk</code> where <code>e</code> is any expression of type <code>ℤ</code>.
   In this case, the <code>hk</code> will always stay in the context, but it will be used to rewrite <code>e</code> in
   all hypotheses and the target.
 * The tactic <code>lift n to ℕ using h</code> will remove <code>h</code> from the context. If you want to keep it,
   specify it again as the third argument to <code>with</code>, like this: <code>lift n to ℕ using h with n rfl h</code>.
 * More generally, this can lift an expression from <code>α</code> to <code>β</code> assuming that there is an instance
   of <code>can_lift α β</code>. In this case the proof obligation is specified by <code>can_lift.cond</code>.</p>
</p>       </div>
</div></body></html>