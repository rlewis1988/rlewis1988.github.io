<!DOCTYPE html><html lang="en"><head><title>tactic.apply</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/tactic/index.html">tactic</a>/<br><a href="apply.html">apply</a></div><div class="mod_doc"><p>This file provides an alternative implementation for <code>apply</code> to fix the so-called "apply bug".</p>

<p>The issue arises when the goals is a Π-type -- whether it is visible or hidden behind a definition.</p>

<p>For instance, consider the following proof:</p>

<p><code>
example {α β} (x y z : α → β) (h₀ : x ≤ y) (h₁ : y ≤ z) : x ≤ z :=
begin
  apply le_trans,
end
</code></p>

<p>Because <code>x ≤ z</code> is definitionally equal to <code>∀ i, x i ≤ z i</code>, <code>apply</code> will fail. The alternative definition,
<code>apply'</code> fixes this. When <code>apply</code> would work, <code>apply</code> is used and otherwise, a different strategy is deployed</p>
</div><div class="def"><a id="tactic.reorder_goals"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L31">tactic.reorder_goals</a></span> <span class="decl_args">{α : Type u_1}</span> <span class="decl_args">(gs : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#bool">bool</a> × α))</span> <span class="decl_args">(a : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.new_goals">tactic.new_goals</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> α</div>
<div class="indent"><p>With <code>gs</code> a list of proof goals, <code>reorder_goals gs new_g</code> will use the <code>new_goals</code> policy <code>new_g</code> to rearrange the
   dependent goals to either drop them, push them to the end of the list or leave them in place. The <code>bool</code> values in
   <code>gs</code> indicates whether the goal is dependent or not.</p>
       </div>
</div><div class="def"><a id="tactic.apply'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L78">tactic.apply'</a></span> <span class="decl_args">(e : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">(cfg : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.apply_cfg">tactic.apply_cfg</a>
  {md := tactic.transparency.semireducible,
   approx := bool.tt,
   new_goals := tactic.new_goals.non_dep_first,
   instances := bool.tt,
   <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#auto_param">auto_param</a> := bool.tt,
   <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> := bool.tt,
   unify := bool.tt})</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>))</div>
<div class="indent"><p><code>apply'</code> mimics the behavior of <code>apply_core</code>. When
<code>apply_core</code> fails, it is retried by providing the term with meta
variables as additional arguments. The meta variables can then
become new goals depending on the <code>cfg.new_goals</code> policy.</p>

<p><code>apply'</code> also finds instances and applies opt_params and auto_params.</p>
       </div>
</div><div class="def"><a id="tactic.fapply'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L84">tactic.fapply'</a></span> <span class="decl_args">(e : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>))</div>
<div class="indent"><p>Same as <code>apply'</code> but __all__ arguments that weren't inferred are added to goal list.</p>
       </div>
</div><div class="def"><a id="tactic.eapply'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L87">tactic.eapply'</a></span> <span class="decl_args">(e : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>))</div>
<div class="indent"><p>Same as <code>apply'</code> but only goals that don't depend on other goals are added to goal list.</p>
       </div>
</div><div class="def"><a id="tactic.reflexivity'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L103">tactic.reflexivity'</a></span> <span class="decl_args">(md : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.transparency">tactic.transparency</a> tactic.transparency.semireducible)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Similar to <code>reflexivity</code> with the difference that <code>apply'</code> is used instead of <code>apply</code></p>
       </div>
</div><div class="def"><a id="tactic.symmetry'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L107">tactic.symmetry'</a></span> <span class="decl_args">(md : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.transparency">tactic.transparency</a> tactic.transparency.semireducible)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Similar to <code>symmetry</code> with the difference that <code>apply'</code> is used instead of <code>apply</code></p>
       </div>
</div><div class="def"><a id="tactic.transitivity'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L111">tactic.transitivity'</a></span> <span class="decl_args">(md : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.transparency">tactic.transparency</a> tactic.transparency.semireducible)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Similar to <code>transitivity</code> with the difference that <code>apply'</code> is used instead of <code>apply</code></p>
       </div>
</div><div class="def"><a id="tactic.interactive.apply'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L123">tactic.interactive.apply'</a></span> <span class="decl_args">(q : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.types.texpr">interactive.types.texpr</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Similarly to <code>apply</code>, the <code>apply'</code> tactic tries to match the current goal against the conclusion of the type of term.</p>

<p>It differs from <code>apply</code> in that it does not unfold definition in order to find out what the assumptions of the provided term is. It is especially useful when defining relations on function spaces (e.g. <code>≤</code>) so that rules like transitivity on <code>le : (α → β) → (α → β) → (α → β)</code> will be considered to have three parameters and two assumptions (i.e. <code>f g h : α → β</code>, <code>H₀ : f ≤ g</code>, <code>H₁ : g ≤ h</code>) instead of three parameters, two assumptions and then one more parameter (i.e. <code>f g h : α → β</code>, <code>H₀ : f ≤ g</code>, <code>H₁ : g ≤ h</code>, <code>x : α</code>). Whereas <code>apply</code> would expect the goal <code>f x ≤ h x</code>, <code>apply'</code> will work with the goal <code>f ≤ h</code>.</p>
       </div>
</div><div class="def"><a id="tactic.interactive.fapply'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L129">tactic.interactive.fapply'</a></span> <span class="decl_args">(q : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.types.texpr">interactive.types.texpr</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Similar to the <code>apply'</code> tactic, but does not reorder goals.</p>
       </div>
</div><div class="def"><a id="tactic.interactive.eapply'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L135">tactic.interactive.eapply'</a></span> <span class="decl_args">(q : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.types.texpr">interactive.types.texpr</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Similar to the <code>apply'</code> tactic, but only creates subgoals for non-dependent premises that have not been fixed by type inference or type class resolution.</p>
       </div>
</div><div class="def"><a id="tactic.interactive.apply_with'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L141">tactic.interactive.apply_with'</a></span> <span class="decl_args">(q : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser.pexpr">lean.parser.pexpr</a>)</span> <span class="decl_args">(cfg : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.apply_cfg">tactic.apply_cfg</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Similar to the <code>apply'</code> tactic, but allows the user to provide a <code>apply_cfg</code> configuration object.</p>
       </div>
</div><div class="def"><a id="tactic.interactive.mapply'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L148">tactic.interactive.mapply'</a></span> <span class="decl_args">(q : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.types.texpr">interactive.types.texpr</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Similar to the <code>apply'</code> tactic, but uses matching instead of unification.
<code>mapply' t</code> is equivalent to <code>apply_with' t {unify := ff}</code></p>
       </div>
</div><div class="def"><a id="tactic.interactive.reflexivity'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L155">tactic.interactive.reflexivity'</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Similar to <code>reflexivity</code> with the difference that <code>apply'</code> is used instead of <code>apply</code>.</p>
       </div>
</div><div class="def"><a id="tactic.interactive.refl'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L161">tactic.interactive.refl'</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Shorter name for the tactic <code>reflexivity'</code>.</p>
       </div>
</div><div class="def"><a id="tactic.interactive.symmetry'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L167">tactic.interactive.symmetry'</a></span> <span class="decl_args">(a : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.types.location">interactive.types.location</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p><code>symmetry'</code> behaves like <code>symmetry</code> but also offers the option <code>symmetry' at h</code> to apply symmetry to assumption <code>h</code></p>
       </div>
</div><div class="def"><a id="tactic.interactive.transitivity'"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/tactic/apply.lean#L174">tactic.interactive.transitivity'</a></span> <span class="decl_args">(q : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/category/alternative.html#optional">optional</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.types.texpr">interactive.types.texpr</a>))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>Similar to <code>transitivity</code> with the difference that <code>apply'</code> is used instead of <code>apply</code>.</p>
       </div>
</div></body></html>