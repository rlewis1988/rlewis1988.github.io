<html><head><title>tactic.solve_by_elim</title><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><p></p>
</div><div class="entry"><a id="tactic.mk_assumption_set">      <h4>tactic.mk_assumption_set</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#bool">bool</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#list">list</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive.html#tactic.simp_arg_type">tactic.simp_arg_type</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#list">list</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/name.html#name">name</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#list">list</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a>)</code>
<div class="indent"><p><p>Builds a collection of lemmas for use in the backtracking search in <code>solve_by_elim</code>.</p>

<ul>
<li>By default, it includes all local hypotheses, along with <code>rfl</code>, <code>trivial</code>, <code>congr_fun</code> and <code>congr_arg</code>.</li>
<li>The flag <code>no_dflt</code> removes these.</li>
<li>The argument <code>hs</code> is a list of <code>simp_arg_type</code>s,
and can be used to add, or remove, lemmas or expressions from the set.</li>
<li>The argument <code>attr : list name</code> adds all lemmas tagged with one of a specified list of attributes.</li>
</ul>
</p>       </div>
</div><div class="entry"><a id="tactic.solve_by_elim_aux">      <h4>tactic.solve_by_elim_aux</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#list">list</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a>) → ℕ → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a></code>
<div class="indent"><p><p>The internal implementation of <code>solve_by_elim</code>, with a limiting counter.</p>
</p>       </div>
</div><div class="entry"><a id="tactic.by_elim_opt">      <h4>tactic.by_elim_opt</h4><code>Type</code>
<div class="indent"><p><p>Configuration options for <code>solve_by_elim</code>.</p>

<ul>
<li>By default <code>solve_by_elim</code> operates only on the first goal,
but with <code>backtrack_all_goals := true</code>, it operates on all goals at once,
backtracking across goals as needed,
and only succeeds if it dischargers all goals.</li>
<li><code>discharger</code> specifies a tactic to try discharge subgoals
(this is only attempted on subgoals for which no lemma applies successfully).</li>
<li><code>assumptions</code> generates the list of lemmas to use in the backtracking search.</li>
<li><code>max_rep</code> bounds the depth of the search.</li>
</ul>
</p>       </div>
</div><div class="entry"><a id="tactic.solve_by_elim">      <h4>tactic.solve_by_elim</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#opt_param">opt_param</a> <a href="/home/rob/lean/mathlib/scripts/html_out/tactic/solve_by_elim.html#tactic.by_elim_opt">tactic.by_elim_opt</a>
  {backtrack_all_goals := bool.ff,
   discharger := tactic.done,
   assumptions := <a href="/home/rob/lean/mathlib/scripts/html_out/tactic/solve_by_elim.html#tactic.mk_assumption_set">tactic.mk_assumption_set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#decidable.to_bool">decidable.to_bool</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#false">false</a>) list.nil list.nil,
   max_rep := 3} →
<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a></code>
<div class="indent"><p><p><code>solve_by_elim</code> repeatedly tries <code>apply</code>ing a lemma
from the list of assumptions (passed via the <code>by_elim_opt</code> argument),
recursively operating on any generated subgoals.
It succeeds only if it discharges the first goal
(or with <code>backtrack_all_goals := tt</code>, if it discharges all goals.)</p>
</p>       </div>
</div><div class="entry"><a id="tactic.interactive.apply_assumption">      <h4>tactic.interactive.apply_assumption</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#opt_param">opt_param</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#list">list</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a>)) <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic.local_context">tactic.local_context</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#opt_param">opt_param</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a>) (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/monad.html#return">return</a> ()) → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a></code>
<div class="indent"><p><p><code>apply_assumption</code> looks for an assumption of the form <code>... → ∀ _, ... → head</code>
where <code>head</code> matches the current goal.</p>

<p>alternatively, when encountering an assumption of the form <code>sg₀ → ¬ sg₁</code>,
after the main approach failed, the goal is dismissed and <code>sg₀</code> and <code>sg₁</code>
are made into the new goal.</p>

<p>optional arguments:
- asms: list of rules to consider instead of the local constants
- tac:  a tactic to run on each subgoals after applying an assumption; if
        this tactic fails, the corresponding assumption will be rejected and
        the next one will be attempted.</p>
</p>       </div>
</div><div class="entry"><a id="tactic.interactive.solve_by_elim">      <h4>tactic.interactive.solve_by_elim</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/alternative.html#optional">optional</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/lean/parser.html#lean.parser.tk">lean.parser.tk</a> \"*\")) →
<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.types.only_flag">interactive.types.only_flag</a> →
<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive.html#tactic.simp_arg_list">tactic.simp_arg_list</a> →
<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.types.with_ident_list">interactive.types.with_ident_list</a> →
<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#opt_param">opt_param</a> <a href="/home/rob/lean/mathlib/scripts/html_out/tactic/solve_by_elim.html#tactic.by_elim_opt">tactic.by_elim_opt</a>
  {backtrack_all_goals := bool.ff,
   discharger := tactic.done,
   assumptions := <a href="/home/rob/lean/mathlib/scripts/html_out/tactic/solve_by_elim.html#tactic.mk_assumption_set">tactic.mk_assumption_set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#decidable.to_bool">decidable.to_bool</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#false">false</a>) list.nil list.nil,
   max_rep := 3} →
<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a></code>
<div class="indent"><p><p><code>solve_by_elim</code> calls <code>apply</code> on the main goal to find an assumption whose head matches
and then repeatedly calls <code>apply</code> on the generated subgoals until no subgoals remain,
performing at most <code>max_rep</code> recursive steps.</p>

<p><code>solve_by_elim</code> discharges the current goal or fails.</p>

<p><code>solve_by_elim</code> performs back-tracking if <code>apply_assumption</code> chooses an unproductive assumption.</p>

<p>By default, the assumptions passed to apply_assumption are the local context, <code>rfl</code>, <code>trivial</code>, <code>congr_fun</code> and
<code>congr_arg</code>.</p>

<p><code>solve_by_elim [h₁, h₂, ..., hᵣ]</code> also applies the named lemmas.</p>

<p>`solve<em>by</em>elim with attr₁ ... attrᵣ also applied all lemmas tagged with the specified attributes.</p>

<p><code>solve_by_elim only [h₁, h₂, ..., hᵣ]</code> does not include the local context, <code>rfl</code>, <code>trivial</code>, <code>congr_fun</code>, or <code>congr_arg</code>
unless they are explicitly included.</p>

<p><code>solve_by_elim [-id]</code> removes a specified assumption.</p>

<p><code>solve_by_elim*</code> tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.</p>

<p>optional arguments:
- discharger: a subsidiary tactic to try at each step (e.g. <code>cc</code> may be helpful)
- max_rep: number of attempts at discharging generated sub-goals</p>
</p>       </div>
</div></body></html>