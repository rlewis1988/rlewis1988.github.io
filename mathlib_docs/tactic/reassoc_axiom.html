<!DOCTYPE html><html lang="en"><head><title>tactic.reassoc_axiom</title><meta charset="UTF-8"><link rel="stylesheet" href="/home/rob/lean/mathlib/scripts/html_out/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="/home/rob/lean/mathlib/scripts/html_out/index.html">root</a>/<br><a href="/home/rob/lean/mathlib/scripts/html_out/tactic/index.html">tactic</a>/<br><a href="reassoc_axiom.html">reassoc_axiom</a></div><div class="mod_doc"><p>Reformulate category-theoretic axioms in a more associativity-friendly way.</p>

<h2>The <code>reassoc</code> attribute</h2>

<p>The <code>reassoc</code> attribute can be applied to a lemma</p>

<p><code>lean
@[reassoc]
lemma some_lemma : foo ≫ bar = baz := ...
</code></p>

<p>and produce</p>

<p><code>lean
lemma some_lemma_assoc {Y : C} (f : X ⟶ Y) : foo ≫ bar ≫ f = baz ≫ f := ...
</code></p>

<p>The name of the produced lemma can be specified with <code>@[reassoc other_lemma_name]</code>. If
<code>simp</code> is added first, the generated lemma will also have the <code>simp</code> attribute.</p>

<h2>The <code>reassoc_axiom</code> command</h2>

<p>When declaring a class of categories, the axioms can be reformulated to be more amenable
to manipulation in right associated expressions:</p>

<p>```
class some_class (C : Type) [category C] :=
(foo : Π X : C, X ⟶ X)
(bar : ∀ {X Y : C} (f : X ⟶ Y), foo X ≫ f = f ≫ foo Y)</p>

<p>reassoc_axiom some_class.bar
```</p>

<p>Here too, the <code>reassoc</code> attribute can be used instead. It works well when combined with
<code>simp</code>:</p>

<p><code>
attribute [simp, reassoc] some_class.bar
</code></p>
</div><div class="def"><a id="tactic.get_cat_inst"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/tactic/reassoc_axiom.lean#L55">tactic.get_cat_inst</a></span> <span class="decl_args">(a : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a></div>
<div class="indent"><p>From an expression <code>f ≫ g</code>, extract the expression representing the category instance.</p>
       </div>
</div><div class="def"><a id="tactic.prove_reassoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/tactic/reassoc_axiom.lean#L63">tactic.prove_reassoc</a></span> <span class="decl_args">(h : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a> × <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/expr.html#expr">expr</a>)</div>
<div class="indent"><p>(internals for <code>@[reassoc]</code>)
Given a lemma of the form <code>f ≫ g = h</code>, proves a new lemma of the form <code>h : ∀ {W} (k), f ≫ (g ≫ k) = h ≫ k</code>,
and returns the type and proof of this lemma.</p>
       </div>
</div><div class="def"><a id="tactic.reassoc_axiom"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/tactic/reassoc_axiom.lean#L92">tactic.reassoc_axiom</a></span> <span class="decl_args">(n : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/name.html#name">name</a>)</span> <span class="decl_args">(n' : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#opt_param">opt_param</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/name.html#name">name</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/meta/expr.html#name.append_suffix">name.append_suffix</a> n "_assoc"))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a></div>
<div class="indent"><p>(implementation for <code>@[reassoc]</code>)
Given a declaration named <code>n</code> of the form <code>f ≫ g = h</code>, proves a new lemma named <code>n'</code> of the form <code>∀ {W} (k), f ≫ (g ≫ k) = h ≫ k</code>.</p>
       </div>
</div><div class="def"><a id="tactic.reassoc_attr"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/tactic/reassoc_axiom.lean#L115">tactic.reassoc_attr</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/attribute.html#user_attribute">user_attribute</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#option">option</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/name.html#name">name</a>)</div>
<div class="indent"><p>On the following lemma:
<code>lean
@[reassoc]
lemma foo_bar : foo ≫ bar = foo := ...
</code>
generates</p>

<p><code>lean
lemma foo_bar_assoc {Z} {x : Y ⟶ Z} : foo ≫ bar ≫ x = foo ≫ x := ...
</code></p>

<p>The name of <code>foo_bar_assoc</code> can also be selected with @[reassoc new_name]</p>
       </div>
</div><div class="def"><a id="tactic.reassoc_cmd"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/tactic/reassoc_axiom.lean#L132">tactic.reassoc_cmd</a></span> <span class="decl_args">(_x : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/lean/parser.html#lean.parser.tk">lean.parser.tk</a> "reassoc_axiom"))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/lean/parser.html#lean.parser">lean.parser</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a></div>
<div class="indent"><p><code>lean
reassoc_axiom my_axiom
</code></p>

<p>produces the lemma <code>my_axiom_assoc</code> which transforms a statement of the
form <code>x ≫ y = z</code> into <code>x ≫ y ≫ k = z ≫ k</code>.</p>
       </div>
</div><div class="def"><a id="tactic.interactive.reassoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/tactic/reassoc_axiom.lean#L146">tactic.interactive.reassoc</a></span> <span class="decl_args">(del : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/alternative.html#optional">optional</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/lean/parser.html#lean.parser.tk">lean.parser.tk</a> "!")))</span> <span class="decl_args">(ns : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/lean/parser.html#lean.parser.many">lean.parser.many</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/lean/parser.html#lean.parser.ident">lean.parser.ident</a>))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a></div>
<div class="indent"><p><code>reassoc h</code>, for assumption <code>h : x ≫ y = z</code>, creates a new assumption <code>h : ∀ {W} (f : Z ⟶ W), x ≫ y ≫ f = z ≫ f</code>.
    <code>reassoc! h</code>, does the same but deletes the initial <code>h</code> assumption.
(You can also add the attribute <code>@[reassoc]</code> to lemmas to generate new declarations generalized in this way.)</p>
       </div>
</div><div class="def"><a id="tactic.calculated_Prop"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/tactic/reassoc_axiom.lean#L155">tactic.calculated_Prop</a></span> <span class="decl_args">{α : Sort u_1}</span> <span class="decl_args">(β : Prop)</span> <span class="decl_args">(hh : α)</span> <span class="decl_args">:</span>       <div class="decl_type">Prop</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="tactic.derive_reassoc_proof"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/tactic/reassoc_axiom.lean#L157">tactic.derive_reassoc_proof</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/tactic.html#tactic">tactic</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#unit">unit</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.reassoc_of"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/dfd25ff4fe93bbe6e376dd2d27f7ef7ee7c8b3f9/src/tactic/reassoc_axiom.lean#L182">category_theory.reassoc_of</a></span> <span class="decl_args">{α : Sort u_1}</span> <span class="decl_args">(hh : α)</span> <span class="decl_args">{β : Prop}</span> <span class="decl_args">(x : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/meta/name.html#auto_param">auto_param</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/tactic/reassoc_axiom.html#tactic.calculated_Prop">tactic.calculated_Prop</a> β hh)
  (name.mk_string "derive_reassoc_proof" (name.mk_string "tactic" name.anonymous)))</span> <span class="decl_args">:</span>       <div class="decl_type">β</div>
<div class="indent"><p>With <code>h : x ≫ y ≫ z = x</code> (with universal quantifiers tolerated),
   <code>reassoc_of h : ∀ {X'} (f : W ⟶ X'), x ≫ y ≫ z ≫ f = x ≫ f</code>.</p>

<p>The type and proof of <code>reassoc_of h</code> is generated by <code>tactic.derive_reassoc_proof</code>
   which make <code>reassoc_of</code> meta-programming adjacent. It is not called as a tactic but as
   an expression. The goal is to avoid creating assumptions to dismiss after one use:</p>

<p><code>lean
   example (X Y Z W : C) (x : X ⟶ Y) (y : Y ⟶ Z) (z z' : Z ⟶ W) (w : X ⟶ Z)
     (h : x ≫ y = w)
     (h' : y ≫ z = y ≫ z') :
     x ≫ y ≫ z = w ≫ z' :=
   begin
     rw [h',reassoc_of h],
   end
</code></p>
       </div>
</div></body></html>