<!DOCTYPE html><html lang="en"><head><title>tactic.ext</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><p></p>
</div><div class="def"><a id="derive_struct_ext_lemma"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L34">derive_struct_ext_lemma</a></span> <span class="decl_args">(n : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a></div>
<div class="indent"><p><code>derive_struct_ext_lemma n</code> generates an extensionality lemma based on
the equality of all non-propositional projections.</p>

<p>On the following:</p>

<p><code>lean
@[ext]
structure foo (α : Type*) :=
(x y : ℕ)
(z : {z // z &lt; x})
(k : α)
(h : x &lt; y)
</code></p>

<p><code>derive_struct_lemma</code> generates:</p>

<p><code>lean
foo.ext : ∀ {α : Type u_1} (x y : foo α), x.x = y.x → x.y = y.y → x.z == y.z → x.k = y.k → x = y
</code></p>
       </div>
</div><div class="def"><a id="get_ext_subject"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L79">get_ext_subject</a></span> <span class="decl_args">(a : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="ext_param_type"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L99">ext_param_type</a></span>  <span class="decl_args">:</span>       <div class="decl_type">Type</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="opt_minus"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L101">opt_minus</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser">lean.parser</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> → <a href="https://robertylewis.com/mathlib_docs/tactic/ext.html#ext_param_type">ext_param_type</a>)</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="ext_param"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L104">ext_param</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser">lean.parser</a> <a href="https://robertylewis.com/mathlib_docs/tactic/ext.html#ext_param_type">ext_param_type</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="saturate_fun"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L109">saturate_fun</a></span> <span class="decl_args">(a : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="equiv_type_constr"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L122">equiv_type_constr</a></span> <span class="decl_args">(n n' : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="extensional_attribute"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L209">extensional_attribute</a></span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/attribute.html#user_attribute">user_attribute</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_map">name_map</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>) (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#bool">bool</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> <a href="https://robertylewis.com/mathlib_docs/tactic/ext.html#ext_param_type">ext_param_type</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>))</div>
<div class="indent"><p>Tag lemmas of the form:</p>

<p><code>lean
@[ext]
lemma my_collection.ext (a b : my_collection)
  (h : ∀ x, a.lookup x = b.lookup y) :
  a = b := ...
</code></p>

<p>The attribute indexes extensionality lemma using the type of the
objects (i.e. <code>my_collection</code>) which it gets from the statement of
the lemma.  In some cases, the same lemma can be used to state the
extensionality of multiple types that are definitionally equivalent.</p>

<p><code>lean
attribute [ext [(→),thunk,stream]] funext
</code></p>

<p>Those parameters are cumulative. The following are equivalent:</p>

<p><code>lean
attribute [ext [(→),thunk]] funext
attribute [ext [stream]] funext
</code>
and
<code>lean
attribute [ext [(→),thunk,stream]] funext
</code></p>

<p>One removes type names from the list for one lemma with:
<code>lean
attribute [ext [-stream,-thunk]] funext
</code></p>

<p>Also, the following:</p>

<p><code>lean
@[ext]
lemma my_collection.ext (a b : my_collection)
  (h : ∀ x, a.lookup x = b.lookup y) :
  a = b := ...
</code></p>

<p>is equivalent to</p>

<p><code>lean
@[ext *]
lemma my_collection.ext (a b : my_collection)
  (h : ∀ x, a.lookup x = b.lookup y) :
  a = b := ...
</code></p>

<p>This allows us specify type synonyms along with the type
that referred to in the lemma statement.</p>

<p><code>lean
@[ext [*,my_type_synonym]]
lemma my_collection.ext (a b : my_collection)
  (h : ∀ x, a.lookup x = b.lookup y) :
  a = b := ...
</code></p>

<p>Attribute <code>ext</code> can be applied to a structure to generate its extensionality lemma:</p>

<p><code>lean
@[ext]
structure foo (α : Type*) :=
(x y : ℕ)
(z : {z // z &lt; x})
(k : α)
(h : x &lt; y)
</code></p>

<p>will generate:</p>

<p><code>lean
@[ext] lemma foo.ext : ∀ {α : Type u_1} (x y : foo α), x.x = y.x → x.y = y.y → x.z == y.z → x.k = y.k → x = y
</code></p>
       </div>
</div><div class="thm"><a id="ulift.ext"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L240">ulift.ext</a></span> <span class="decl_args">{α : Type u₁}</span> <span class="decl_args">(X Y : <a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#ulift">ulift</a> α)</span> <span class="decl_args">(w : X.down = Y.down)</span> <span class="decl_args">:</span>       <div class="decl_type">X = Y</div>
<div class="indent"><p></p>
       Attributes: ext</div>
</div><div class="thm"><a id="plift.ext"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L247">plift.ext</a></span> <span class="decl_args">{P : Prop}</span> <span class="decl_args">(a b : <a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#plift">plift</a> P)</span> <span class="decl_args">:</span>       <div class="decl_type">a = b</div>
<div class="indent"><p></p>
       Attributes: ext</div>
</div><div class="def"><a id="tactic.try_intros"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L255">tactic.try_intros</a></span> <span class="decl_args">(a : <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_patt">tactic.ext_patt</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_patt">tactic.ext_patt</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="tactic.ext1"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L263">tactic.ext1</a></span> <span class="decl_args">(xs : <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_patt">tactic.ext_patt</a>)</span> <span class="decl_args">(cfg : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.apply_cfg">tactic.apply_cfg</a>
  {md := tactic.transparency.semireducible,
   approx := bool.tt,
   new_goals := tactic.new_goals.non_dep_first,
   instances := bool.tt,
   <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#auto_param">auto_param</a> := bool.tt,
   <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> := bool.tt,
   unify := bool.tt})</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_patt">tactic.ext_patt</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="tactic.ext"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L273">tactic.ext</a></span> <span class="decl_args">(a : <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_patt">tactic.ext_patt</a>)</span> <span class="decl_args">(a_1 : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> ℕ)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="tactic.interactive.ext1"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L288">tactic.interactive.ext1</a></span> <span class="decl_args">(xs : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_parse">tactic.ext_parse</a>)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><p><code>ext1 id</code> selects and apply one extensionality lemma (with attribute
<code>ext</code>), using <code>id</code>, if provided, to name a local constant
introduced by the lemma. If <code>id</code> is omitted, the local constant is
named automatically, as per <code>intro</code>.</p>
       </div>
</div><div class="def"><a id="tactic.interactive.ext"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/tactic/ext.lean#L318">tactic.interactive.ext</a></span> <span class="decl_args">(a : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_parse">tactic.ext_parse</a>)</span> <span class="decl_args">(a_1 : <a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/category/alternative.html#optional">optional</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser.tk">lean.parser.tk</a> ":" *> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser.small_nat">lean.parser.small_nat</a>)))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></div>
<div class="indent"><ul>
<li><code>ext</code> applies as many extensionality lemmas as possible;</li>
<li><code>ext ids</code>, with <code>ids</code> a list of identifiers, finds extentionality and applies them
until it runs out of identifiers in <code>ids</code> to name the local constants.</li>
</ul>

<p>When trying to prove:</p>

<p><code>lean
α β : Type,
f g : α → set β
⊢ f = g
</code></p>

<p>applying <code>ext x y</code> yields:</p>

<p><code>lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
</code></p>

<p>by applying functional extensionality and set extensionality.</p>

<p>A maximum depth can be provided with <code>ext x y z : 3</code>.</p>
       </div>
</div></body></html>