<html><head><title>tactic.ext</title><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><p></p>
</div><div class="entry"><a id="derive_struct_ext_lemma">      <h4>derive_struct_ext_lemma</h4><code><a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> → <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a></code>
<div class="indent"><p><p><code>derive_struct_ext_lemma n</code> generates an extensionality lemma based on
the equality of all non-propositional projections.</p>

<p>On the following:</p>

<p><code>lean
@[ext]
structure foo (α : Type*) :=
(x y : ℕ)
(z : {z // z &lt; x})
(k : α)
(h : x &lt; y)
</code></p>

<p><code>derive_struct_lemma</code> generates:</p>

<p><code>lean
foo.ext : ∀ {α : Type u_1} (x y : foo α), x.x = y.x → x.y = y.y → x.z == y.z → x.k = y.k → x = y
</code></p>
</p>       </div>
</div><div class="entry"><a id="get_ext_subject">      <h4>get_ext_subject</h4><code><a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a> → <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a></code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="ext_param_type">      <h4>ext_param_type</h4><code>Type</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="opt_minus">      <h4>opt_minus</h4><code><a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser">lean.parser</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> → <a href="https://robertylewis.com/mathlib_docs/tactic/ext.html#ext_param_type">ext_param_type</a>)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="ext_param">      <h4>ext_param</h4><code><a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser">lean.parser</a> <a href="https://robertylewis.com/mathlib_docs/tactic/ext.html#ext_param_type">ext_param_type</a></code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="saturate_fun">      <h4>saturate_fun</h4><code><a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> → <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/expr.html#expr">expr</a></code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="equiv_type_constr">      <h4>equiv_type_constr</h4><code><a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> → <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> → <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="extensional_attribute">      <h4>extensional_attribute</h4><code><a href="https://robertylewis.com/mathlib_docs/core/init/meta/attribute.html#user_attribute">user_attribute</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/rb_map.html#name_map">name_map</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>) (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#bool">bool</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> <a href="https://robertylewis.com/mathlib_docs/tactic/ext.html#ext_param_type">ext_param_type</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a> × <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#name">name</a>))</code>
<div class="indent"><p><p>Tag lemmas of the form:</p>

<p><code>lean
@[ext]
lemma my_collection.ext (a b : my_collection)
  (h : ∀ x, a.lookup x = b.lookup y) :
  a = b := ...
</code></p>

<p>The attribute indexes extensionality lemma using the type of the
objects (i.e. <code>my_collection</code>) which it gets from the statement of
the lemma.  In some cases, the same lemma can be used to state the
extensionality of multiple types that are definitionally equivalent.</p>

<p><code>lean
attribute [ext [(→),thunk,stream]] funext
</code></p>

<p>Those parameters are cumulative. The following are equivalent:</p>

<p><code>lean
attribute [ext [(→),thunk]] funext
attribute [ext [stream]] funext
</code>
and
<code>lean
attribute [ext [(→),thunk,stream]] funext
</code></p>

<p>One removes type names from the list for one lemma with:
<code>lean
attribute [ext [-stream,-thunk]] funext
</code></p>

<p>Also, the following:</p>

<p><code>lean
@[ext]
lemma my_collection.ext (a b : my_collection)
  (h : ∀ x, a.lookup x = b.lookup y) :
  a = b := ...
</code></p>

<p>is equivalent to</p>

<p><code>lean
@[ext *]
lemma my_collection.ext (a b : my_collection)
  (h : ∀ x, a.lookup x = b.lookup y) :
  a = b := ...
</code></p>

<p>This allows us specify type synonyms along with the type
that referred to in the lemma statement.</p>

<p><code>lean
@[ext [*,my_type_synonym]]
lemma my_collection.ext (a b : my_collection)
  (h : ∀ x, a.lookup x = b.lookup y) :
  a = b := ...
</code></p>

<p>Attribute <code>ext</code> can be applied to a structure to generate its extensionality lemma:</p>

<p><code>lean
@[ext]
structure foo (α : Type*) :=
(x y : ℕ)
(z : {z // z &lt; x})
(k : α)
(h : x &lt; y)
</code></p>

<p>will generate:</p>

<p><code>lean
@[ext] lemma foo.ext : ∀ {α : Type u_1} (x y : foo α), x.x = y.x → x.y = y.y → x.z == y.z → x.k = y.k → x = y
</code></p>
</p>       </div>
</div><div class="entry"><a id="ulift.ext">      <h4>ulift.ext</h4><code>∀ {α : Type u₁} (X Y : <a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#ulift">ulift</a> α), X.down = Y.down → X = Y</code>
<div class="indent"><p><p></p>
</p>       Attributes: ext</div>
</div><div class="entry"><a id="plift.ext">      <h4>plift.ext</h4><code>∀ {P : Prop} (a b : <a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#plift">plift</a> P), a = b</code>
<div class="indent"><p><p></p>
</p>       Attributes: ext</div>
</div><div class="entry"><a id="tactic.try_intros">      <h4>tactic.try_intros</h4><code><a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_patt">tactic.ext_patt</a> → <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_patt">tactic.ext_patt</a></code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="tactic.ext1">      <h4>tactic.ext1</h4><code><a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_patt">tactic.ext_patt</a> →
<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic.apply_cfg">tactic.apply_cfg</a>
  {md := tactic.transparency.semireducible,
   approx := bool.tt,
   new_goals := tactic.new_goals.non_dep_first,
   instances := bool.tt,
   <a href="https://robertylewis.com/mathlib_docs/core/init/meta/name.html#auto_param">auto_param</a> := bool.tt,
   <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> := bool.tt,
   unify := bool.tt} →
<a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_patt">tactic.ext_patt</a></code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="tactic.ext">      <h4>tactic.ext</h4><code><a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_patt">tactic.ext_patt</a> → <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> ℕ → <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="tactic.interactive.ext1">      <h4>tactic.interactive.ext1</h4><code><a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_parse">tactic.ext_parse</a> → <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></code>
<div class="indent"><p><p><code>ext1 id</code> selects and apply one extensionality lemma (with attribute
<code>ext</code>), using <code>id</code>, if provided, to name a local constant
introduced by the lemma. If <code>id</code> is omitted, the local constant is
named automatically, as per <code>intro</code>.</p>
</p>       </div>
</div><div class="entry"><a id="tactic.interactive.ext">      <h4>tactic.interactive.ext</h4><code><a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> <a href="https://robertylewis.com/mathlib_docs/tactic/rcases.html#tactic.ext_parse">tactic.ext_parse</a> →
<a href="https://robertylewis.com/mathlib_docs/core/init/meta/interactive_base.html#interactive.parse">interactive.parse</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/category/alternative.html#optional">optional</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser.tk">lean.parser.tk</a> \":\" *> <a href="https://robertylewis.com/mathlib_docs/core/init/meta/lean/parser.html#lean.parser.small_nat">lean.parser.small_nat</a>)) → <a href="https://robertylewis.com/mathlib_docs/core/init/meta/tactic.html#tactic">tactic</a> <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#unit">unit</a></code>
<div class="indent"><p><ul>
<li><code>ext</code> applies as many extensionality lemmas as possible;</li>
<li><code>ext ids</code>, with <code>ids</code> a list of identifiers, finds extentionality and applies them
until it runs out of identifiers in <code>ids</code> to name the local constants.</li>
</ul>

<p>When trying to prove:</p>

<p><code>lean
α β : Type,
f g : α → set β
⊢ f = g
</code></p>

<p>applying <code>ext x y</code> yields:</p>

<p><code>lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
</code></p>

<p>by applying functional extensionality and set extensionality.</p>

<p>A maximum depth can be provided with <code>ext x y z : 3</code>.</p>
</p>       </div>
</div></body></html>