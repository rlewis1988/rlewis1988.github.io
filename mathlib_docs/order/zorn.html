<!DOCTYPE html><html lang="en"><head><title>order.zorn</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/order/index.html">order</a>/<br><a href="zorn.html">zorn</a></div><div class="mod_doc"><p></p>
</div><div class="def"><a id="zorn.chain"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L25">zorn.chain</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">(r : α → α → Prop)</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α)</span> <span class="decl_args">:</span>       <div class="decl_type">Prop</div>
<div class="indent"><p>A chain is a subset <code>c</code> satisfying
 <code>x ≺ y ∨ x = y ∨ y ≺ x</code> for all <code>x y ∈ c</code>.</p>
       </div>
</div><div class="thm"><a id="zorn.chain.total_of_refl"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L28">zorn.chain.total_of_refl</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/classes.html#is_refl">is_refl</a> α r]</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(H : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c)</span> <span class="decl_args">{x y : α}</span> <span class="decl_args">(hx : x ∈ c)</span> <span class="decl_args">(hy : y ∈ c)</span> <span class="decl_args">:</span>       <div class="decl_type">r x y ∨ r y x</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain.directed"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L33">zorn.chain.directed</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/classes.html#is_refl">is_refl</a> α r]</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(H : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c)</span> <span class="decl_args">{x y : α}</span> <span class="decl_args">(hx : x ∈ c)</span> <span class="decl_args">(hy : y ∈ c)</span> <span class="decl_args">:</span>       <div class="decl_type">∃ (z : α), z ∈ c ∧ r x z ∧ r y z</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain.mono"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L41">zorn.chain.mono</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">{c c' : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(a : c' ⊆ c)</span> <span class="decl_args">(a_1 : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c'</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain.directed_on"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L44">zorn.chain.directed_on</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/classes.html#is_refl">is_refl</a> α r]</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(H : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/basic.html#directed_on">directed_on</a> r c</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain_insert"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L47">zorn.chain_insert</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">{a : α}</span> <span class="decl_args">(hc : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c)</span> <span class="decl_args">(ha : ∀ (b : α), b ∈ c → b ≠ a → r a b ∨ r b a)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r (<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#insert">insert</a> a c)</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="zorn.super_chain"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L53">zorn.super_chain</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">(c₁ c₂ : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α)</span> <span class="decl_args">:</span>       <div class="decl_type">Prop</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="zorn.is_max_chain"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L55">zorn.is_max_chain</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α)</span> <span class="decl_args">:</span>       <div class="decl_type">Prop</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="zorn.succ_chain"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L57">zorn.succ_chain</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">(c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.succ_spec"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L60">zorn.succ_spec</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(h : ∃ (c' : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α), <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c ∧ <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.super_chain">zorn.super_chain</a> c c')</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.super_chain">zorn.super_chain</a> c (<a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.succ_chain">zorn.succ_chain</a> c)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain_succ"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L67">zorn.chain_succ</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(hc : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r (<a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.succ_chain">zorn.succ_chain</a> c)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.super_of_not_max"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L73">zorn.super_of_not_max</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(hc₁ : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c)</span> <span class="decl_args">(hc₂ : ¬zorn.is_max_chain c)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.super_chain">zorn.super_chain</a> c (<a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.succ_chain">zorn.succ_chain</a> c)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.succ_increasing"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L81">zorn.succ_increasing</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">:</span>       <div class="decl_type">c ⊆ <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.succ_chain">zorn.succ_chain</a> c</div>
<div class="indent"><p></p>
       </div>
</div><div class="cnst"><a id="zorn.chain_closure"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L87">zorn.chain_closure</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">(a : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α)</span> <span class="decl_args">:</span>       <div class="decl_type">Prop</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain_closure_empty"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L91">zorn.chain_closure_empty</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain_closure">zorn.chain_closure</a> ∅</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain_closure_closure"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L96">zorn.chain_closure_closure</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain_closure">zorn.chain_closure</a> (⋃₀ <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain_closure">zorn.chain_closure</a>)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain_closure_total"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L147">zorn.chain_closure_total</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">{c₁ c₂ : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(hc₁ : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain_closure">zorn.chain_closure</a> c₁)</span> <span class="decl_args">(hc₂ : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain_closure">zorn.chain_closure</a> c₂)</span> <span class="decl_args">:</span>       <div class="decl_type">c₁ ⊆ c₂ ∨ c₂ ⊆ c₁</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain_closure_succ_fixpoint"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L152">zorn.chain_closure_succ_fixpoint</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">{c₁ c₂ : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(hc₁ : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain_closure">zorn.chain_closure</a> c₁)</span> <span class="decl_args">(hc₂ : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain_closure">zorn.chain_closure</a> c₂)</span> <span class="decl_args">(h_eq : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.succ_chain">zorn.succ_chain</a> c₂ = c₂)</span> <span class="decl_args">:</span>       <div class="decl_type">c₁ ⊆ c₂</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain_closure_succ_fixpoint_iff"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L163">zorn.chain_closure_succ_fixpoint_iff</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(hc : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain_closure">zorn.chain_closure</a> c)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.succ_chain">zorn.succ_chain</a> c = c ↔ c = ⋃₀ <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain_closure">zorn.chain_closure</a></div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain_chain_closure"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L175">zorn.chain_chain_closure</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(hc : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain_closure">zorn.chain_closure</a> c)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="zorn.max_chain"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L189">zorn.max_chain</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.max_chain_spec"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L195">zorn.max_chain_spec</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.is_max_chain">zorn.is_max_chain</a> <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.max_chain">zorn.max_chain</a></div>
<div class="indent"><p>Hausdorff's maximality principle</p>

<p>There exists a maximal totally ordered subset of <code>α</code>.
Note that we do not require <code>α</code> to be partially ordered by <code>r</code>.</p>
       </div>
</div><div class="thm"><a id="zorn.exists_maximal_of_chains_bounded"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L208">zorn.exists_maximal_of_chains_bounded</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{r : α → α → Prop}</span> <span class="decl_args">(h : ∀ (c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α), <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub))</span> <span class="decl_args">(<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/classes.html#trans">trans</a> : ∀ {a b c : α}, r a b → r b c → r a c)</span> <span class="decl_args">:</span>       <div class="decl_type">∃ (m : α), ∀ (a : α), r m a → r a m</div>
<div class="indent"><p>Zorn's lemma</p>

<p>If every chain has an upper bound, then there is a maximal element</p>
       </div>
</div><div class="thm"><a id="zorn.zorn_partial_order"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L224">zorn.zorn_partial_order</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/order.html#partial_order">partial_order</a> α]</span> <span class="decl_args">(h : ∀ (c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α), <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> has_le.le c → (∃ (ub : α), ∀ (a : α), a ∈ c → a ≤ ub))</span> <span class="decl_args">:</span>       <div class="decl_type">∃ (m : α), ∀ (a : α), m ≤ a → a = m</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.zorn_partial_order₀"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L229">zorn.zorn_partial_order₀</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/order.html#partial_order">partial_order</a> α]</span> <span class="decl_args">(s : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α)</span> <span class="decl_args">(ih : ∀ (c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α),
  c ⊆ s →
  <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> has_le.le c →
  ∀ (y : α), y ∈ c → (∃ (ub : α) (H : ub ∈ s), ∀ (z : α), z ∈ c → z ≤ ub))</span> <span class="decl_args">(x : α)</span> <span class="decl_args">(hxs : x ∈ s)</span> <span class="decl_args">:</span>       <div class="decl_type">∃ (m : α) (H : m ∈ s), x ≤ m ∧ ∀ (z : α), z ∈ s → m ≤ z → z = m</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.zorn_subset"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L241">zorn.zorn_subset</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">(S : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α))</span> <span class="decl_args">(h : ∀ (c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α)),
  c ⊆ S →
  <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> has_subset.subset c → (∃ (ub : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α) (H : ub ∈ S), ∀ (s : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α), s ∈ c → s ⊆ ub))</span> <span class="decl_args">:</span>       <div class="decl_type">∃ (m : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α) (H : m ∈ S), ∀ (a : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α), a ∈ S → m ⊆ a → a = m</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.zorn_subset₀"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L257">zorn.zorn_subset₀</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">(S : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α))</span> <span class="decl_args">(H : ∀ (c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α)),
  c ⊆ S →
  <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> has_subset.subset c →
  c ≠ ∅ → (∃ (ub : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α) (H : ub ∈ S), ∀ (s : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α), s ∈ c → s ⊆ ub))</span> <span class="decl_args">(x : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α)</span> <span class="decl_args">(hx : x ∈ S)</span> <span class="decl_args">:</span>       <div class="decl_type">∃ (m : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α) (H : m ∈ S), x ⊆ m ∧ ∀ (a : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α), a ∈ S → m ⊆ a → a = m</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain.total"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L273">zorn.chain.total</a></span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/order.html#preorder">preorder</a> α]</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(H : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> has_le.le c)</span> <span class="decl_args">{x y : α}</span> <span class="decl_args">(a : x ∈ c)</span> <span class="decl_args">(a_1 : y ∈ c)</span> <span class="decl_args">:</span>       <div class="decl_type">x ≤ y ∨ y ≤ x</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="zorn.chain.image"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/886b15b5ea473ae51ed90de31b05f23de00be10d/src/order/zorn.lean#L278">zorn.chain.image</a></span> <span class="decl_args">{α : Type u_1}</span> <span class="decl_args">{β : Type u_2}</span> <span class="decl_args">(r : α → α → Prop)</span> <span class="decl_args">(s : β → β → Prop)</span> <span class="decl_args">(f : α → β)</span> <span class="decl_args">(h : ∀ (x y : α), r x y → s (f x) (f y))</span> <span class="decl_args">{c : <a href="https://robertylewis.com/mathlib_docs/core/init/data/set.html#set">set</a> α}</span> <span class="decl_args">(hrc : <a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> r c)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/order/zorn.html#zorn.chain">zorn.chain</a> s (f '' c)</div>
<div class="indent"><p></p>
       </div>
</div></body></html>