<!DOCTYPE html><html lang="en"><head><title>category.bitraversable.basic</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/category/index.html">category</a>/<br><a href="https://robertylewis.com/mathlib_docs/category/bitraversable/index.html">bitraversable</a>/<br><a href="basic.html">basic</a>      <br><br><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category/bitraversable/basic.lean">View file source</a></div><div class="mod_doc"><h1>Bitraversable type class</h1>

<p>Type class for traversing bifunctors. The concepts and laws are taken from
https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bitraversable.html</p>

<p>Simple examples of <code>bitraversable</code> are <code>prod</code> and <code>sum</code>. A more elaborate example is
to define an a-list as:</p>

<p><code>
def <a href="https://robertylewis.com/mathlib_docs/data/list/alist.html#alist">alist</a> (key val : Type) := <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (key × val)
</code></p>

<p>Then we can use <code>f : key → <a href="https://robertylewis.com/mathlib_docs/core/system/io.html#io">io</a> key'</code> and <code>g : val → <a href="https://robertylewis.com/mathlib_docs/core/system/io.html#io">io</a> val'</code> to manipulate the <code>alist</code>'s key
and value respectively with <code>bitraverse f g : <a href="https://robertylewis.com/mathlib_docs/data/list/alist.html#alist">alist</a> key val → <a href="https://robertylewis.com/mathlib_docs/core/system/io.html#io">io</a> (<a href="https://robertylewis.com/mathlib_docs/data/list/alist.html#alist">alist</a> key' val')</code></p>

<h2>Main definitions</h2>

<ul>
<li>bitraversable - exposes the <code>bitraverse</code> function</li>
<li>is_lawful_bitraversable - laws similar to is_lawful_traversable</li>
</ul>

<h2>Tags</h2>

<p>traversable bitraversable iterator functor bifunctor applicative</p>
</div><div class="structure"><a id="bitraversable"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category/bitraversable/basic.lean#L40">bitraversable</a></span> <span class="decl_args">(t : Type u → Type u → Type u)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (u+1)</div>
<div class="indent"><p></p>
       <div class="structure_fields">
Fields:
<div class="structure_field">bitraversable.to_bifunctor : <a href="https://robertylewis.com/mathlib_docs/category/bifunctor.html#bifunctor">bifunctor</a> t</div>
<div class="structure_field">bitraversable.bitraverse : Π {m : Type ? → Type ?} [_inst_1 : <a href="https://robertylewis.com/mathlib_docs/core/init/category/applicative.html#applicative">applicative</a> m] {α α' β β' : Type ?},
  (α → m α') → (β → m β') → t α β → m (t α' β')</div>
</div>

</div>
</div><div class="def"><a id="bisequence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category/bitraversable/basic.lean#L46">bisequence</a></span> <span class="decl_args">{t : Type u_1 → Type u_1 → Type u_1}</span> <span class="decl_args">{m : Type u_1 → Type u_1}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category/bitraversable/basic.html#bitraversable">bitraversable</a> t]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/category/applicative.html#applicative">applicative</a> m]</span> <span class="decl_args">{α β : Type u_1}</span> <span class="decl_args">(a : t (m α) (m β))</span> <span class="decl_args">:</span>       <div class="decl_type">m (t α β)</div>
<div class="indent"><p></p>
       

</div>
</div><div class="structure"><a id="is_lawful_bitraversable"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/lean-3.4.2/src/category/bitraversable/basic.lean#L51">is_lawful_bitraversable</a></span> <span class="decl_args">(t : Type u → Type u → Type u)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category/bitraversable/basic.html#bitraversable">bitraversable</a> t]</span> <span class="decl_args">:</span>       <div class="decl_type">Type</div>
<div class="indent"><p></p>
       <div class="structure_fields">
Fields:
<div class="structure_field">is_lawful_bitraversable.to_is_lawful_bifunctor : <a href="https://robertylewis.com/mathlib_docs/category/bifunctor.html#is_lawful_bifunctor">is_lawful_bifunctor</a> t</div>
<div class="structure_field">is_lawful_bitraversable.id_bitraverse : ∀ {α β : Type ?} (x : t α β), bitraversable.bitraverse <a href="https://robertylewis.com/mathlib_docs/category/functor.html#id.mk">id.mk</a> <a href="https://robertylewis.com/mathlib_docs/category/functor.html#id.mk">id.mk</a> x = <a href="https://robertylewis.com/mathlib_docs/category/functor.html#id.mk">id.mk</a> x</div>
<div class="structure_field">is_lawful_bitraversable.comp_bitraverse : ∀ {F G : Type ? → Type ?} [_inst_1_1 : <a href="https://robertylewis.com/mathlib_docs/core/init/category/applicative.html#applicative">applicative</a> F] [_inst_2 : <a href="https://robertylewis.com/mathlib_docs/core/init/category/applicative.html#applicative">applicative</a> G] [_inst_3 : <a href="https://robertylewis.com/mathlib_docs/core/init/category/lawful.html#is_lawful_applicative">is_lawful_applicative</a> F]
[_inst_4 : <a href="https://robertylewis.com/mathlib_docs/core/init/category/lawful.html#is_lawful_applicative">is_lawful_applicative</a> G] {α α' β β' γ γ' : Type ?} (f : β → F γ) (f' : β' → F γ')
(g : α → G β) (g' : α' → G β') (x : t α α'),
  bitraversable.bitraverse (<a href="https://robertylewis.com/mathlib_docs/category/functor.html#functor.comp.mk">functor.comp.mk</a> ∘ functor.map f ∘ g) (<a href="https://robertylewis.com/mathlib_docs/category/functor.html#functor.comp.mk">functor.comp.mk</a> ∘ functor.map f' ∘ g') x =
    <a href="https://robertylewis.com/mathlib_docs/category/functor.html#functor.comp.mk">functor.comp.mk</a> (bitraversable.bitraverse f f' <$> bitraversable.bitraverse g g' x)</div>
<div class="structure_field">is_lawful_bitraversable.bitraverse_eq_bimap_id : ∀ {α α' β β' : Type ?} (f : α → β) (f' : α' → β') (x : t α α'),
  bitraversable.bitraverse (<a href="https://robertylewis.com/mathlib_docs/category/functor.html#id.mk">id.mk</a> ∘ f) (<a href="https://robertylewis.com/mathlib_docs/category/functor.html#id.mk">id.mk</a> ∘ f') x = <a href="https://robertylewis.com/mathlib_docs/category/functor.html#id.mk">id.mk</a> (bifunctor.bimap f f' x)</div>
<div class="structure_field">is_lawful_bitraversable.binaturality : ∀ {F G : Type ? → Type ?} [_inst_1_1 : <a href="https://robertylewis.com/mathlib_docs/core/init/category/applicative.html#applicative">applicative</a> F] [_inst_2 : <a href="https://robertylewis.com/mathlib_docs/core/init/category/applicative.html#applicative">applicative</a> G] [_inst_3 : <a href="https://robertylewis.com/mathlib_docs/core/init/category/lawful.html#is_lawful_applicative">is_lawful_applicative</a> F]
[_inst_4 : <a href="https://robertylewis.com/mathlib_docs/core/init/category/lawful.html#is_lawful_applicative">is_lawful_applicative</a> G] (η : <a href="https://robertylewis.com/mathlib_docs/category/traversable/basic.html#applicative_transformation">applicative_transformation</a> F G) {α α' β β' : Type ?} (f : α → F β)
(f' : α' → F β') (x : t α α'),
  ⇑η (bitraversable.bitraverse f f' x) = bitraversable.bitraverse (⇑η ∘ f) (⇑η ∘ f') x</div>
</div>

</div>
</div></body></html>