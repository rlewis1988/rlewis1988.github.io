<!DOCTYPE html><html lang="en"><head><title>data.hash_map</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><p></p>
</div><div class="def"><a id="bucket_array"></a>      <span class="decl_name">bucket_array</span> <span class="decl_args">(α : Type u)</span> <span class="decl_args">(β : α → Type v)</span> <span class="decl_args">(n : ℕ+)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p><code>bucket_array α β</code> is the underlying data type for <code>hash_map α β</code>,
 an array of linked lists of key-value pairs.</p>
       </div>
</div><div class="def"><a id="hash_map.mk_idx"></a>      <span class="decl_name">hash_map.mk_idx</span> <span class="decl_args">(n : ℕ+)</span> <span class="decl_args">(i : ℕ)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/data/fin/basic.html#fin">fin</a> (n.val)</div>
<div class="indent"><p>Make a hash_map index from a <code>nat</code> hash value and a (positive) buffer size</p>
       </div>
</div><div class="def"><a id="bucket_array.read"></a>      <span class="decl_name">bucket_array.read</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">(data : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)</div>
<div class="indent"><p>Read the bucket corresponding to an element</p>
       </div>
</div><div class="def"><a id="bucket_array.write"></a>      <span class="decl_name">bucket_array.write</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">(data : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n</div>
<div class="indent"><p>Write the bucket corresponding to an element</p>
       </div>
</div><div class="def"><a id="bucket_array.modify"></a>      <span class="decl_name">bucket_array.modify</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">(data : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(f : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a) → <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n</div>
<div class="indent"><p>Modify (read, apply <code>f</code>, and write) the bucket corresponding to an element</p>
       </div>
</div><div class="def"><a id="bucket_array.as_list"></a>      <span class="decl_name">bucket_array.as_list</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">(data : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)</div>
<div class="indent"><p>The list of all key-value pairs in the bucket list</p>
       </div>
</div><div class="thm"><a id="bucket_array.mem_as_list"></a>      <span class="decl_name">bucket_array.mem_as_list</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">(data : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n)</span> <span class="decl_args">{a : Σ (a : α), β a}</span> <span class="decl_args">:</span>       <div class="decl_type">a ∈ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.as_list">bucket_array.as_list</a> data ↔ ∃ (i : <a href="https://robertylewis.com/mathlib_docs/core/init/data/fin/basic.html#fin">fin</a> (n.val)), a ∈ <a href="https://robertylewis.com/mathlib_docs/core/init/data/array/basic.html#array.read">array.read</a> data i</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="bucket_array.foldl"></a>      <span class="decl_name">bucket_array.foldl</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">(data : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n)</span> <span class="decl_args">{δ : Type w}</span> <span class="decl_args">(d : δ)</span> <span class="decl_args">(f : δ → Π (a : α), β a → δ)</span> <span class="decl_args">:</span>       <div class="decl_type">δ</div>
<div class="indent"><p>Fold a function <code>f</code> over the key-value pairs in the bucket list</p>
       </div>
</div><div class="thm"><a id="bucket_array.foldl_eq"></a>      <span class="decl_name">bucket_array.foldl_eq</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">(data : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n)</span> <span class="decl_args">{δ : Type w}</span> <span class="decl_args">(d : δ)</span> <span class="decl_args">(f : δ → Π (a : α), β a → δ)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.foldl">bucket_array.foldl</a> data d f =
  <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.foldl">list.foldl</a> (λ (r : δ) (a : Σ (a : α), β a), f r (a.fst) (a.snd)) d (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.as_list">bucket_array.as_list</a> data)</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="hash_map.reinsert_aux"></a>      <span class="decl_name">hash_map.reinsert_aux</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">(data : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n</div>
<div class="indent"><p>Insert the pair <code>⟨a, b⟩</code> into the correct location in the bucket array
 (without checking for duplication)</p>
       </div>
</div><div class="def"><a id="hash_map.find_aux"></a>      <span class="decl_name">hash_map.find_aux</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(a_1 : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> (β a)</div>
<div class="indent"><p>Search a bucket for a key <code>a</code> and return the value</p>
       </div>
</div><div class="thm"><a id="hash_map.find_aux_iff"></a>      <span class="decl_name">hash_map.find_aux_iff</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{a : α}</span> <span class="decl_args">{b : β a}</span> <span class="decl_args">{l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)}</span> <span class="decl_args">(a_1 : <a href="https://robertylewis.com/mathlib_docs/data/list/defs.html#list.nodup">list.nodup</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst l))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find_aux">hash_map.find_aux</a> a l = option.some b ↔ ⟨a, b⟩ ∈ l</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="hash_map.contains_aux"></a>      <span class="decl_name">hash_map.contains_aux</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#bool">bool</a></div>
<div class="indent"><p>Returns <code>tt</code> if the bucket <code>l</code> contains the key <code>a</code></p>
       </div>
</div><div class="thm"><a id="hash_map.contains_aux_iff"></a>      <span class="decl_name">hash_map.contains_aux_iff</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{a : α}</span> <span class="decl_args">{l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)}</span> <span class="decl_args">(nd : <a href="https://robertylewis.com/mathlib_docs/data/list/defs.html#list.nodup">list.nodup</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst l))</span> <span class="decl_args">:</span>       <div class="decl_type">↥(<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.contains_aux">hash_map.contains_aux</a> a l) ↔ a ∈ <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst l</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="hash_map.replace_aux"></a>      <span class="decl_name">hash_map.replace_aux</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">(a_1 : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)</div>
<div class="indent"><p>Modify a bucket to replace a value in the list. Leaves the list
unchanged if the key is not found.</p>
       </div>
</div><div class="def"><a id="hash_map.erase_aux"></a>      <span class="decl_name">hash_map.erase_aux</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(a_1 : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)</div>
<div class="indent"><p>Modify a bucket to remove a key, if it exists.</p>
       </div>
</div><div class="cnst"><a id="hash_map.valid"></a>      <span class="decl_name">hash_map.valid</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">(bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n)</span> <span class="decl_args">(sz : ℕ)</span> <span class="decl_args">:</span>       <div class="decl_type">Prop</div>
<div class="indent"><p>The predicate <code>valid bkts sz</code> means that <code>bkts</code> satisfies the <code>hash_map</code>
 invariants: There are exactly <code>sz</code> elements in it, every pair is in the
 bucket determined by its key and the hash function, and no key appears
 multiple times in the list.</p>
       </div>
</div><div class="thm"><a id="hash_map.valid.idx_enum"></a>      <span class="decl_name">hash_map.valid.idx_enum</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{sz : ℕ}</span> <span class="decl_args">(v : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts sz)</span> <span class="decl_args">{i : ℕ}</span> <span class="decl_args">{l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)}</span> <span class="decl_args">(he : (i, l) ∈ <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.enum">list.enum</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/array/basic.html#array.to_list">array.to_list</a> bkts))</span> <span class="decl_args">{a : α}</span> <span class="decl_args">{b : β a}</span> <span class="decl_args">(hl : ⟨a, b⟩ ∈ l)</span> <span class="decl_args">:</span>       <div class="decl_type">∃ (h : i < n.val), <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.mk_idx">hash_map.mk_idx</a> n (hash_fn a) = ⟨i, h⟩</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.valid.idx_enum_1"></a>      <span class="decl_name">hash_map.valid.idx_enum_1</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{sz : ℕ}</span> <span class="decl_args">(v : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts sz)</span> <span class="decl_args">{i : ℕ}</span> <span class="decl_args">{l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)}</span> <span class="decl_args">(he : (i, l) ∈ <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.enum">list.enum</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/array/basic.html#array.to_list">array.to_list</a> bkts))</span> <span class="decl_args">{a : α}</span> <span class="decl_args">{b : β a}</span> <span class="decl_args">(hl : ⟨a, b⟩ ∈ l)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.mk_idx">hash_map.mk_idx</a> n (hash_fn a)).val = i</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.valid.as_list_nodup"></a>      <span class="decl_name">hash_map.valid.as_list_nodup</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{sz : ℕ}</span> <span class="decl_args">(v : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts sz)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/list/defs.html#list.nodup">list.nodup</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.as_list">bucket_array.as_list</a> bkts))</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.mk_as_list"></a>      <span class="decl_name">hash_map.mk_as_list</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(n : ℕ+)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.as_list">bucket_array.as_list</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/array/basic.html#mk_array">mk_array</a> (n.val) list.nil) = list.nil</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.mk_valid"></a>      <span class="decl_name">hash_map.mk_valid</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(n : ℕ+)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn (<a href="https://robertylewis.com/mathlib_docs/core/init/data/array/basic.html#mk_array">mk_array</a> (n.val) list.nil) 0</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.valid.find_aux_iff"></a>      <span class="decl_name">hash_map.valid.find_aux_iff</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{sz : ℕ}</span> <span class="decl_args">(v : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts sz)</span> <span class="decl_args">{a : α}</span> <span class="decl_args">{b : β a}</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find_aux">hash_map.find_aux</a> a (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.read">bucket_array.read</a> hash_fn bkts a) = option.some b ↔ ⟨a, b⟩ ∈ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.as_list">bucket_array.as_list</a> bkts</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.valid.contains_aux_iff"></a>      <span class="decl_name">hash_map.valid.contains_aux_iff</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{sz : ℕ}</span> <span class="decl_args">(v : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts sz)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">:</span>       <div class="decl_type">↥(<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.contains_aux">hash_map.contains_aux</a> a (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.read">bucket_array.read</a> hash_fn bkts a)) ↔ a ∈ <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.as_list">bucket_array.as_list</a> bkts)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.append_of_modify"></a>      <span class="decl_name">hash_map.append_of_modify</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{bidx : <a href="https://robertylewis.com/mathlib_docs/core/init/data/fin/basic.html#fin">fin</a> (n.val)}</span> <span class="decl_args">{f : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a) → <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)}</span> <span class="decl_args">(u v1 v2 w : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">(hl : <a href="https://robertylewis.com/mathlib_docs/core/init/data/array/basic.html#array.read">array.read</a> bkts bidx = u ++ v1 ++ w)</span> <span class="decl_args">(hfl : f (<a href="https://robertylewis.com/mathlib_docs/core/init/data/array/basic.html#array.read">array.read</a> bkts bidx) = u ++ v2 ++ w)</span> <span class="decl_args">:</span>       <div class="decl_type">∃ (u' w' : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)),
  <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.as_list">bucket_array.as_list</a> bkts = u' ++ v1 ++ w' ∧ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.as_list">bucket_array.as_list</a> bkts' = u' ++ v2 ++ w'</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.valid.modify"></a>      <span class="decl_name">hash_map.valid.modify</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{bidx : <a href="https://robertylewis.com/mathlib_docs/core/init/data/fin/basic.html#fin">fin</a> (n.val)}</span> <span class="decl_args">{f : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a) → <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)}</span> <span class="decl_args">(u v1 v2 w : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">(hl : <a href="https://robertylewis.com/mathlib_docs/core/init/data/array/basic.html#array.read">array.read</a> bkts bidx = u ++ v1 ++ w)</span> <span class="decl_args">(hfl : f (<a href="https://robertylewis.com/mathlib_docs/core/init/data/array/basic.html#array.read">array.read</a> bkts bidx) = u ++ v2 ++ w)</span> <span class="decl_args">(hvnd : <a href="https://robertylewis.com/mathlib_docs/data/list/defs.html#list.nodup">list.nodup</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst v2))</span> <span class="decl_args">(hal : ∀ (a : Σ (a : α), β a), a ∈ v2 → <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.mk_idx">hash_map.mk_idx</a> n (hash_fn (a.fst)) = bidx)</span> <span class="decl_args">(djuv : <a href="https://robertylewis.com/mathlib_docs/data/list/defs.html#list.disjoint">list.disjoint</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst u) (<a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst v2))</span> <span class="decl_args">(djwv : <a href="https://robertylewis.com/mathlib_docs/data/list/defs.html#list.disjoint">list.disjoint</a> (<a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst w) (<a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst v2))</span> <span class="decl_args">{sz : ℕ}</span> <span class="decl_args">(v : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts sz)</span> <span class="decl_args">:</span>       <div class="decl_type">sz + <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.length">list.length</a> v2 ≥ <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.length">list.length</a> v1 ∧ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts' (sz + <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.length">list.length</a> v2 - <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.length">list.length</a> v1)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.valid.replace_aux"></a>      <span class="decl_name">hash_map.valid.replace_aux</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">(l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">(a_1 : a ∈ <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst l)</span> <span class="decl_args">:</span>       <div class="decl_type">∃ (u w : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)) (b' : β a),
  l = u ++ [⟨a, b'⟩] ++ w ∧ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.replace_aux">hash_map.replace_aux</a> a b l = u ++ [⟨a, b⟩] ++ w</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.valid.replace"></a>      <span class="decl_name">hash_map.valid.replace</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{sz : ℕ}</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">(Hc : ↥(<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.contains_aux">hash_map.contains_aux</a> a (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.read">bucket_array.read</a> hash_fn bkts a)))</span> <span class="decl_args">(v : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts sz)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.modify">bucket_array.modify</a> hash_fn bkts a (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.replace_aux">hash_map.replace_aux</a> a b)) sz</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.valid.insert"></a>      <span class="decl_name">hash_map.valid.insert</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{sz : ℕ}</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">(Hnc : ¬↥(<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.contains_aux">hash_map.contains_aux</a> a (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.read">bucket_array.read</a> hash_fn bkts a)))</span> <span class="decl_args">(v : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts sz)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.reinsert_aux">hash_map.reinsert_aux</a> hash_fn bkts a b) (sz + 1)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.valid.erase_aux"></a>      <span class="decl_name">hash_map.valid.erase_aux</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">(a_1 : a ∈ <a href="https://robertylewis.com/mathlib_docs/core/init/data/list/basic.html#list.map">list.map</a> sigma.fst l)</span> <span class="decl_args">:</span>       <div class="decl_type">∃ (u w : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)) (b : β a),
  l = u ++ [⟨a, b⟩] ++ w ∧ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.erase_aux">hash_map.erase_aux</a> a l = u ++ list.nil ++ w</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.valid.erase"></a>      <span class="decl_name">hash_map.valid.erase</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{n : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{sz : ℕ}</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(Hc : ↥(<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.contains_aux">hash_map.contains_aux</a> a (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.read">bucket_array.read</a> hash_fn bkts a)))</span> <span class="decl_args">(v : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts sz)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.modify">bucket_array.modify</a> hash_fn bkts a (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.erase_aux">hash_map.erase_aux</a> a)) (sz - 1)</div>
<div class="indent"><p></p>
       </div>
</div><div class="cnst"><a id="hash_map"></a>      <span class="decl_name">hash_map</span> <span class="decl_args">(α : Type u)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(β : α → Type v)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> u v)</div>
<div class="indent"><p>A hash map data structure, representing a finite key-value map
 with key type <code>α</code> and value type <code>β</code> (which may depend on <code>α</code>).</p>
       </div>
</div><div class="def"><a id="mk_hash_map"></a>      <span class="decl_name">mk_hash_map</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">(nbuckets : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> ℕ 8)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β</div>
<div class="indent"><p>Construct an empty hash map with buffer size <code>nbuckets</code> (default 8).</p>
       </div>
</div><div class="def"><a id="hash_map.find"></a>      <span class="decl_name">hash_map.find</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#option">option</a> (β a)</div>
<div class="indent"><p>Return the value corresponding to a key, or <code>none</code> if not found</p>
       </div>
</div><div class="def"><a id="hash_map.contains"></a>      <span class="decl_name">hash_map.contains</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#bool">bool</a></div>
<div class="indent"><p>Return <code>tt</code> if the key exists in the map</p>
       </div>
</div><div class="def"><a id="hash_map.has_mem"></a>      <span class="decl_name">hash_map.has_mem</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#has_mem">has_mem</a> α (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="hash_map.fold"></a>      <span class="decl_name">hash_map.fold</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">{δ : Type w}</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(d : δ)</span> <span class="decl_args">(f : δ → Π (a : α), β a → δ)</span> <span class="decl_args">:</span>       <div class="decl_type">δ</div>
<div class="indent"><p>Fold a function over the key-value pairs in the map</p>
       </div>
</div><div class="def"><a id="hash_map.entries"></a>      <span class="decl_name">hash_map.entries</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a)</div>
<div class="indent"><p>The list of key-value pairs in the map</p>
       </div>
</div><div class="def"><a id="hash_map.keys"></a>      <span class="decl_name">hash_map.keys</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> α</div>
<div class="indent"><p>The list of keys in the map</p>
       </div>
</div><div class="thm"><a id="hash_map.find_iff"></a>      <span class="decl_name">hash_map.find_iff</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> m a = option.some b ↔ ⟨a, b⟩ ∈ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.entries">hash_map.entries</a> m</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.contains_iff"></a>      <span class="decl_name">hash_map.contains_iff</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">:</span>       <div class="decl_type">↥(<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.contains">hash_map.contains</a> m a) ↔ a ∈ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.keys">hash_map.keys</a> m</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.entries_empty"></a>      <span class="decl_name">hash_map.entries_empty</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">(n : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> ℕ 8)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.entries">hash_map.entries</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#mk_hash_map">mk_hash_map</a> hash_fn n) = list.nil</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.keys_empty"></a>      <span class="decl_name">hash_map.keys_empty</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">(n : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> ℕ 8)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.keys">hash_map.keys</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#mk_hash_map">mk_hash_map</a> hash_fn n) = list.nil</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.find_empty"></a>      <span class="decl_name">hash_map.find_empty</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">(n : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> ℕ 8)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#mk_hash_map">mk_hash_map</a> hash_fn n) a = option.none</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.not_contains_empty"></a>      <span class="decl_name">hash_map.not_contains_empty</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">(n : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#opt_param">opt_param</a> ℕ 8)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">:</span>       <div class="decl_type">¬↥(<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.contains">hash_map.contains</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#mk_hash_map">mk_hash_map</a> hash_fn n) a)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.insert_lemma"></a>      <span class="decl_name">hash_map.insert_lemma</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">{n n' : ℕ+}</span> <span class="decl_args">{bkts : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array">bucket_array</a> α β n}</span> <span class="decl_args">{sz : ℕ}</span> <span class="decl_args">(v : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn bkts sz)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.valid">hash_map.valid</a> hash_fn (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#bucket_array.foldl">bucket_array.foldl</a> bkts (<a href="https://robertylewis.com/mathlib_docs/core/init/data/array/basic.html#mk_array">mk_array</a> (n'.val) list.nil) (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.reinsert_aux">hash_map.reinsert_aux</a> hash_fn)) sz</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="hash_map.insert"></a>      <span class="decl_name">hash_map.insert</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β</div>
<div class="indent"><p>Insert a key-value pair into the map. (Modifies <code>m</code> in-place when applicable)</p>
       </div>
</div><div class="thm"><a id="hash_map.mem_insert"></a>      <span class="decl_name">hash_map.mem_insert</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">(a' : α)</span> <span class="decl_args">(b' : β a')</span> <span class="decl_args">:</span>       <div class="decl_type">⟨a', b'⟩ ∈ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.entries">hash_map.entries</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.insert">hash_map.insert</a> m a b) ↔
  <a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#ite">ite</a> (a = a') (b == b') (⟨a', b'⟩ ∈ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.entries">hash_map.entries</a> m)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.find_insert_eq"></a>      <span class="decl_name">hash_map.find_insert_eq</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.insert">hash_map.insert</a> m a b) a = option.some b</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.find_insert_ne"></a>      <span class="decl_name">hash_map.find_insert_ne</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a a' : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">(h : a ≠ a')</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.insert">hash_map.insert</a> m a b) a' = <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> m a'</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.find_insert"></a>      <span class="decl_name">hash_map.find_insert</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a' a : α)</span> <span class="decl_args">(b : β a)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.insert">hash_map.insert</a> m a b) a' =
  <a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#dite">dite</a> (a = a') (λ (h : a = a'), option.some (eq.rec_on h b)) (λ (h : ¬a = a'), <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> m a')</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="hash_map.insert_all"></a>      <span class="decl_name">hash_map.insert_all</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β</div>
<div class="indent"><p>Insert a list of key-value pairs into the map. (Modifies <code>m</code> in-place when applicable)</p>
       </div>
</div><div class="def"><a id="hash_map.of_list"></a>      <span class="decl_name">hash_map.of_list</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(l : <a href="https://robertylewis.com/mathlib_docs/core/init/core.html#list">list</a> (Σ (a : α), β a))</span> <span class="decl_args">(hash_fn : α → ℕ)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β</div>
<div class="indent"><p>Construct a hash map from a list of key-value pairs.</p>
       </div>
</div><div class="def"><a id="hash_map.erase"></a>      <span class="decl_name">hash_map.erase</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β</div>
<div class="indent"><p>Remove a key from the map. (Modifies <code>m</code> in-place when applicable)</p>
       </div>
</div><div class="thm"><a id="hash_map.mem_erase"></a>      <span class="decl_name">hash_map.mem_erase</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a a' : α)</span> <span class="decl_args">(b' : β a')</span> <span class="decl_args">:</span>       <div class="decl_type">⟨a', b'⟩ ∈ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.entries">hash_map.entries</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.erase">hash_map.erase</a> m a) ↔ a ≠ a' ∧ ⟨a', b'⟩ ∈ <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.entries">hash_map.entries</a> m</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.find_erase_eq"></a>      <span class="decl_name">hash_map.find_erase_eq</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a : α)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.erase">hash_map.erase</a> m a) a = option.none</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.find_erase_ne"></a>      <span class="decl_name">hash_map.find_erase_ne</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a a' : α)</span> <span class="decl_args">(h : a ≠ a')</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.erase">hash_map.erase</a> m a) a' = <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> m a'</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="hash_map.find_erase"></a>      <span class="decl_name">hash_map.find_erase</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">(m : <a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</span> <span class="decl_args">(a' a : α)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.erase">hash_map.erase</a> m a) a' = <a href="https://robertylewis.com/mathlib_docs/core/init/logic.html#ite">ite</a> (a = a') option.none (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map.find">hash_map.find</a> m a')</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="hash_map.has_to_string"></a>      <span class="decl_name">hash_map.has_to_string</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/data/to_string.html#has_to_string">has_to_string</a> α]</span> <span class="decl_args">[Π (a : α), <a href="https://robertylewis.com/mathlib_docs/core/init/data/to_string.html#has_to_string">has_to_string</a> (β a)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/data/to_string.html#has_to_string">has_to_string</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="hash_map.has_to_format"></a>      <span class="decl_name">hash_map.has_to_format</span> <span class="decl_args">{α : Type u}</span> <span class="decl_args">{β : α → Type v}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/core.html#decidable_eq">decidable_eq</a> α]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/core/init/meta/format.html#has_to_format">has_to_format</a> α]</span> <span class="decl_args">[Π (a : α), <a href="https://robertylewis.com/mathlib_docs/core/init/meta/format.html#has_to_format">has_to_format</a> (β a)]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/meta/format.html#has_to_format">has_to_format</a> (<a href="https://robertylewis.com/mathlib_docs/data/hash_map.html#hash_map">hash_map</a> α β)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div></body></html>