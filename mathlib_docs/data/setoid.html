<!DOCTYPE html><html lang="en"><head><title>data.setoid</title><meta charset="UTF-8"><link rel="stylesheet" href="/home/rob/lean/mathlib/scripts/html_out/style.css"></head><body><div class="mod_doc"><h1>Equivalence relations</h1>

<p>The first section of the file defines the complete lattice of equivalence relations
on a type, results about the inductively defined equivalence closure of a binary relation,
and the analogues of some isomorphism theorems for quotients of arbitrary types.</p>

<p>The second section comprises properties of equivalence relations viewed as partitions.</p>

<h2>Implementation notes</h2>

<p>The function <code>rel</code> and lemmas ending in ' make it easier to talk about different
equivalence relations on the same type.</p>

<p>The complete lattice instance for equivalence relations could have been defined by lifting
the Galois insertion of equivalence relations on α into binary relations on α, and then using
<code>complete_lattice.copy</code> to define a complete lattice instance with more appropriate
definitional equalities (a similar example is <code>filter.lattice.complete_lattice</code> in
<code>order/filter/basic.lean</code>). This does not save space, however, and is less clear.</p>

<p>Partitions are not defined as a separate structure here; users are encouraged to
reason about them using the existing <code>setoid</code> and its infrastructure.</p>

<h2>Tags</h2>

<p>setoid, equivalence, iseqv, relation, equivalence relation, partition, equivalence
class</p>
</div><div class="def"><a id="setoid.rel"></a>      <h4>setoid.rel</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α → α → α → Prop</code>
<div class="indent"><p>A version of <code>setoid.r</code> that takes the equivalence relation as an explicit argument.</p>
       </div>
</div><div class="thm"><a id="quotient.eq_rel"></a>      <h4>quotient.eq_rel</h4><code>∀ {α : Type u_1} {r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α} {x y : α}, ⟦x⟧ = ⟦y⟧ ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x y</code>
<div class="indent"><p>A version of <code>quotient.eq'</code> compatible with <code>setoid.rel</code>, to make rewriting possible.</p>
       </div>
</div><div class="thm"><a id="setoid.ext'"></a>      <h4>setoid.ext'</h4><code>∀ {α : Type u_1} {r s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α}, (∀ (a b : α), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r a b ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> s a b) → r = s</code>
<div class="indent"><p></p>
       Attributes: ext</div>
</div><div class="thm"><a id="setoid.ext_iff"></a>      <h4>setoid.ext_iff</h4><code>∀ {α : Type u_1} {r s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α}, r = s ↔ ∀ (a b : α), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r a b ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> s a b</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="setoid.eq_iff_rel_eq"></a>      <h4>setoid.eq_iff_rel_eq</h4><code>∀ {α : Type u_1} {r₁ r₂ : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α}, r₁ = r₂ ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r₁ = <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r₂</code>
<div class="indent"><p>Two equivalence relations are equal iff their underlying binary operations are equal.</p>
       </div>
</div><div class="def"><a id="setoid.has_le"></a>      <h4>setoid.has_le</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#has_le">has_le</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α)</code>
<div class="indent"><p>Defining <code>≤</code> for equivalence relations.</p>
       Attributes: instance</div>
</div><div class="thm"><a id="setoid.le_def"></a>      <h4>setoid.le_def</h4><code>∀ {α : Type u_1} {r s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α}, r ≤ s ↔ ∀ {x y : α}, <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x y → <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> s x y</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="setoid.refl'"></a>      <h4>setoid.refl'</h4><code>∀ {α : Type u_1} (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α) (x : α), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x x</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="setoid.symm'"></a>      <h4>setoid.symm'</h4><code>∀ {α : Type u_1} (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α) {x y : α}, <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x y → <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r y x</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="setoid.trans'"></a>      <h4>setoid.trans'</h4><code>∀ {α : Type u_1} (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α) {x y z : α}, <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x y → <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r y z → <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x z</code>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="setoid.ker"></a>      <h4>setoid.ker</h4><code>Π {α : Type u_1} {β : Type u_2}, (α → β) → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α</code>
<div class="indent"><p>The kernel of a function is an equivalence relation.</p>
       </div>
</div><div class="thm"><a id="setoid.ker_mk_eq"></a>      <h4>setoid.ker_mk_eq</h4><code>∀ {α : Type u_1} (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient.mk">quotient.mk</a> = r</code>
<div class="indent"><p>The kernel of the quotient map induced by an equivalence relation r equals r.</p>
       Attributes: simp</div>
</div><div class="def"><a id="setoid.lattice.has_inf"></a>      <h4>setoid.lattice.has_inf</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/order/lattice.html#lattice.has_inf">lattice.has_inf</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α)</code>
<div class="indent"><p>The infimum of two equivalence relations.</p>
       Attributes: instance</div>
</div><div class="thm"><a id="setoid.inf_def"></a>      <h4>setoid.inf_def</h4><code>∀ {α : Type u_1} {r s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α}, <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> (r ⊓ s) = <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r ⊓ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> s</code>
<div class="indent"><p>The infimum of 2 equivalence relations r and s is the same relation as the infimum
   of the underlying binary operations.</p>
       </div>
</div><div class="thm"><a id="setoid.inf_iff_and"></a>      <h4>setoid.inf_iff_and</h4><code>∀ {α : Type u_1} {r s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α} {x y : α}, <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> (r ⊓ s) x y ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x y ∧ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> s x y</code>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="setoid.lattice.has_Inf"></a>      <h4>setoid.lattice.has_Inf</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.has_Inf">lattice.has_Inf</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α)</code>
<div class="indent"><p>The infimum of a set of equivalence relations.</p>
       Attributes: instance</div>
</div><div class="thm"><a id="setoid.Inf_def"></a>      <h4>setoid.Inf_def</h4><code>∀ {α : Type u_1} {s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α)}, <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.Inf">lattice.Inf</a> s) = <a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.Inf">lattice.Inf</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> '' s)</code>
<div class="indent"><p>The underlying binary operation of the infimum of a set of equivalence relations
   is the infimum of the set's image under the map to the underlying binary operation.</p>
       </div>
</div><div class="thm"><a id="setoid.Inf_le"></a>      <h4>setoid.Inf_le</h4><code>∀ {α : Type u_1} (S : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α)) (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α), r ∈ S → <a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.Inf">lattice.Inf</a> S ≤ r</code>
<div class="indent"><p>The infimum of a set of equivalence relations is contained in any element of the set.</p>
       </div>
</div><div class="thm"><a id="setoid.le_Inf"></a>      <h4>setoid.le_Inf</h4><code>∀ {α : Type u_1} (S : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α)) (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α),
  (∀ (s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α), s ∈ S → r ≤ s) → r ≤ <a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.Inf">lattice.Inf</a> S</code>
<div class="indent"><p>If an equivalence relation r is contained in every element of a set of equivalence relations,
   r is contained in the infimum of the set.</p>
       </div>
</div><div class="thm"><a id="setoid.eqv_gen_eq"></a>      <h4>setoid.eqv_gen_eq</h4><code>∀ {α : Type u_1} (r : α → α → Prop),
  <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> r = <a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.Inf">lattice.Inf</a> {s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α | ∀ (x y : α), r x y → <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> s x y}</code>
<div class="indent"><p>The inductively defined equivalence closure of a binary relation r is the infimum
   of the set of all equivalence relations containing r.</p>
       </div>
</div><div class="def"><a id="setoid.lattice.has_sup"></a>      <h4>setoid.lattice.has_sup</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/order/lattice.html#lattice.has_sup">lattice.has_sup</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α)</code>
<div class="indent"><p>The supremum of two equivalence relations, defined as the infimum of the set of
   equivalence relations containing both.</p>
       Attributes: instance</div>
</div><div class="thm"><a id="setoid.sup_eq_eqv_gen"></a>      <h4>setoid.sup_eq_eqv_gen</h4><code>∀ {α : Type u_1} (r s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α), r ⊔ s = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> (λ (x y : α), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x y ∨ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> s x y)</code>
<div class="indent"><p>The supremum of two equivalence relations r and s is the equivalence closure of the binary
   relation <code>x is related to y by r or s</code>.</p>
       </div>
</div><div class="thm"><a id="setoid.sup_def"></a>      <h4>setoid.sup_def</h4><code>∀ {α : Type u_1} {r s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α}, r ⊔ s = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r ⊔ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> s)</code>
<div class="indent"><p>The supremum of 2 equivalence relations r and s is the equivalence closure of the
   supremum of the underlying binary operations.</p>
       </div>
</div><div class="def"><a id="setoid.complete_lattice"></a>      <h4>setoid.complete_lattice</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.complete_lattice">lattice.complete_lattice</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α)</code>
<div class="indent"><p>The complete lattice of equivalence relations on a type, with bottom element <code>=</code>
   and top element the trivial equivalence relation.</p>
       Attributes: instance</div>
</div><div class="thm"><a id="setoid.Sup_eq_eqv_gen"></a>      <h4>setoid.Sup_eq_eqv_gen</h4><code>∀ {α : Type u_1} (S : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α)),
  <a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.Sup">lattice.Sup</a> S = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> (λ (x y : α), ∃ (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α), r ∈ S ∧ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x y)</code>
<div class="indent"><p>The supremum of a set S of equivalence relations is the equivalence closure of the binary
   relation <code>there exists r ∈ S relating x and y</code>.</p>
       </div>
</div><div class="thm"><a id="setoid.Sup_def"></a>      <h4>setoid.Sup_def</h4><code>∀ {α : Type u_1} {s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α)}, <a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.Sup">lattice.Sup</a> s = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.Sup">lattice.Sup</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> '' s))</code>
<div class="indent"><p>The supremum of a set of equivalence relations is the equivalence closure of the
   supremum of the set's image under the map to the underlying binary operation.</p>
       </div>
</div><div class="thm"><a id="setoid.eqv_gen_of_setoid"></a>      <h4>setoid.eqv_gen_of_setoid</h4><code>∀ {α : Type u_1} (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> setoid.r = r</code>
<div class="indent"><p>The equivalence closure of an equivalence relation r is r.</p>
       Attributes: simp</div>
</div><div class="thm"><a id="setoid.eqv_gen_idem"></a>      <h4>setoid.eqv_gen_idem</h4><code>∀ {α : Type u_1} (r : α → α → Prop), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> r)) = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> r</code>
<div class="indent"><p>Equivalence closure is idempotent.</p>
       Attributes: simp</div>
</div><div class="thm"><a id="setoid.eqv_gen_le"></a>      <h4>setoid.eqv_gen_le</h4><code>∀ {α : Type u_1} {r : α → α → Prop} {s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α},
  (∀ (x y : α), r x y → <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> s x y) → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> r ≤ s</code>
<div class="indent"><p>The equivalence closure of a binary relation r is contained in any equivalence
   relation containing r.</p>
       </div>
</div><div class="thm"><a id="setoid.eqv_gen_mono"></a>      <h4>setoid.eqv_gen_mono</h4><code>∀ {α : Type u_1} {r s : α → α → Prop},
  (∀ (x y : α), r x y → s x y) → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> r ≤ <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> s</code>
<div class="indent"><p>Equivalence closure of binary relations is monotonic.</p>
       </div>
</div><div class="def"><a id="setoid.gi"></a>      <h4>setoid.gi</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/order/galois_connection.html#galois_insertion">galois_insertion</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#eqv_gen.setoid">eqv_gen.setoid</a> <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a></code>
<div class="indent"><p>There is a Galois insertion of equivalence relations on α into binary relations
   on α, with equivalence closure the lower adjoint.</p>
       </div>
</div><div class="thm"><a id="setoid.injective_iff_ker_bot"></a>      <h4>setoid.injective_iff_ker_bot</h4><code>∀ {α : Type u_1} {β : Type u_2} (f : α → β), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> f ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> f = ⊥</code>
<div class="indent"><p>A function from α to β is injective iff its kernel is the bottom element of the complete lattice
   of equivalence relations on α.</p>
       </div>
</div><div class="thm"><a id="setoid.ker_apply_eq_preimage"></a>      <h4>setoid.ker_apply_eq_preimage</h4><code>∀ {α : Type u_1} {β : Type u_2} (f : α → β) (x : α), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> f) x = f ⁻¹' {f x}</code>
<div class="indent"><p>The elements related to x ∈ α by the kernel of f are those in the preimage of f(x) under f.</p>
       </div>
</div><div class="thm"><a id="setoid.lift_unique"></a>      <h4>setoid.lift_unique</h4><code>∀ {α : Type u_1} {β : Type u_2} {r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α} {f : α → β} (H : r ≤ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> f) (g : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient">quotient</a> r → β),
  f = g ∘ <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient.mk">quotient.mk</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient.lift">quotient.lift</a> f H = g</code>
<div class="indent"><p>The uniqueness part of the universal property for quotients of an arbitrary type.</p>
       </div>
</div><div class="thm"><a id="setoid.injective_ker_lift"></a>      <h4>setoid.injective_ker_lift</h4><code>∀ {α : Type u_1} {β : Type u_2} (f : α → β), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient.lift">quotient.lift</a> f _)</code>
<div class="indent"><p>Given a map f from α to β, the natural map from the quotient of α by the kernel of f is
   injective.</p>
       </div>
</div><div class="thm"><a id="setoid.ker_eq_lift_of_injective"></a>      <h4>setoid.ker_eq_lift_of_injective</h4><code>∀ {α : Type u_1} {β : Type u_2} {r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α} (f : α → β)
(H : ∀ (x y : α), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x y → f x = f y), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient.lift">quotient.lift</a> f H) → <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> f = r</code>
<div class="indent"><p>Given a map f from α to β, the kernel of f is the unique equivalence relation on α whose
   induced map from the quotient of α to β is injective.</p>
       </div>
</div><div class="def"><a id="setoid.quotient_ker_equiv_range"></a>      <h4>setoid.quotient_ker_equiv_range</h4><code>Π {α : Type u_1} {β : Type u_2} (f : α → β), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient">quotient</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> f) ≃ ↥(<a href="/home/rob/lean/mathlib/scripts/html_out/data/set/basic.html#set.range">set.range</a> f)</code>
<div class="indent"><p>The first isomorphism theorem for sets: the quotient of α by the kernel of a function f
   bijects with f's image.</p>
       </div>
</div><div class="def"><a id="setoid.quotient_ker_equiv_of_surjective"></a>      <h4>setoid.quotient_ker_equiv_of_surjective</h4><code>Π {α : Type u_1} {β : Type u_2} (f : α → β), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.surjective">function.surjective</a> f → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient">quotient</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> f) ≃ β</code>
<div class="indent"><p>The quotient of α by the kernel of a surjective function f bijects with f's codomain.</p>
       </div>
</div><div class="def"><a id="setoid.quotient_quotient_equiv_quotient"></a>      <h4>setoid.quotient_quotient_equiv_quotient</h4><code>Π {α : Type u_1} (r s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α) (h : r ≤ s), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient">quotient</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/quot.html#quot.map_right">quot.map_right</a> h)) ≃ <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient">quotient</a> s</code>
<div class="indent"><p>The third isomorphism theorem for sets.</p>
       </div>
</div><div class="def"><a id="setoid.map"></a>      <h4>setoid.map</h4><code>Π {α : Type u_1} {β : Type u_2} (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α) (f : α → β), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> f ≤ r → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> β</code>
<div class="indent"><p>Given a function f whose kernel is contained in an equivalence relation r, the equivalence
   closure of the relation on f's image defined by x ≈ y ↔ the elements of f⁻¹(x) are related
   to the elements of f⁻¹(y) by r.</p>
       </div>
</div><div class="def"><a id="setoid.map_of_surjective"></a>      <h4>setoid.map_of_surjective</h4><code>Π {α : Type u_1} {β : Type u_2} (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α) (f : α → β),
  <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> f ≤ r → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.surjective">function.surjective</a> f → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> β</code>
<div class="indent"><p>Given a surjective function f whose kernel is contained in an equivalence relation r, the
   equivalence relation on f's codomain defined by x ≈ y ↔ the elements of f⁻¹(x) are related to
   the elements of f⁻¹(y) by r.</p>
       </div>
</div><div class="thm"><a id="setoid.map_of_surjective_eq_map"></a>      <h4>setoid.map_of_surjective_eq_map</h4><code>∀ {α : Type u_1} {β : Type u_2} {r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α} {f : α → β} (h : <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.ker">setoid.ker</a> f ≤ r)
(hf : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.surjective">function.surjective</a> f), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.map">setoid.map</a> r f h = <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.map_of_surjective">setoid.map_of_surjective</a> r f h hf</code>
<div class="indent"><p>A special case of the equivalence closure of an equivalence relation r equalling r.</p>
       </div>
</div><div class="def"><a id="setoid.comap"></a>      <h4>setoid.comap</h4><code>Π {α : Type u_1} {β : Type u_2} {r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α}, (β → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient">quotient</a> r) → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/quot.html#quotient">quotient</a> r) → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> β</code>
<div class="indent"><p>Given an equivalence relation r on α and a map f to the quotient of α by r, an
   equivalence relation s on the quotient induces an equivalence relation on f's domain defined
   by x ≈ y ↔ f(x) is related to f(y) by s.</p>
       </div>
</div><div class="def"><a id="setoid.correspondence"></a>      <h4>setoid.correspondence</h4><code>Π {α : Type u_1} (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α), has_le.le ≃o has_le.le</code>
<div class="indent"><p>Given an equivalence relation r on α, the order-preserving bijection between the set of
   equivalence relations containing r and the equivalence relations on the quotient of α by r.</p>
       </div>
</div><div class="thm"><a id="setoid.eq_of_mem_eqv_class"></a>      <h4>setoid.eq_of_mem_eqv_class</h4><code>∀ {α : Type u_1} {c : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)},
  (∀ (a : α), ∃ (b : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α) (H : b ∈ c), a ∈ b ∧ ∀ (b' : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α), b' ∈ c → a ∈ b' → b = b') →
  ∀ {x : α} {b b' : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α}, b ∈ c → x ∈ b → b' ∈ c → x ∈ b' → b = b'</code>
<div class="indent"><p>If x ∈ α is in 2 elements of a set of sets partitioning α, those 2 sets are equal.</p>
       </div>
</div><div class="def"><a id="setoid.mk_classes"></a>      <h4>setoid.mk_classes</h4><code>Π {α : Type u_1} (c : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)),
  (∀ (a : α), ∃ (b : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α) (H : b ∈ c), a ∈ b ∧ ∀ (b' : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α), b' ∈ c → a ∈ b' → b = b') →
  <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α</code>
<div class="indent"><p>Makes an equivalence relation from a set of sets partitioning α.</p>
       </div>
</div><div class="def"><a id="setoid.classes"></a>      <h4>setoid.classes</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)</code>
<div class="indent"><p>Makes the equivalence classes of an equivalence relation.</p>
       </div>
</div><div class="thm"><a id="setoid.mem_classes"></a>      <h4>setoid.mem_classes</h4><code>∀ {α : Type u_1} (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α) (y : α), {x : α | <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r x y} ∈ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes">setoid.classes</a> r</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="setoid.eq_iff_classes_eq"></a>      <h4>setoid.eq_iff_classes_eq</h4><code>∀ {α : Type u_1} {r₁ r₂ : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α},
  r₁ = r₂ ↔ ∀ (x : α), {y : α | <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r₁ x y} = {y : α | <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> r₂ x y}</code>
<div class="indent"><p>Two equivalence relations are equal iff all their equivalence classes are equal.</p>
       </div>
</div><div class="thm"><a id="setoid.classes_inj"></a>      <h4>setoid.classes_inj</h4><code>∀ {α : Type u_1} {r₁ r₂ : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α}, r₁ = r₂ ↔ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes">setoid.classes</a> r₁ = <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes">setoid.classes</a> r₂</code>
<div class="indent"><p>Two equivalence relations are equal iff their equivalence classes are equal.</p>
       </div>
</div><div class="thm"><a id="setoid.empty_not_mem_classes"></a>      <h4>setoid.empty_not_mem_classes</h4><code>∀ {α : Type u_1} {r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α}, ∅ ∉ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes">setoid.classes</a> r</code>
<div class="indent"><p>The empty set is not an equivalence class.</p>
       </div>
</div><div class="thm"><a id="setoid.classes_eqv_classes"></a>      <h4>setoid.classes_eqv_classes</h4><code>∀ {α : Type u_1} {r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α} (a : α),
  ∃ (b : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α) (H : b ∈ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes">setoid.classes</a> r),
    a ∈ b ∧ ∀ (b' : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α), b' ∈ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes">setoid.classes</a> r → a ∈ b' → b = b'</code>
<div class="indent"><p>Equivalence classes partition the type.</p>
       </div>
</div><div class="thm"><a id="setoid.eq_of_mem_classes"></a>      <h4>setoid.eq_of_mem_classes</h4><code>∀ {α : Type u_1} {r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α} {x : α} {b : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α},
  b ∈ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes">setoid.classes</a> r → x ∈ b → ∀ {b' : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α}, b' ∈ <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes">setoid.classes</a> r → x ∈ b' → b = b'</code>
<div class="indent"><p>If x ∈ α is in 2 equivalence classes, the equivalence classes are equal.</p>
       </div>
</div><div class="thm"><a id="setoid.eq_eqv_class_of_mem"></a>      <h4>setoid.eq_eqv_class_of_mem</h4><code>∀ {α : Type u_1} {c : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)}
(H : ∀ (a : α), ∃ (b : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α) (H : b ∈ c), a ∈ b ∧ ∀ (b' : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α), b' ∈ c → a ∈ b' → b = b')
{s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α} {y : α}, s ∈ c → y ∈ s → s = {x : α | <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.mk_classes">setoid.mk_classes</a> c H) x y}</code>
<div class="indent"><p>The elements of a set of sets partitioning α are the equivalence classes of the
   equivalence relation defined by the set of sets.</p>
       </div>
</div><div class="thm"><a id="setoid.eqv_class_mem"></a>      <h4>setoid.eqv_class_mem</h4><code>∀ {α : Type u_1} {c : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)}
(H : ∀ (a : α), ∃ (b : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α) (H : b ∈ c), a ∈ b ∧ ∀ (b' : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α), b' ∈ c → a ∈ b' → b = b')
{y : α}, {x : α | <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.mk_classes">setoid.mk_classes</a> c H) x y} ∈ c</code>
<div class="indent"><p>The equivalence classes of the equivalence relation defined by a set of sets
   partitioning α are elements of the set of sets.</p>
       </div>
</div><div class="thm"><a id="setoid.eqv_classes_disjoint"></a>      <h4>setoid.eqv_classes_disjoint</h4><code>∀ {α : Type u_1} {c : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)},
  (∀ (a : α), ∃ (b : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α) (H : b ∈ c), a ∈ b ∧ ∀ (b' : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α), b' ∈ c → a ∈ b' → b = b') →
  <a href="/home/rob/lean/mathlib/scripts/html_out/data/set/lattice.html#set.pairwise_disjoint">set.pairwise_disjoint</a> c</code>
<div class="indent"><p>Distinct elements of a set of sets partitioning α are disjoint.</p>
       </div>
</div><div class="thm"><a id="setoid.eqv_classes_of_disjoint_union"></a>      <h4>setoid.eqv_classes_of_disjoint_union</h4><code>∀ {α : Type u_1} {c : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)},
  ⋃₀ c = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set.univ">set.univ</a> →
  <a href="/home/rob/lean/mathlib/scripts/html_out/data/set/lattice.html#set.pairwise_disjoint">set.pairwise_disjoint</a> c →
  ∀ (a : α), ∃ (b : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α) (H : b ∈ c), a ∈ b ∧ ∀ (b' : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α), b' ∈ c → a ∈ b' → b = b'</code>
<div class="indent"><p>A set of disjoint sets covering α partition α (classical).</p>
       </div>
</div><div class="def"><a id="setoid.setoid_of_disjoint_union"></a>      <h4>setoid.setoid_of_disjoint_union</h4><code>Π {α : Type u_1} {c : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)}, ⋃₀ c = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set.univ">set.univ</a> → <a href="/home/rob/lean/mathlib/scripts/html_out/data/set/lattice.html#set.pairwise_disjoint">set.pairwise_disjoint</a> c → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α</code>
<div class="indent"><p>Makes an equivalence relation from a set of disjoints sets covering α.</p>
       </div>
</div><div class="thm"><a id="setoid.mk_classes_classes"></a>      <h4>setoid.mk_classes_classes</h4><code>∀ {α : Type u_1} (r : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.mk_classes">setoid.mk_classes</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes">setoid.classes</a> r) <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes_eqv_classes">setoid.classes_eqv_classes</a> = r</code>
<div class="indent"><p>The equivalence relation made from the equivalence classes of an equivalence
   relation r equals r.</p>
       </div>
</div><div class="def"><a id="setoid.is_partition"></a>      <h4>setoid.is_partition</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α) → Prop</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="setoid.ne_empty_of_mem_partition"></a>      <h4>setoid.ne_empty_of_mem_partition</h4><code>∀ {α : Type u_1} {c : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)}, <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.is_partition">setoid.is_partition</a> c → ∀ {s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α}, s ∈ c → s ≠ ∅</code>
<div class="indent"><p>A partition of α does not contain the empty set.</p>
       </div>
</div><div class="thm"><a id="setoid.exists_of_mem_partition"></a>      <h4>setoid.exists_of_mem_partition</h4><code>∀ {α : Type u_1} {c : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)} (hc : <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.is_partition">setoid.is_partition</a> c) {s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α},
  s ∈ c → (∃ (y : α), s = {x : α | <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.rel">setoid.rel</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.mk_classes">setoid.mk_classes</a> c _) x y})</code>
<div class="indent"><p>All elements of a partition of α are the equivalence class of some y ∈ α.</p>
       </div>
</div><div class="thm"><a id="setoid.classes_mk_classes"></a>      <h4>setoid.classes_mk_classes</h4><code>∀ {α : Type u_1} (c : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α)) (hc : <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.is_partition">setoid.is_partition</a> c), <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.classes">setoid.classes</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.mk_classes">setoid.mk_classes</a> c _) = c</code>
<div class="indent"><p>The equivalence classes of the equivalence relation defined by a partition of α equal
   the original partition.</p>
       </div>
</div><div class="def"><a id="setoid.partition.le"></a>      <h4>setoid.partition.le</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#has_le">has_le</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.is_partition">setoid.is_partition</a>)</code>
<div class="indent"><p>Defining <code>≤</code> on partitions as the <code>≤</code> defined on their induced equivalence relations.</p>
       Attributes: instance</div>
</div><div class="def"><a id="setoid.partition.partial_order"></a>      <h4>setoid.partition.partial_order</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/algebra/order.html#partial_order">partial_order</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.is_partition">setoid.is_partition</a>)</code>
<div class="indent"><p>Defining a partial order on partitions as the partial order on their induced
   equivalence relations.</p>
       Attributes: instance</div>
</div><div class="def"><a id="setoid.partition.order_iso"></a>      <h4>setoid.partition.order_iso</h4><code>Π (α : Type u_1), has_le.le ≃o partial_order.le</code>
<div class="indent"><p>The order-preserving bijection between equivalence relations and partitions of sets.</p>
       </div>
</div><div class="def"><a id="setoid.partition.complete_lattice"></a>      <h4>setoid.partition.complete_lattice</h4><code>Π {α : Type u_1}, <a href="/home/rob/lean/mathlib/scripts/html_out/order/complete_lattice.html#lattice.complete_lattice">lattice.complete_lattice</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> <a href="/home/rob/lean/mathlib/scripts/html_out/data/setoid.html#setoid.is_partition">setoid.is_partition</a>)</code>
<div class="indent"><p>A complete lattice instance for partitions; there is more infrastructure for the
   equivalent complete lattice on equivalence relations.</p>
       Attributes: instance</div>
</div></body></html>