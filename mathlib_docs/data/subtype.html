<!DOCTYPE html><html lang="en"><head><title>data.subtype</title><meta charset="UTF-8"><link rel="stylesheet" href="/home/rob/lean/mathlib/scripts/html_out/style.css"></head><body><div class="mod_doc"><p></p>
</div><div class="thm"><a id="subtype.forall"></a>      <h4>subtype.forall</h4><code>∀ {α : Sort u_1} {p : α → Prop} {q : {a // p a} → Prop},
  (∀ (x : {a // p a}), q x) ↔ ∀ (a : α) (b : p a), q ⟨a, b⟩</code>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="subtype.forall'"></a>      <h4>subtype.forall'</h4><code>∀ {α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop},
  (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q (x.val) _</code>
<div class="indent"><p>An alternative version of <code>subtype.forall</code>. This one is useful if Lean cannot figure out <code>q</code>
 when using <code>subtype.forall</code> from right to left.</p>
       </div>
</div><div class="thm"><a id="subtype.exists"></a>      <h4>subtype.exists</h4><code>∀ {α : Sort u_1} {p : α → Prop} {q : {a // p a} → Prop},
  (∃ (x : {a // p a}), q x) ↔ ∃ (a : α) (b : p a), q ⟨a, b⟩</code>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="subtype.eq'"></a>      <h4>subtype.eq'</h4><code>∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : {x // p x}}, a1.val = a2.val → a1 = a2</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.ext"></a>      <h4>subtype.ext</h4><code>∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : {x // p x}}, a1 = a2 ↔ a1.val = a2.val</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.coe_ext"></a>      <h4>subtype.coe_ext</h4><code>∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : {x // p x}}, a1 = a2 ↔ ↑a1 = ↑a2</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.val_injective"></a>      <h4>subtype.val_injective</h4><code>∀ {α : Sort u_1} {p : α → Prop}, <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> subtype.val</code>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="subtype.restrict"></a>      <h4>subtype.restrict</h4><code>Π {α : Sort u_1} {β : α → Type u_2}, (Π (x : α), β x) → Π (p : α → Prop) (x : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p), β (x.val)</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.restrict_apply"></a>      <h4>subtype.restrict_apply</h4><code>∀ {α : Sort u_1} {β : α → Type u_2} (f : Π (x : α), β x) (p : α → Prop) (x : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p),
  <a href="/home/rob/lean/mathlib/scripts/html_out/data/subtype.html#subtype.restrict">subtype.restrict</a> f p x = f (x.val)</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.restrict_def"></a>      <h4>subtype.restrict_def</h4><code>∀ {α : Sort u_1} {β : Type u_2} (f : α → β) (p : α → Prop), <a href="/home/rob/lean/mathlib/scripts/html_out/data/subtype.html#subtype.restrict">subtype.restrict</a> f p = f ∘ subtype.val</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.restrict_injective"></a>      <h4>subtype.restrict_injective</h4><code>∀ {α : Sort u_1} {β : Type u_2} {f : α → β} (p : α → Prop),
  <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> f → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/subtype.html#subtype.restrict">subtype.restrict</a> f p)</code>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="subtype.coind"></a>      <h4>subtype.coind</h4><code>Π {α : Sort u_1} {β : Sort u_2} (f : α → β) {p : β → Prop}, (∀ (a : α), p (f a)) → α → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p</code>
<div class="indent"><p>Defining a map into a subtype, this can be seen as an "coinduction principle" of <code>subtype</code></p>
       </div>
</div><div class="thm"><a id="subtype.coind_injective"></a>      <h4>subtype.coind_injective</h4><code>∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {p : β → Prop} (h : ∀ (a : α), p (f a)),
  <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> f → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/subtype.html#subtype.coind">subtype.coind</a> f h)</code>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="subtype.map"></a>      <h4>subtype.map</h4><code>Π {α : Sort u_1} {β : Sort u_2} {p : α → Prop} {q : β → Prop} (f : α → β),
  (∀ (a : α), p a → q (f a)) → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> q</code>
<div class="indent"><p>Restriction of a function to a function on subtypes.</p>
       </div>
</div><div class="thm"><a id="subtype.map_comp"></a>      <h4>subtype.map_comp</h4><code>∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {p : α → Prop} {q : β → Prop} {r : γ → Prop}
{x : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p} (f : α → β) (h : ∀ (a : α), p a → q (f a)) (g : β → γ) (l : ∀ (a : β), q a → r (g a)),
  <a href="/home/rob/lean/mathlib/scripts/html_out/data/subtype.html#subtype.map">subtype.map</a> g l (<a href="/home/rob/lean/mathlib/scripts/html_out/data/subtype.html#subtype.map">subtype.map</a> f h x) = <a href="/home/rob/lean/mathlib/scripts/html_out/data/subtype.html#subtype.map">subtype.map</a> (g ∘ f) _ x</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.map_id"></a>      <h4>subtype.map_id</h4><code>∀ {α : Sort u_1} {p : α → Prop} {h : ∀ (a : α), p a → p (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#id">id</a> a)}, <a href="/home/rob/lean/mathlib/scripts/html_out/data/subtype.html#subtype.map">subtype.map</a> <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#id">id</a> h = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#id">id</a></code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.map_injective"></a>      <h4>subtype.map_injective</h4><code>∀ {α : Sort u_1} {β : Sort u_2} {p : α → Prop} {q : β → Prop} {f : α → β}
(h : ∀ (a : α), p a → q (f a)), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> f → <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/data/subtype.html#subtype.map">subtype.map</a> f h)</code>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="subtype.has_equiv"></a>      <h4>subtype.has_equiv</h4><code>Π {α : Sort u_1} [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#has_equiv">has_equiv</a> α] (p : α → Prop), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#has_equiv">has_equiv</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p)</code>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="thm"><a id="subtype.equiv_iff"></a>      <h4>subtype.equiv_iff</h4><code>∀ {α : Sort u_1} [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#has_equiv">has_equiv</a> α] {p : α → Prop} {s t : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p}, s ≈ t ↔ s.val ≈ t.val</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.refl"></a>      <h4>subtype.refl</h4><code>∀ {α : Sort u_1} {p : α → Prop} [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α] (s : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p), s ≈ s</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.symm"></a>      <h4>subtype.symm</h4><code>∀ {α : Sort u_1} {p : α → Prop} [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α] {s t : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p}, s ≈ t → t ≈ s</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.trans"></a>      <h4>subtype.trans</h4><code>∀ {α : Sort u_1} {p : α → Prop} [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α] {s t u : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p}, s ≈ t → t ≈ u → s ≈ u</code>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="subtype.equivalence"></a>      <h4>subtype.equivalence</h4><code>∀ {α : Sort u_1} [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α] (p : α → Prop), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#equivalence">equivalence</a> has_equiv.equiv</code>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="subtype.setoid"></a>      <h4>subtype.setoid</h4><code>Π {α : Sort u_1} [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> α] (p : α → Prop), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/setoid.html#setoid">setoid</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#subtype">subtype</a> p)</code>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="thm"><a id="subtype.coe_eta"></a>      <h4>subtype.coe_eta</h4><code>∀ {α : Type u_1} {p : α → Prop} (a : {a // p a}) (h : p ↑a), ⟨↑a, h⟩ = a</code>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="subtype.coe_mk"></a>      <h4>subtype.coe_mk</h4><code>∀ {α : Type u_1} {p : α → Prop} (a : α) (h : p a), ↑⟨a, h⟩ = a</code>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="subtype.mk_eq_mk"></a>      <h4>subtype.mk_eq_mk</h4><code>∀ {α : Type u_1} {p : α → Prop} {a : α} {h : p a} {a' : α} {h' : p a'}, ⟨a, h⟩ = ⟨a', h'⟩ ↔ a = a'</code>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="subtype.val_prop"></a>      <h4>subtype.val_prop</h4><code>∀ {α : Type u_1} {S : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α} (a : {a // a ∈ S}), a.val ∈ S</code>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="subtype.val_prop'"></a>      <h4>subtype.val_prop'</h4><code>∀ {α : Type u_1} {S : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> α} (a : {a // a ∈ S}), ↑a ∈ S</code>
<div class="indent"><p></p>
       Attributes: simp</div>
</div></body></html>