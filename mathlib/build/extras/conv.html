<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="https://robertylewis.com/mathlib//css/lean.css" >
  <link rel="shortcut icon" href="https://robertylewis.com/mathlib//img/favicon.ico">
	<link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Merriweather:700">
    

	<script>
                function buildShortcutsForStructures(names) {
                        const o = {}
                        names.forEach(name => o[name] = `\\mathbb\{${name}\}`)
                        return o
                }
		MathJax = {
			  tex: {
                                  macros: {
                                          ...buildShortcutsForStructures(["R", "Q", "Z", "N", "C"]),
                                  },
				      inlineMath: [['$', '$'], ['\\(', '\\)']]
				    },
		};
	</script>
	<script type="text/javascript" id="MathJax-script" async
		  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>

	<title>The conversion tactic mode</title>
  </head>
  <body>
  <div id="wrapper">
  <nav class="navbar navbar-expand-lg navbar-light bg-gradient-light d-md-none">
    <div class="d-flex flex-grow-1">
		<a class="navbar-brand" href="https://robertylewis.com/mathlib/index.html">Lean Community
    </a>
    </div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </nav>
  <div class="container-fluid"><div class="row">
    <nav id="navbar" class="col-md-3 col-xl-2 d-md-block bg-light sidebar collapse navbar navbar-light pb-4">
      <div class="d-sm-none d-md-block"><a class="navbar-brand" href="https://robertylewis.com/mathlib/index.html">Lean Community</a></div>
      <div>
        <h6 class="sidebar-heading px-3 mt-4 mb-1">Installation</h6>
        <ul class="nav flex-column">
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/get_started.html">Get started</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/install/linux.html">Linux installation</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/install/debian.html">Debian installation</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/install/macos.html">MacOS installation</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/install/windows.html">Windows installation</a></li>
        
          <li class="nav-item"><a href="https://leanprover-community.github.io/lean-web-editor">Online version (no installation)</a></li>
        </ul>
      </div><div>
        <h6 class="sidebar-heading px-3 mt-4 mb-1">Documentation</h6>
        <ul class="nav flex-column">
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/learn.html">Big list of docs (start here)</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/extras/calc.html">calc mode</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/extras/conv.html">conv mode</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/extras/simp.html">simplifier</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/extras/tactic_writing.html">tactic writing tutorial</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/extras/well_founded_recursion.html">well-founded recursion</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/leanproject.html">leanproject</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/toolchain.html">How pieces fit together</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/mwe.html">About MWEs</a></li>
        
          <li class="nav-item"><a href="https://leanprover-community.github.io/mathlib_docs">API documentation</a></li>
        </ul>
      </div><div>
        <h6 class="sidebar-heading px-3 mt-4 mb-1">Library overviews</h6>
        <ul class="nav flex-column">
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/mathlib-overview.html">Library overview</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/100.html">Wiedijk's 100 theorems</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/undergrad.html">Undergraduate maths</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/lean_projects.html">Other Lean projects</a></li>
        </ul>
      </div><div>
        <h6 class="sidebar-heading px-3 mt-4 mb-1">Theory docs</h6>
        <ul class="nav flex-column">
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/theories/category_theory.html">Category theory</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/theories/linear_algebra.html">Linear algebra</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/theories/naturals.html">Natural numbers</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/theories/padics.html">p-adic numbers</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/theories/sets.html">Sets and set-like objects</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/theories/topology.html">Topology</a></li>
        </ul>
      </div><div>
        <h6 class="sidebar-heading px-3 mt-4 mb-1">Contributing</h6>
        <ul class="nav flex-column">
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/contribute/index.html">Pull request lifecycle</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/contribute/naming.html">Naming conventions</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/contribute/style.html">Code style guideline</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/contribute/doc.html">Documentation style</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/ci.html">CI for 3rd party projects</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/mathlib_stats.html">Contribution statistics</a></li>
        </ul>
      </div><div>
        <h6 class="sidebar-heading px-3 mt-4 mb-1">Community</h6>
        <ul class="nav flex-column">
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/meet.html">Maintainers</a></li>
        
          <li class="nav-item"><a href="https://robertylewis.com/mathlib/papers.html">Papers about Lean</a></li>
        
          <li class="nav-item"><a href="https://leanprover.zulipchat.com/">Zulip chat</a></li>
        </ul>
      </div>
    </nav>
  <main class="col-md-9 col-xl-8 px-md-4">
    <div class="mt-5 mx-auto" style="max-width: 60em">
	  
<h1 id="the-conversion-tactic-mode" class="markdown-heading">The conversion tactic mode <a class="hover-link" href="#the-conversion-tactic-mode">#</a></h1>
<p>Inside a tactic block, one can use the keyword <code>conv</code> to enter conversion
mode. This mode allows to travel inside assumptions and goals, even
inside <code>λ</code> binders in them, to apply rewriting or simplifying steps.</p>
<p>This is similar to the conversion tacticals (tactic combinators) found in
other theorem provers like HOL4, HOL Light or Isabelle.</p>
<h2 id="basic-navigation-and-rewriting" class="markdown-heading">Basic navigation and rewriting <a class="hover-link" href="#basic-navigation-and-rewriting">#</a></h2>
<p>As a first example, let us prove
<code>example (a b c : ℕ) : a * (b * c) = a * (c * b)</code> (examples in this file
are somewhat artificial since the <code>ring</code> tactic from
<code>tactic.ring</code> could finish them immediately). The naive first attempt is
to enter tactic mode and try <code>rw mul_comm</code>. But this transforms the goal
into <code>b * c * a = a * (c * b)</code>, after commuting the very first
multiplication appearing in the term. There are several ways to fix this
issue, and one way is to use a more precise tool : the
conversion mode.  The following code block shows the current target after
each line. Note that the target is prefixed by <code>|</code> where normal mode
shows a goal prefixed by <code>⊢</code> (these targets are still called &quot;goals&quot;
though).</p>
<div class="highlight"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">conv</span>
  <span class="k">begin</span>          <span class="c1">-- | a * (b * c) = a * (c * b)</span>
    <span class="n">to_lhs</span><span class="o">,</span>      <span class="c1">-- | a * (b * c)</span>
    <span class="n">congr</span><span class="o">,</span>       <span class="c1">-- 2 goals : | a and | b * c</span>
    <span class="n">skip</span><span class="o">,</span>        <span class="c1">-- | b * c</span>
    <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="c1">-- | c * b</span>
  <span class="kn">end</span>
<span class="kn">end</span>
</pre></div>

<p>The above snippet show three navigation commands:</p>
<ul>
<li><code>to_lhs</code> navigates to the left hand side of a relation (here
equality), there is also a <code>to_rhs</code> navigating to the right hand side.</li>
<li><code>congr</code> creates as many targets as there are arguments to the current
head function (here the head function is multiplication)</li>
<li><code>skip</code> goes to the next target</li>
</ul>
<p>Once arrived at the relevant target, we can use <code>rw</code> as in normal mode.
Note that Lean tries to solves the current goal if it became <code>x = x</code> (in
the strict syntactical sense, definitional equality is not enough: one
needs to conclude by <code>refl</code> or <code>trivial</code> in this case).</p>
<p>The second main reason to use conversion mode is to rewrite under
binders. Suppose we want to prove <code>example (λ x : ℕ, 0+x) = (λ x, x)</code>.
The naive first attempt is to enter tactic mode and try <code>rw zero_add</code>.
But this fails with a frustrating</p>
<div class="highlight"><pre><span></span>rewrite tactic failed, did not find
instance of the pattern in the target expression 0 + ?m_3
state:
⊢ (λ (x : ℕ), 0 + x) = λ (x : ℕ), x
</pre></div>

<p>The solution is:</p>
<div class="highlight"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">conv</span>
  <span class="k">begin</span>           <span class="c1">-- | (λ (x : ℕ), 0 + x) = λ (x : ℕ), x</span>
    <span class="n">to_lhs</span><span class="o">,</span>       <span class="c1">-- | λ (x : ℕ), 0 + x</span>
    <span class="n">funext</span><span class="o">,</span>       <span class="c1">-- | 0 + x</span>
    <span class="n">rw</span> <span class="n">zero_add</span><span class="o">,</span>  <span class="c1">-- | x</span>
  <span class="kn">end</span>
<span class="kn">end</span>
</pre></div>

<p>where <code>funext</code> is the navigation command entering inside the <code>λ</code> binder.
Note that this example is somewhat artificial, one could also do:</p>
<div class="highlight"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">0</span><span class="bp">+</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">funext</span> <span class="bp">;</span> <span class="n">rw</span> <span class="n">zero_add</span>
</pre></div>

<p>All this is also available to rewrite an hypothesis <code>H</code> from the local context
using <code>conv at H</code>.</p>
<h2 id="pattern-matching" class="markdown-heading">Pattern matching <a class="hover-link" href="#pattern-matching">#</a></h2>
<p>Navigation using the above commands can be tedious. One can shortcut it
using pattern matching as follows:</p>
<div class="highlight"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">conv</span> <span class="k">in</span> <span class="o">(</span><span class="n">b</span><span class="bp">*</span><span class="n">c</span><span class="o">)</span>
<span class="k">begin</span>          <span class="c1">-- | b * c</span>
  <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="c1">-- | c * b</span>
<span class="kn">end</span>
<span class="kn">end</span>
</pre></div>

<p>As usual, <code>begin</code> and <code>end</code> can be replaced by curly brackets to
delimit conversion mode and a single tactic invocation can be introduced
by <code>by</code> to get the one liner:</p>
<div class="highlight"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">conv</span> <span class="k">in</span> <span class="o">(</span><span class="n">b</span><span class="bp">*</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">}</span>
</pre></div>

<p>Beware that a well known bug makes Lean printing: &quot;find converter
failed, pattern was not found&quot; when the tactics inside conversion mode
fail, even if the pattern was actually found.</p>
<p>Of course wild-cards are allowed:</p>
<div class="highlight"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">conv</span> <span class="k">in</span> <span class="o">(</span><span class="bp">_</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">}</span>
</pre></div>

<p>In all those cases, only the first match is affected.
A more sophisticated version of pattern matching is available inside
conversion mode using the <code>for</code> command. The following performs rewriting
only for the second and third occurrences of <code>b * c</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span>  <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">):=</span>
<span class="k">by</span> <span class="n">conv</span> <span class="o">{</span> <span class="n">for</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">}</span> <span class="o">}</span>
</pre></div>

<h2 id="other-tactics-inside-conversion-mode" class="markdown-heading">Other tactics inside conversion mode <a class="hover-link" href="#other-tactics-inside-conversion-mode">#</a></h2>
<p>Besides rewriting using <code>rw</code>, one can use <code>simp</code>, <code>dsimp</code>, <code>change</code> and <code>whnf</code>.
<code>change</code> is a useful tool -- it allows changing a term to something
definitionally equal, rather like the <code>show</code> command in tactic mode.
The <code>whnf</code> command means &quot;reduces to weak head normal form&quot; and will eventually
be explained in <a href="https://leanprover.github.io/programming_in_lean/#08_Writing_Tactics.html">Programming in Lean</a> section 8.4.</p>
<p>Extensions to <code>conv</code> provided by mathlib, such as <code>ring</code> and <code>norm_num</code>, can be
found in the <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#conv">mathlib docs</a>.</p>

    </div>
  </main>
  </div></div>
</div>

  <nav class="footer navbar navbar-expand-lg navbar-light bg-light justify-content-end">
  <ul class="nav">
    <li class="nav-item">
      <a class="nav-link active" href="https://github.com/leanprover-community/leanprover-community.github.io/blob/newsite/templates/extras/conv.md">Suggest edits to this page on GitHub</a>
    </li>
  </ul>
</nav>

    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://robertylewis.com/mathlib//js/bootstrap.min.js"></script>
    
  </body>
</html>