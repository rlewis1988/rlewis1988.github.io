<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/pages-test/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/pages-test/" rel="alternate" type="text/html" /><updated>2021-06-09T13:08:17-07:00</updated><id>http://localhost:4000/pages-test/feed.xml</id><title type="html">Robert Y. Lewis</title><subtitle>personal description</subtitle><author><name>Robert Y. Lewis</name><email>robert_lewis@brown.edu</email></author><entry><title type="html">Formalizing the Ring of Witt Vectors</title><link href="http://localhost:4000/pages-test/lean/witt-vectors/" rel="alternate" type="text/html" title="Formalizing the Ring of Witt Vectors" /><published>2020-10-07T02:30:00-07:00</published><updated>2020-10-07T02:30:00-07:00</updated><id>http://localhost:4000/pages-test/lean/witt-vectors</id><content type="html" xml:base="http://localhost:4000/pages-test/lean/witt-vectors/">&lt;p&gt;Johan Commelin and I have released a preprint of our new paper,
&lt;a href=&quot;http://robertylewis.com/files/witt-vectors.pdf&quot;&gt;Formalizing the Ring of Witt Vectors&lt;/a&gt;!
(Update, Nov 25: the paper has been accepted at &lt;a href=&quot;https://popl21.sigplan.org/home/CPP-2021#event-overview&quot;&gt;CPP ‘21&lt;/a&gt;.)
We describe the construction of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Witt_vector&quot;&gt;p-typical Witt vectors&lt;/a&gt;
and their ring structure in Lean, and show that the ring of Witt vectors over the integers modulo p
is isomorphic to the ring of p-adic integers.&lt;/p&gt;

&lt;p&gt;Witt vectors are a notoriously messy topic to cover informally.
The ring structure depends on a layer of definitions binding certain polynomials together.
Without caution, trying to prove things about this ring structure can lead to unfolding
horrible polynomial identities that are both intractable and unenlightening.&lt;/p&gt;

&lt;p&gt;Johan and I developed a framework in Lean to vastly simplify these calculations.
The horror is minimized and neatly contained in one or two preliminary proofs;
after that, some simple Lean metaprograms are able to handle these calculations cleanly and uniformly.&lt;/p&gt;</content><author><name>Robert Y. Lewis</name><email>robert_lewis@brown.edu</email></author><category term="lean" /><summary type="html">Johan Commelin and I have released a preprint of our new paper, Formalizing the Ring of Witt Vectors! (Update, Nov 25: the paper has been accepted at CPP ‘21.) We describe the construction of the p-typical Witt vectors and their ring structure in Lean, and show that the ring of Witt vectors over the integers modulo p is isomorphic to the ring of p-adic integers.</summary></entry><entry><title type="html">Metaprogramming in Lean tutorial</title><link href="http://localhost:4000/pages-test/lean/metaprogramming/" rel="alternate" type="text/html" title="Metaprogramming in Lean tutorial" /><published>2020-07-13T02:30:00-07:00</published><updated>2020-07-13T02:30:00-07:00</updated><id>http://localhost:4000/pages-test/lean/metaprogramming</id><content type="html" xml:base="http://localhost:4000/pages-test/lean/metaprogramming/">&lt;p&gt;Johan Commelin and Patrick Massot are organizing the workshop 
&lt;a href=&quot;https://leanprover-community.github.io/lftcm2020/&quot;&gt;Lean for the Curious Mathematician&lt;/a&gt;,
taking place virtually July 13-17, 2020.
The workshop aims to give working mathematicians
a hands-on introduction to formal proof.&lt;/p&gt;

&lt;p&gt;As part of the “intermediate track” of this workshop,
for users who have some experience with formal proof,
I recorded a &lt;a href=&quot;https://www.youtube.com/playlist?list=PLlF-CfQhukNnq2kDCw2P_vI5AfXN7egP2&quot;&gt;series of videos&lt;/a&gt;
about metaprogramming in Lean:
how do we use the system to introspect on its own syntax
and write and evaluate programs to prove theorems?&lt;/p&gt;

&lt;p&gt;Since the workshop is aimed at a novice audience,
I wasn’t expecting a large live audience,
so I prerecorded the videos and put them on YouTube. 
The first two videos in the series are accessible to people 
who have had any introduction to Lean, for instance through the &lt;a href=&quot;https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/&quot;&gt;Natural Number Game&lt;/a&gt;.
The later videos assume some more familiarity with the system 
and with functional programming.&lt;/p&gt;

&lt;p&gt;Feedback on these recordings is very welcome!&lt;/p&gt;</content><author><name>Robert Y. Lewis</name><email>robert_lewis@brown.edu</email></author><category term="lean" /><summary type="html">Johan Commelin and Patrick Massot are organizing the workshop Lean for the Curious Mathematician, taking place virtually July 13-17, 2020. The workshop aims to give working mathematicians a hands-on introduction to formal proof.</summary></entry><entry><title type="html">Logic and Modeling course information</title><link href="http://localhost:4000/pages-test/teaching/logic-modeling/" rel="alternate" type="text/html" title="Logic and Modeling course information" /><published>2020-07-05T02:30:00-07:00</published><updated>2020-07-05T02:30:00-07:00</updated><id>http://localhost:4000/pages-test/teaching/logic-modeling</id><content type="html" xml:base="http://localhost:4000/pages-test/teaching/logic-modeling/">&lt;p&gt;In Spring 2020, I taught the course Logic and Modeling at the VU.
The course was held entirely online due to the COVID-19 pandemic.&lt;/p&gt;

&lt;p&gt;I have collected the course information, lecture recordings, and assignments
&lt;a href=&quot;http://localhost:4000/logic_and_modeling&quot;&gt;here&lt;/a&gt;.
(While the archive does not contain all the information that was on Canvas,
it contains most of the material fit for public consumption.)&lt;/p&gt;

&lt;p&gt;Instructors interested in teaching with the &lt;a href=&quot;http://avigad.github.io/logic_and_proof/&quot;&gt;Logic and Proof&lt;/a&gt; text
may find the recorded lectures of some use!&lt;/p&gt;</content><author><name>Robert Y. Lewis</name><email>robert_lewis@brown.edu</email></author><category term="teaching" /><summary type="html">In Spring 2020, I taught the course Logic and Modeling at the VU. The course was held entirely online due to the COVID-19 pandemic.</summary></entry><entry><title type="html">The Lean mathematical library</title><link href="http://localhost:4000/pages-test/lean/mathlib-paper/" rel="alternate" type="text/html" title="The Lean mathematical library" /><published>2019-10-21T05:30:00-07:00</published><updated>2019-10-21T05:30:00-07:00</updated><id>http://localhost:4000/pages-test/lean/mathlib-paper</id><content type="html" xml:base="http://localhost:4000/pages-test/lean/mathlib-paper/">&lt;p&gt;Along with a number of other contributors, I have written &lt;a href=&quot;https://leanprover-community.github.io/papers/mathlib-paper.pdf&quot;&gt;a paper&lt;/a&gt; about the Lean mathematical library. The paper describes a large-scale, open project to which 68 people (and counting) have contributed. Rather than attribute the paper to some subset of this group, we decided to release it as a community effort. (Update, Nov 28: our paper has been accepted at &lt;a href=&quot;https://popl20.sigplan.org/home/CPP-2020&quot;&gt;CPP&lt;/a&gt;!)&lt;/p&gt;

&lt;p&gt;A huge amount of work has gone into building &lt;a href=&quot;https://github.com/leanprover-community/mathlib&quot;&gt;mathlib&lt;/a&gt; and it’s great to see it documented. One aspect of the project that we emphasize in the paper is the collaboration between people with different academic backgrounds and interests. Using mathlib is pleasant because it’s designed to support many people doing different things. Mathematics is a heterogeneous field, and many practicing mathematicians (let alone computer scientists) see only a small fragment of it. If our aim is to develop a system, library, and environment to accommodate mathematics, broadly speaking, we need participants from all corners.&lt;/p&gt;</content><author><name>Robert Y. Lewis</name><email>robert_lewis@brown.edu</email></author><category term="lean" /><summary type="html">Along with a number of other contributors, I have written a paper about the Lean mathematical library. The paper describes a large-scale, open project to which 68 people (and counting) have contributed. Rather than attribute the paper to some subset of this group, we decided to release it as a community effort. (Update, Nov 28: our paper has been accepted at CPP!)</summary></entry><entry><title type="html">Formalizing the solution to the cap set problem</title><link href="http://localhost:4000/pages-test/lean/cap-set/" rel="alternate" type="text/html" title="Formalizing the solution to the cap set problem" /><published>2019-06-09T05:30:00-07:00</published><updated>2019-06-09T05:30:00-07:00</updated><id>http://localhost:4000/pages-test/lean/cap-set</id><content type="html" xml:base="http://localhost:4000/pages-test/lean/cap-set/">&lt;p&gt;&lt;a href=&quot;http://www.few.vu.nl/~sdn249/&quot;&gt;Sander Dahmen&lt;/a&gt;, &lt;a href=&quot;https://www.cs.vu.nl/~jhl890/&quot;&gt;Johannes Hölzl&lt;/a&gt;, and
I have formalized &lt;a href=&quot;https://arxiv.org/abs/1605.09223&quot;&gt;Ellenberg and Gijswijt’s solution to the cap set
problem&lt;/a&gt; in Lean. &lt;a href=&quot;https://lean-forward.github.io/e-g/&quot;&gt;Our paper about this
project&lt;/a&gt; will appear at ITP 2019. &lt;a href=&quot;http://localhost:4000/files/capset_long_slides.pdf&quot;&gt;Here are some
slides&lt;/a&gt; from a talk I gave about this formalization.&lt;/p&gt;

&lt;p&gt;The cap set problem is a combinatorial question, easy to ask but difficult to answer. Briefly, it
asks about the growth rate of the cardinality of &lt;em&gt;cap sets&lt;/em&gt;, subsets of a group that contain no
three-term arithmetic progression, as the dimension of the underlying space increases. Ellenberg and
Gijswijt discovered a solution in 2016; their celebrated proof appeared in the &lt;em&gt;Annals of
Mathematics&lt;/em&gt; in 2017. The approach that Ellenberg and Gijswijt take is an extremely clever
application of elementary methods, which makes it a good candidate to formalize.&lt;/p&gt;

&lt;p&gt;Very little cutting-edge mathematics is formalized in proof assistants. Reasons for this are
well-documented throughout the literature: the costs are too high; the tools and infrastructure are
not ready; the general expertise isn’t there. The &lt;a href=&quot;https://lean-forward.github.io&quot;&gt;Lean Forward
project&lt;/a&gt; aims to change this, by spurring collaboration between tool
developers, formalizers, and mathematicians. Our project is a step toward these goals. Admittedly,
our choice of a formalization target is uniquely accessible. But this gives us a first data point
for Lean Forward: at least one modern, noteworthy paper in mathematics can be formalized with a
reasonable amount of time and effort.&lt;/p&gt;

&lt;p&gt;Lean Forward emphasizes that collaboration between people from different areas is needed to bring
formalized mathematics to the mainstream. Our project is an example of exactly this kind of
collaboration. We need mathematicians, computer scientists, engineers, and people in between to come
together to make
&lt;a href=&quot;http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/wiedijk_2.pdf&quot;&gt;lofty&lt;/a&gt;,
&lt;a href=&quot;https://formalabstracts.github.io/&quot;&gt;ambitious&lt;/a&gt; formalization projects into reality.&lt;/p&gt;</content><author><name>Robert Y. Lewis</name><email>robert_lewis@brown.edu</email></author><category term="lean" /><summary type="html">Sander Dahmen, Johannes Hölzl, and I have formalized Ellenberg and Gijswijt’s solution to the cap set problem in Lean. Our paper about this project will appear at ITP 2019. Here are some slides from a talk I gave about this formalization.</summary></entry><entry><title type="html">Lean Together 2019</title><link href="http://localhost:4000/pages-test/lean/conference/lean-together/" rel="alternate" type="text/html" title="Lean Together 2019" /><published>2019-01-25T13:05:33-08:00</published><updated>2019-01-25T13:05:33-08:00</updated><id>http://localhost:4000/pages-test/lean/conference/lean-together</id><content type="html" xml:base="http://localhost:4000/pages-test/lean/conference/lean-together/">&lt;p&gt;From the 7th to the 11th of January, 2019, we hosted a workshop &lt;a href=&quot;https://lean-forward.github.io/lean-together/&quot;&gt;Lean
Together&lt;/a&gt; in Amsterdam. This workshop was meant to
serve a few purposes. First, it was a meeting for Lean developers and users who have been working
remotely on the system and &lt;a href=&quot;https://leanprover-community.github.io/&quot;&gt;mathematics libraries&lt;/a&gt;. Second,
it was a kickoff party for Jasmin Blanchette’s &lt;a href=&quot;https://lean-forward.github.io/&quot;&gt;Lean Forward&lt;/a&gt; NWO
project. A key part of this project is “mathematical outreach”; we want to put proof assistants in
the hands of mathematicians, and through collaboration with computer scientists, advance the world
of formal mathematics.&lt;/p&gt;

&lt;p&gt;The workshop was an incredible success on both fronts. When we started planning in July, we expected
to have around 30 participants; we ended up with 68 people registered. Amazingly, 29 self-identified
their primary discipline as mathematics, and 29 as computer science. (Nine chose the
“multidisciplinary” option and one wrote in “logic.”) It was great to meet more of the Lean crowd in
person, and equally great to see the crowd eager novice formalizers.&lt;/p&gt;

&lt;p&gt;We’re still feeling the momentum from this meeting and we hope to keep things rolling. Watch out for
an announcement about Lean Together 2020: this time, it’s in Pittsburgh.&lt;/p&gt;</content><author><name>Robert Y. Lewis</name><email>robert_lewis@brown.edu</email></author><category term="lean" /><category term="conference" /><summary type="html">From the 7th to the 11th of January, 2019, we hosted a workshop Lean Together in Amsterdam. This workshop was meant to serve a few purposes. First, it was a meeting for Lean developers and users who have been working remotely on the system and mathematics libraries. Second, it was a kickoff party for Jasmin Blanchette’s Lean Forward NWO project. A key part of this project is “mathematical outreach”; we want to put proof assistants in the hands of mathematicians, and through collaboration with computer scientists, advance the world of formal mathematics.</summary></entry><entry><title type="html">A formal proof of Hensel’s lemma over the p-adic integers</title><link href="http://localhost:4000/pages-test/padics/index.html" rel="alternate" type="text/html" title="A formal proof of Hensel’s lemma over the p-adic integers" /><published>2018-10-18T02:00:00-07:00</published><updated>2018-10-18T02:00:00-07:00</updated><id>http://localhost:4000/pages-test/padics/hensels-lemma</id><content type="html" xml:base="http://localhost:4000/pages-test/padics/index.html">&lt;p&gt;Here you will find the supplementary materials to &lt;a href=&quot;padics.pdf&quot;&gt;my paper&lt;/a&gt; &lt;em&gt;A formal proof of Hensel’s
lemma over the p-adic integers&lt;/em&gt;. This paper was published at CPP 2019. For more information, contact
&lt;a href=&quot;mailto:r.y.lewis@vu.nl&quot;&gt;Robert Y. Lewis&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;the-formal-development&quot;&gt;The Formal Development&lt;/h3&gt;

&lt;p&gt;The project described in the linked paper has been incorporated into the Lean
&lt;a href=&quot;https://github.com/leanprover/mathlib/&quot;&gt;mathlib&lt;/a&gt; repository. The current state of the p-adic number
development can be found in the directory
&lt;a href=&quot;https://github.com/leanprover/mathlib/tree/master/src/data/padics&quot;&gt;/data/padics/&lt;/a&gt;. See also the pull
requests &lt;a href=&quot;https://github.com/leanprover/mathlib/pull/337&quot;&gt;here&lt;/a&gt; and
&lt;a href=&quot;https://github.com/leanprover/mathlib/pull/262&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since mathlib is regularly updated, we preserve a branch
&lt;a href=&quot;https://github.com/robertylewis/mathlib/tree/padics_paper&quot;&gt;here&lt;/a&gt; that shows its state when this
paper was written.&lt;/p&gt;</content><author><name>Robert Y. Lewis</name><email>robert_lewis@brown.edu</email></author><category term="paper" /><summary type="html">Here you will find the supplementary materials to my paper A formal proof of Hensel’s lemma over the p-adic integers. This paper was published at CPP 2019. For more information, contact Robert Y. Lewis. The Formal Development The project described in the linked paper has been incorporated into the Lean mathlib repository. The current state of the p-adic number development can be found in the directory /data/padics/. See also the pull requests here and here. Since mathlib is regularly updated, we preserve a branch here that shows its state when this paper was written.</summary></entry><entry><title type="html">A bi-directional extensible interface between Lean and Mathematica</title><link href="http://localhost:4000/pages-test/leanmm/index.html" rel="alternate" type="text/html" title="A bi-directional extensible interface between Lean and Mathematica" /><published>2018-02-06T01:00:00-08:00</published><updated>2018-02-06T01:00:00-08:00</updated><id>http://localhost:4000/pages-test/leanmm/mathematica</id><content type="html" xml:base="http://localhost:4000/pages-test/leanmm/index.html">&lt;p&gt;Minchao Wu and I have been working on a project that connects the computer algebra system
Mathematica to the Lean theorem prover. Here you will find the supplementary materials corresponding
to &lt;a href=&quot;lean_mm.pdf&quot;&gt;our paper draft&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;An &lt;a href=&quot;https://arxiv.org/abs/1712.09288&quot;&gt;early version of this work&lt;/a&gt; was presented at PxTP.
For more information, contact &lt;a href=&quot;https://robertylewis.com&quot;&gt;Robert Y.
Lewis&lt;/a&gt; and &lt;a href=&quot;mailto:logic.mcwu@gmail.com&quot;&gt;Minchao Wu&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;versioning&quot;&gt;Versioning&lt;/h2&gt;

&lt;p&gt;These tools and examples are compatible with various versions of Lean.
In any of the GitHub repositories, look for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lean-x.y.z&lt;/code&gt; branch
for a version of the project compatible with Lean x.y.z.
The core tool will automatically be updated to new versions of Lean
as long as compatibility is maintained.
Unfortunately this automatic upgrading is not possible for the example repositories
due to licensing issues,
but we will do it manually;
please contact the authors if you need a fresh update on short notice,
or try running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leanproject up&lt;/code&gt; yourself.&lt;/p&gt;

&lt;p&gt;The link is known to work with Mathematica versions 11 and 12,
and perhaps with earlier versions.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lean-3.17.1&lt;/code&gt; branches, and any below, are frozen as of August 19, 2020.
All claims in our paper draft have been tested to be true of this version,
and we have not intentionally falsified any in later versions.&lt;/p&gt;

&lt;h2 id=&quot;installing-the-link&quot;&gt;Installing the link&lt;/h2&gt;

&lt;p&gt;The link requires you to have Python installed with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python3&lt;/code&gt; in the system path.&lt;/p&gt;

&lt;p&gt;We strongly recommend installing Lean with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elan&lt;/code&gt; version manager
and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leanproject&lt;/code&gt; supporting tool,
following &lt;a href=&quot;https://leanprover-community.github.io/get_started.html#regular-install&quot;&gt;the “regular install” instructions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The core tool for using Mathematica from Lean is available on
&lt;a href=&quot;https://github.com/rlewis1988/mathematica&quot;&gt;GitHub&lt;/a&gt;. This project can be added as a dependency to
any Lean project using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leanpkg&lt;/code&gt; package manager.
Note that, if you install the project as a dependency using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leanpkg&lt;/code&gt;,
you do not need to download it separately.
It will be downloaded automatically to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_target/deps/mathematica&lt;/code&gt; directory of your project.&lt;/p&gt;

&lt;p&gt;To use the link in this direction, you must start the Mathematica server. Do this either by&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;math --noprompt -run '&amp;lt;&amp;lt;&quot;server2.m&quot;&lt;/code&gt;
in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_target/deps/mathematica/src&lt;/code&gt; directory of your project, or&lt;/li&gt;
  &lt;li&gt;opening the Mathematica frontend and evaluating &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&quot;/path/to/_target/deps/mathematica/src/server2.m&quot;&lt;/code&gt;
(with the correct path).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The code for using Lean from Mathematica is also available on
&lt;a href=&quot;https://github.com/minchaowu/mm_lean&quot;&gt;GitHub&lt;/a&gt;. This project uses the above as a dependency.
See directions below for using it.&lt;/p&gt;

&lt;h2 id=&quot;examples-of-calling-mathematica-from-lean&quot;&gt;Examples of calling Mathematica from Lean&lt;/h2&gt;

&lt;p&gt;A project containing examples of the Mathematica-from-Lean link in action is available
&lt;a href=&quot;https://github.com/rlewis1988/mathematica_examples&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The easiest way to try this out is to download the project using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leanproject&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leanproject get robertylewis/mathematica_examples
cd mathematica_examples/_target/deps/mathematica/src
math --noprompt -run '&amp;lt;&amp;lt;&quot;server2.m&quot;'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will download the core link, the examples,
Lean’s mathematical library mathlib (on which the examples depend),
and precompiled binaries for mathlib.
If you use an alternate installation method, you may have to compile mathlib yourself,
which can take a long time.&lt;/p&gt;

&lt;p&gt;You can then see the link in action in any file in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mathematica_examples/src&lt;/code&gt;.
&lt;strong&gt;Note&lt;/strong&gt;: if you use the VSCode editor,
you must use the “Open Folder” feature to open the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mathematica_examples&lt;/code&gt; directory.
Opening individual files will not work.
An easy way to do this from the command line,
starting in the same directory you started in above, is&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;code mathematica_examples
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;examples-of-calling-lean-from-mathematica&quot;&gt;Examples of calling Lean from Mathematica&lt;/h2&gt;

&lt;p&gt;These examples and the code to make them work are on &lt;a href=&quot;https://github.com/minchaowu/mm_lean&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As above, it is easiest to install using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leanproject&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leanproject get minchaowu/mm_lean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LeanProof.nb&lt;/code&gt; in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mm_lean&lt;/code&gt; directory contains examples of the
Lean-from-Mathematica link.
You will need to evaluate the first few configuration lines
to start a Lean server;
after that, the examples below can be tried in any order.&lt;/p&gt;

&lt;h2 id=&quot;possible-issues&quot;&gt;Possible issues&lt;/h2&gt;

&lt;p&gt;The Mathematica-from-Lean link expects a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python3&lt;/code&gt; executable in the path. Create an alias if you do
not have this.&lt;/p&gt;

&lt;p&gt;The link communicates over port 10000. If this is taken, change the port numbers in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client2.py&lt;/code&gt; and
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server2.m&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are known issues with Mathematica’s socket server functionality on certain versions of Linux.
This may cause the server to use excess CPU.&lt;/p&gt;

&lt;h2 id=&quot;additional-information&quot;&gt;Additional information&lt;/h2&gt;
&lt;p&gt;The full, unabbreviated form of the expression &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x^2-2*x+1&lt;/code&gt; in Lean is&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app (app (app (app (const (name.mk_string add (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_add (name.mk_string distrib (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_distrib (name.mk_string ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ring (name.mk_string division_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_division_ring (name.mk_string field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_field (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil)))))))) (app (app (app (app (const (name.mk_string sub (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string add_group_has_sub (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_add_group (name.mk_string add_comm_group (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_add_comm_group (name.mk_string ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ring (name.mk_string division_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_division_ring (name.mk_string field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_field (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil))))))))) (app (app (app (app (const (name.mk_string mul (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_mul (name.mk_string mul_zero_class (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_mul_zero_class (name.mk_string semiring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_semiring (name.mk_string ordered_semiring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ordered_semiring (name.mk_string ordered_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ordered_ring (name.mk_string linear_ordered_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_linear_ordered_ring (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil))))))))) (local_const (name.mk_numeral 1 (name.mk_numeral 18 (name.anonymous))) (name.mk_string x (name.anonymous)) (binder_info.default) (const (name.mk_string real (name.anonymous)) (level_list.nil)))) (local_const (name.mk_numeral 1 (name.mk_numeral 18 (name.anonymous))) (name.mk_string x (name.anonymous)) (binder_info.default) (const (name.mk_string real (name.anonymous)) (level_list.nil))))) (app (app (app (app (const (name.mk_string mul (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_mul (name.mk_string mul_zero_class (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_mul_zero_class (name.mk_string semiring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_semiring (name.mk_string ordered_semiring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ordered_semiring (name.mk_string ordered_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ordered_ring (name.mk_string linear_ordered_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_linear_ordered_ring (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil))))))))) (app (app (app (const (name.mk_string bit0 (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_add (name.mk_string distrib (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_distrib (name.mk_string ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ring (name.mk_string division_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_division_ring (name.mk_string field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_field (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil)))))))) (app (app (const (name.mk_string one (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_one (name.mk_string zero_ne_one_class (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_zero_ne_one_class (name.mk_string division_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_division_ring (name.mk_string field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_field (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil))))))))) (local_const (name.mk_numeral 1 (name.mk_numeral 18 (name.anonymous))) (name.mk_string x (name.anonymous)) (binder_info.default) (const (name.mk_string real (name.anonymous)) (level_list.nil)))))) (app (app (const (name.mk_string one (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_one (name.mk_string zero_ne_one_class (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_zero_ne_one_class (name.mk_string division_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_division_ring (name.mk_string field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_field (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil)))))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The Mathematica version of this same expression is:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;LeanApp[LeanApp[LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;add&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_add&quot;, LeanNameMkString[&quot;distrib&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_distrib&quot;, LeanNameMkString[&quot;ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ring&quot;, LeanNameMkString[&quot;division_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_division_ring&quot;, LeanNameMkString[&quot;field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_field&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]], LeanApp[LeanApp[LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;sub&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;add_group_has_sub&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_add_group&quot;, LeanNameMkString[&quot;add_comm_group&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_add_comm_group&quot;, LeanNameMkString[&quot;ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ring&quot;, LeanNameMkString[&quot;division_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_division_ring&quot;, LeanNameMkString[&quot;field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_field&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]]], LeanApp[LeanApp[LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;mul&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_mul&quot;, LeanNameMkString[&quot;mul_zero_class&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_mul_zero_class&quot;, LeanNameMkString[&quot;semiring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_semiring&quot;, LeanNameMkString[&quot;ordered_semiring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ordered_semiring&quot;, LeanNameMkString[&quot;ordered_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ordered_ring&quot;, LeanNameMkString[&quot;linear_ordered_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_linear_ordered_ring&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]]], LeanLocal[LeanNameMkNum[1843, LeanNameMkNum[17, LeanNameAnonymous]], LeanNameMkString[&quot;x&quot;, LeanNameAnonymous], BinderInfoDefault, LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]]], LeanLocal[LeanNameMkNum[1843, LeanNameMkNum[17, LeanNameAnonymous]], LeanNameMkString[&quot;x&quot;, LeanNameAnonymous], BinderInfoDefault, LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]]]], LeanApp[LeanApp[LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;mul&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_mul&quot;, LeanNameMkString[&quot;mul_zero_class&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_mul_zero_class&quot;, LeanNameMkString[&quot;semiring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_semiring&quot;, LeanNameMkString[&quot;ordered_semiring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ordered_semiring&quot;, LeanNameMkString[&quot;ordered_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ordered_ring&quot;, LeanNameMkString[&quot;linear_ordered_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_linear_ordered_ring&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]]], LeanApp[LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;bit0&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_add&quot;, LeanNameMkString[&quot;distrib&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_distrib&quot;, LeanNameMkString[&quot;ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ring&quot;, LeanNameMkString[&quot;division_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_division_ring&quot;, LeanNameMkString[&quot;field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_field&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;one&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_one&quot;, LeanNameMkString[&quot;zero_ne_one_class&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_zero_ne_one_class&quot;, LeanNameMkString[&quot;division_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_division_ring&quot;, LeanNameMkString[&quot;field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_field&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]]], LeanLocal[LeanNameMkNum[1843, LeanNameMkNum[17, LeanNameAnonymous]], LeanNameMkString[&quot;x&quot;, LeanNameAnonymous], BinderInfoDefault, LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]]]]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;one&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_one&quot;, LeanNameMkString[&quot;zero_ne_one_class&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_zero_ne_one_class&quot;, LeanNameMkString[&quot;division_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_division_ring&quot;, LeanNameMkString[&quot;field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_field&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Robert Y. Lewis</name><email>robert_lewis@brown.edu</email></author><category term="paper" /><summary type="html">Minchao Wu and I have been working on a project that connects the computer algebra system Mathematica to the Lean theorem prover. Here you will find the supplementary materials corresponding to our paper draft. An early version of this work was presented at PxTP. For more information, contact Robert Y. Lewis and Minchao Wu. Versioning These tools and examples are compatible with various versions of Lean. In any of the GitHub repositories, look for the lean-x.y.z branch for a version of the project compatible with Lean x.y.z. The core tool will automatically be updated to new versions of Lean as long as compatibility is maintained. Unfortunately this automatic upgrading is not possible for the example repositories due to licensing issues, but we will do it manually; please contact the authors if you need a fresh update on short notice, or try running leanproject up yourself. The link is known to work with Mathematica versions 11 and 12, and perhaps with earlier versions. The lean-3.17.1 branches, and any below, are frozen as of August 19, 2020. All claims in our paper draft have been tested to be true of this version, and we have not intentionally falsified any in later versions. Installing the link The link requires you to have Python installed with python3 in the system path. We strongly recommend installing Lean with the elan version manager and leanproject supporting tool, following the “regular install” instructions. The core tool for using Mathematica from Lean is available on GitHub. This project can be added as a dependency to any Lean project using the leanpkg package manager. Note that, if you install the project as a dependency using leanpkg, you do not need to download it separately. It will be downloaded automatically to the _target/deps/mathematica directory of your project. To use the link in this direction, you must start the Mathematica server. Do this either by running math --noprompt -run '&amp;lt;&amp;lt;&quot;server2.m&quot; in the _target/deps/mathematica/src directory of your project, or opening the Mathematica frontend and evaluating &amp;lt;&amp;lt;&quot;/path/to/_target/deps/mathematica/src/server2.m&quot; (with the correct path). The code for using Lean from Mathematica is also available on GitHub. This project uses the above as a dependency. See directions below for using it. Examples of calling Mathematica from Lean A project containing examples of the Mathematica-from-Lean link in action is available here. The easiest way to try this out is to download the project using leanproject: leanproject get robertylewis/mathematica_examples cd mathematica_examples/_target/deps/mathematica/src math --noprompt -run '&amp;lt;&amp;lt;&quot;server2.m&quot;' This will download the core link, the examples, Lean’s mathematical library mathlib (on which the examples depend), and precompiled binaries for mathlib. If you use an alternate installation method, you may have to compile mathlib yourself, which can take a long time. You can then see the link in action in any file in mathematica_examples/src. Note: if you use the VSCode editor, you must use the “Open Folder” feature to open the mathematica_examples directory. Opening individual files will not work. An easy way to do this from the command line, starting in the same directory you started in above, is code mathematica_examples Examples of calling Lean from Mathematica These examples and the code to make them work are on GitHub. As above, it is easiest to install using leanproject: leanproject get minchaowu/mm_lean The file LeanProof.nb in the mm_lean directory contains examples of the Lean-from-Mathematica link. You will need to evaluate the first few configuration lines to start a Lean server; after that, the examples below can be tried in any order. Possible issues The Mathematica-from-Lean link expects a python3 executable in the path. Create an alias if you do not have this. The link communicates over port 10000. If this is taken, change the port numbers in client2.py and server2.m. There are known issues with Mathematica’s socket server functionality on certain versions of Linux. This may cause the server to use excess CPU. Additional information The full, unabbreviated form of the expression x^2-2*x+1 in Lean is app (app (app (app (const (name.mk_string add (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_add (name.mk_string distrib (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_distrib (name.mk_string ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ring (name.mk_string division_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_division_ring (name.mk_string field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_field (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil)))))))) (app (app (app (app (const (name.mk_string sub (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string add_group_has_sub (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_add_group (name.mk_string add_comm_group (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_add_comm_group (name.mk_string ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ring (name.mk_string division_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_division_ring (name.mk_string field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_field (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil))))))))) (app (app (app (app (const (name.mk_string mul (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_mul (name.mk_string mul_zero_class (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_mul_zero_class (name.mk_string semiring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_semiring (name.mk_string ordered_semiring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ordered_semiring (name.mk_string ordered_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ordered_ring (name.mk_string linear_ordered_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_linear_ordered_ring (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil))))))))) (local_const (name.mk_numeral 1 (name.mk_numeral 18 (name.anonymous))) (name.mk_string x (name.anonymous)) (binder_info.default) (const (name.mk_string real (name.anonymous)) (level_list.nil)))) (local_const (name.mk_numeral 1 (name.mk_numeral 18 (name.anonymous))) (name.mk_string x (name.anonymous)) (binder_info.default) (const (name.mk_string real (name.anonymous)) (level_list.nil))))) (app (app (app (app (const (name.mk_string mul (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_mul (name.mk_string mul_zero_class (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_mul_zero_class (name.mk_string semiring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_semiring (name.mk_string ordered_semiring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ordered_semiring (name.mk_string ordered_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ordered_ring (name.mk_string linear_ordered_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_linear_ordered_ring (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil))))))))) (app (app (app (const (name.mk_string bit0 (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_add (name.mk_string distrib (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_distrib (name.mk_string ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_ring (name.mk_string division_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_division_ring (name.mk_string field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_field (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil)))))))) (app (app (const (name.mk_string one (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_one (name.mk_string zero_ne_one_class (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_zero_ne_one_class (name.mk_string division_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_division_ring (name.mk_string field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_field (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil))))))))) (local_const (name.mk_numeral 1 (name.mk_numeral 18 (name.anonymous))) (name.mk_string x (name.anonymous)) (binder_info.default) (const (name.mk_string real (name.anonymous)) (level_list.nil)))))) (app (app (const (name.mk_string one (name.anonymous)) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_has_one (name.mk_string zero_ne_one_class (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_zero_ne_one_class (name.mk_string division_ring (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_division_ring (name.mk_string field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (app (app (const (name.mk_string to_field (name.mk_string linear_ordered_field (name.anonymous))) (level_list.cons (level.zero) (level_list.nil))) (const (name.mk_string real (name.anonymous)) (level_list.nil))) (const (name.mk_string h (name.anonymous)) (level_list.nil))))))) The Mathematica version of this same expression is: &quot;LeanApp[LeanApp[LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;add&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_add&quot;, LeanNameMkString[&quot;distrib&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_distrib&quot;, LeanNameMkString[&quot;ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ring&quot;, LeanNameMkString[&quot;division_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_division_ring&quot;, LeanNameMkString[&quot;field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_field&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]], LeanApp[LeanApp[LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;sub&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;add_group_has_sub&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_add_group&quot;, LeanNameMkString[&quot;add_comm_group&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_add_comm_group&quot;, LeanNameMkString[&quot;ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ring&quot;, LeanNameMkString[&quot;division_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_division_ring&quot;, LeanNameMkString[&quot;field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_field&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]]], LeanApp[LeanApp[LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;mul&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_mul&quot;, LeanNameMkString[&quot;mul_zero_class&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_mul_zero_class&quot;, LeanNameMkString[&quot;semiring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_semiring&quot;, LeanNameMkString[&quot;ordered_semiring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ordered_semiring&quot;, LeanNameMkString[&quot;ordered_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ordered_ring&quot;, LeanNameMkString[&quot;linear_ordered_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_linear_ordered_ring&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]]], LeanLocal[LeanNameMkNum[1843, LeanNameMkNum[17, LeanNameAnonymous]], LeanNameMkString[&quot;x&quot;, LeanNameAnonymous], BinderInfoDefault, LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]]], LeanLocal[LeanNameMkNum[1843, LeanNameMkNum[17, LeanNameAnonymous]], LeanNameMkString[&quot;x&quot;, LeanNameAnonymous], BinderInfoDefault, LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]]]], LeanApp[LeanApp[LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;mul&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_mul&quot;, LeanNameMkString[&quot;mul_zero_class&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_mul_zero_class&quot;, LeanNameMkString[&quot;semiring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_semiring&quot;, LeanNameMkString[&quot;ordered_semiring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ordered_semiring&quot;, LeanNameMkString[&quot;ordered_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ordered_ring&quot;, LeanNameMkString[&quot;linear_ordered_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_linear_ordered_ring&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]]], LeanApp[LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;bit0&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_add&quot;, LeanNameMkString[&quot;distrib&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_distrib&quot;, LeanNameMkString[&quot;ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_ring&quot;, LeanNameMkString[&quot;division_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_division_ring&quot;, LeanNameMkString[&quot;field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_field&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;one&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_one&quot;, LeanNameMkString[&quot;zero_ne_one_class&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_zero_ne_one_class&quot;, LeanNameMkString[&quot;division_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_division_ring&quot;, LeanNameMkString[&quot;field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_field&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]]], LeanLocal[LeanNameMkNum[1843, LeanNameMkNum[17, LeanNameAnonymous]], LeanNameMkString[&quot;x&quot;, LeanNameAnonymous], BinderInfoDefault, LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]]]]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;one&quot;, LeanNameAnonymous], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_has_one&quot;, LeanNameMkString[&quot;zero_ne_one_class&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_zero_ne_one_class&quot;, LeanNameMkString[&quot;division_ring&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_division_ring&quot;, LeanNameMkString[&quot;field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanApp[LeanApp[LeanConst[LeanNameMkString[&quot;to_field&quot;, LeanNameMkString[&quot;linear_ordered_field&quot;, LeanNameAnonymous]], LeanLevelListCons[LeanZeroLevel, LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;real&quot;, LeanNameAnonymous], LeanLevelListNil]], LeanConst[LeanNameMkString[&quot;h&quot;, LeanNameAnonymous], LeanLevelListNil]]]]]]]</summary></entry><entry><title type="html">The Nature of Mathematical Reasoning</title><link href="http://localhost:4000/pages-test/teaching/nomr/" rel="alternate" type="text/html" title="The Nature of Mathematical Reasoning" /><published>2015-05-30T02:00:00-07:00</published><updated>2015-05-30T02:00:00-07:00</updated><id>http://localhost:4000/pages-test/teaching/nomr</id><content type="html" xml:base="http://localhost:4000/pages-test/teaching/nomr/">&lt;p&gt;In 2015 I tought a course at Carnegie Mellon titled &lt;em&gt;The Nature of Mathematical Reasoning.&lt;/em&gt; This
course, aimed at non-mathematicians, took a philosophical look at the historical and modern practice
of mathematics. The course materials can be found &lt;a href=&quot;http://localhost:4000/80110&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I haven’t transferred the course materials to my new website design yet. This page is to preserve a
link from the main site to the materials.&lt;/p&gt;</content><author><name>Robert Y. Lewis</name><email>robert_lewis@brown.edu</email></author><category term="teaching" /><summary type="html">In 2015 I tought a course at Carnegie Mellon titled The Nature of Mathematical Reasoning. This course, aimed at non-mathematicians, took a philosophical look at the historical and modern practice of mathematics. The course materials can be found here. I haven’t transferred the course materials to my new website design yet. This page is to preserve a link from the main site to the materials.</summary></entry></feed>